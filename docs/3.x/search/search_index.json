{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Solital is a fast, easy-to-use PHP framework and also has an easy-to-learn syntax. Created in 2020, Solital emerged as a lighter and simpler alternative to other frameworks available on the market such as Laravel, Symfony and CodeIgniter. Solital Framework has several features to help you create PHP projects with fast performance. Vinci Console is a component to help create, remove, update components. Wolf is Solital's default template engine, as well as being quick to render views. Database manipulation is also possible using Katrina ORM, migations and seeders. You can still use several other components present in Solital Framework. Current version You are reading the version documentation: 3.x Requirements PHP >=8.0 PHP JSON extension enabled PHP PDO extension enabled Features Basic routing (GET, POST, PUT, PATCH, UPDATE, DELETE) with support for custom multiple verbs. Regular Expression Constraints for parameters. Wolf template system. HTTP client manipulation. Vinci Console. Middleware (classes that intercepts before the route is rendered). ORM for database persistence. CSRF protection. Sub-domain routing Custom boot managers to rewrite urls to \"nicer\" ones. Input manager; easily manage GET, POST and FILE values. PSR-3, PSR-6, PSR-11, PSR-14 and PSR-16. Migrations and Seeders And more...","title":"Starting"},{"location":"#current-version","text":"You are reading the version documentation: 3.x","title":"Current version"},{"location":"#requirements","text":"PHP >=8.0 PHP JSON extension enabled PHP PDO extension enabled","title":"Requirements"},{"location":"#features","text":"Basic routing (GET, POST, PUT, PATCH, UPDATE, DELETE) with support for custom multiple verbs. Regular Expression Constraints for parameters. Wolf template system. HTTP client manipulation. Vinci Console. Middleware (classes that intercepts before the route is rendered). ORM for database persistence. CSRF protection. Sub-domain routing Custom boot managers to rewrite urls to \"nicer\" ones. Input manager; easily manage GET, POST and FILE values. PSR-3, PSR-6, PSR-11, PSR-14 and PSR-16. Migrations and Seeders And more...","title":"Features"},{"location":"authenticate/","text":"At first, you have the option to change the index where Solital will store the login in the .env file. INDEX_LOGIN='solital_index_login' Defining the routes You can define dashboard and login routes. The dashboard route will be for when the user authenticates, and the login route will be for when the user logs off and will be redirected to it. To do this, open the auth.yaml file and edit the auth_dashboard_url and auth_login_url variables. auth: auth_dashboard_url: /dashboard auth_login_url: /auth Setting For this, it is necessary to first define the name of the table in the login method. In the columns method, the database username and password. Then, in the values method, the input values of the form. Finally, the register method will perform the login as shown below. $res = Auth::login('auth_users') ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register(); The $res variable will return true if authentication is true. But if it is false , you can add a reply message after the above code if authentication fails. if ($res == false) { message('login', 'Invalid username and/or password!'); response()->redirect('your_login_url'); } Below is an example method of authentication. <?php namespace Solital\\Components\\Controller; use Solital\\Core\\Http\\Controller\\Controller; use Solital\\Core\\Auth\\Auth; class UserController extends Controller { /** * @return void */ public function authPost(): void { $res = Auth::login('auth_users') ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register(); if ($res == false) { message('login', 'Invalid username and/or password!'); response()->redirect(url('auth')); } } } Changing default routes If you need more routes for dashboards and logins, you can change the parameter in the register() function: # In routers.php Course::get('/my-second-dashboard', 'SiteController@SecondDashboard')->name('second.dashboard'); # In Controller $res = Auth::login('auth_users') ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register(url('second.dashboard')); # Or $res = Auth::login('auth_users') ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register('/my-second-dashboard'); Check login To ensure that the user is authenticated, use the Auth::isNotLogged() method. If the login has not been validated, the user will be redirected to the route defined in the auth.yaml file or to the /login route. /** * @return mixed */ public function dashboard(): mixed { Auth::isNotLogged(); return view('dashboard'); } To ensure that the user doesn't fall into the login route when it has already been validated, insert the Auth::isLogged() method in your login route. This method will redirect the user to your system's dashboard. /** * @return mixed */ public function auth(): mixed { Auth::isLogged(); return view('login'); } Logoff To logoff, use the Auth::logoff() method. /** * @return void */ public function exit(): void { Auth::logoff(); } Standard login structure To create a predefined login structure, use php vinci auth:skeleton --login This command will create a LoginController class, templates for authentication, dashboard and predefined routes. Plus a standard user in the database. If you want to remove this structure, use php vinci auth:skeleton --login --remove . Authentication using Sodium encryption You can create an authentication using Sodium encryption. Generating a sodium key First, you need to generate a sodium key. This key is automatically renewed with each new request, so it can be stored in a database, in the session or in another type of storage. use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); Encrypting the password Use Auth::sodium() to encrypt your password. Remember to use it in conjunction with the generated key. use Solital\\Core\\Auth\\Auth; use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); $encoded = Auth::sodium('password', $key); pre($encoded); Verifying the password with Sodium To verify the password generated using the Auth::sodium() method, use Auth::sodiumVerify() together with the generated key, password and hash. use Solital\\Core\\Auth\\Auth; use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); $encoded = Auth::sodium('password', $key); $decoded = Auth::sodiumVerify($encoded, 'password', $key); pre($decoded);","title":"Authenticate"},{"location":"authenticate/#defining-the-routes","text":"You can define dashboard and login routes. The dashboard route will be for when the user authenticates, and the login route will be for when the user logs off and will be redirected to it. To do this, open the auth.yaml file and edit the auth_dashboard_url and auth_login_url variables. auth: auth_dashboard_url: /dashboard auth_login_url: /auth","title":"Defining the routes"},{"location":"authenticate/#setting","text":"For this, it is necessary to first define the name of the table in the login method. In the columns method, the database username and password. Then, in the values method, the input values of the form. Finally, the register method will perform the login as shown below. $res = Auth::login('auth_users') ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register(); The $res variable will return true if authentication is true. But if it is false , you can add a reply message after the above code if authentication fails. if ($res == false) { message('login', 'Invalid username and/or password!'); response()->redirect('your_login_url'); } Below is an example method of authentication. <?php namespace Solital\\Components\\Controller; use Solital\\Core\\Http\\Controller\\Controller; use Solital\\Core\\Auth\\Auth; class UserController extends Controller { /** * @return void */ public function authPost(): void { $res = Auth::login('auth_users') ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register(); if ($res == false) { message('login', 'Invalid username and/or password!'); response()->redirect(url('auth')); } } }","title":"Setting"},{"location":"authenticate/#changing-default-routes","text":"If you need more routes for dashboards and logins, you can change the parameter in the register() function: # In routers.php Course::get('/my-second-dashboard', 'SiteController@SecondDashboard')->name('second.dashboard'); # In Controller $res = Auth::login('auth_users') ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register(url('second.dashboard')); # Or $res = Auth::login('auth_users') ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register('/my-second-dashboard');","title":"Changing default routes"},{"location":"authenticate/#check-login","text":"To ensure that the user is authenticated, use the Auth::isNotLogged() method. If the login has not been validated, the user will be redirected to the route defined in the auth.yaml file or to the /login route. /** * @return mixed */ public function dashboard(): mixed { Auth::isNotLogged(); return view('dashboard'); } To ensure that the user doesn't fall into the login route when it has already been validated, insert the Auth::isLogged() method in your login route. This method will redirect the user to your system's dashboard. /** * @return mixed */ public function auth(): mixed { Auth::isLogged(); return view('login'); }","title":"Check login"},{"location":"authenticate/#logoff","text":"To logoff, use the Auth::logoff() method. /** * @return void */ public function exit(): void { Auth::logoff(); }","title":"Logoff"},{"location":"authenticate/#standard-login-structure","text":"To create a predefined login structure, use php vinci auth:skeleton --login This command will create a LoginController class, templates for authentication, dashboard and predefined routes. Plus a standard user in the database. If you want to remove this structure, use php vinci auth:skeleton --login --remove .","title":"Standard login structure"},{"location":"authenticate/#authentication-using-sodium-encryption","text":"You can create an authentication using Sodium encryption.","title":"Authentication using Sodium encryption"},{"location":"authenticate/#generating-a-sodium-key","text":"First, you need to generate a sodium key. This key is automatically renewed with each new request, so it can be stored in a database, in the session or in another type of storage. use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey();","title":"Generating a sodium key"},{"location":"authenticate/#encrypting-the-password","text":"Use Auth::sodium() to encrypt your password. Remember to use it in conjunction with the generated key. use Solital\\Core\\Auth\\Auth; use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); $encoded = Auth::sodium('password', $key); pre($encoded);","title":"Encrypting the password"},{"location":"authenticate/#verifying-the-password-with-sodium","text":"To verify the password generated using the Auth::sodium() method, use Auth::sodiumVerify() together with the generated key, password and hash. use Solital\\Core\\Auth\\Auth; use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); $encoded = Auth::sodium('password', $key); $decoded = Auth::sodiumVerify($encoded, 'password', $key); pre($decoded);","title":"Verifying the password with Sodium"},{"location":"cache/","text":"Cache is a layer of high-speed physical data storage that holds a subset of data, usually temporary in nature, so that future requests for that data are answered more quickly than is possible when accessing the primary storage location of data. Caching allows you to efficiently reuse previously recovered or computed data. How to use - PSR6/PSR-16 PSR-6 To use the PSR-6, you can follow the step by step guide here use Solital\\Core\\Cache\\Psr6\\CachePool; $pool = new CachePool(); $item = $pool->getItem('aaa'); $item->set(123); $pool->commit(); PSR-16 You can cache through PSR-16. To do this, perform the instance of the Cache class as follows: use Solital\\Cache\\SimpleCache; $cache = new SimpleCache(); $list = User::select()->get(); // The 'has' method checks whether the index exists if ($cache->has('list') == true) { echo '<h1>from cache</h1>'; // The 'get' method returns the cached value if it exists $cache->get('list'); } else { echo '<h1>created cache</h1>'; // The 'set' method creates the cached file $cache->set('list', $list, 20); } // Displays the original content of the $list variable echo '<h1>from original</h1>'; var_dump($list); To delete the cache that was created, use the delete method passing the cache key as a parameter. $cache->delete('list'); The has method checks whether the item key exists. If it exists, use the get method to retrieve the generated cache by passing the key value as a parameter. If it does not exist, the set method creates the cached file, passing in the first parameter the name of the key, the value that will be stored and the time (in int ) that this cached file will be valid. The syntax is similar to the single cache. But the getMultiple method needs an array containing the key values as a parameter. The setMultiple method generates the cache if it does not exist, but pass as an parameter an array in which the keys will be the indexes of the array, and in the last parameter spend the time that the cache will be valid. use Solital\\Cache\\SimpleCache; $cache = new SimpleCache(); $list = [ 'nome' => 'Harvey Specter', 'email' => 'specter@pearsonhardman.com' ]; $list2 = [ 'nome' => 'Louis Litt', 'email' => 'liitup@pearsonhardman.com' ]; $cache->getMultiple(['list1', 'list2']); echo '<h1>created cache</h1>'; $cache->setMultiple([ 'list1' => $list, 'list2' => $list2 ], 20); echo '<h1>from original</h1>'; print_r($list); print_r($list2); In the multiple cache, use deleteMultiple by passing an array containing the cache keys to delete the cached files generated with the setMultiple method. $cache->deleteMultiple([\"list1\", \"list2\"]); Clear cache To clear the entire cache created with the Cache class, use the clear function. $cache->clear(); HTTP Cache Font by heroku The modern day developer has a wide variety of techniques and technologies available to improve application performance and end-user experience. One of the most frequently overlooked technologies is that of the HTTP cache. HTTP caching is a universally adopted specification across all modern web browsers, making its implementation in web applications simple. Appropriate use of these standards can benefit your application greatly, improving response times and reducing server load. However, incorrect caching can cause users to see out-of-date content and hard to debug issues. This article discusses the specifics of HTTP caching and in what scenarios to employ an HTTP cache header based strategy. use Solital\\Core\\Http\\HttpCache; $cache = new HttpCache(); Cache-Control The Cache-Control header is the most important header to set as it effectively \u2018switches on\u2019 caching in the browser. With this header in place, and set with a value that enables caching, the browser will cache the file for as long as specified. Without this header the browser will re-request the file on each subsequent request. public resources can be cached not only by the end-user\u2019s browser but also by any intermediate proxies that may be serving many other users as well. private resources are bypassed by intermediate proxies and can only be cached by the end-client. The value of the Cache-Control header is a composite one, indicating whether the resource is public or private while also indicating the maximum amount of time it can be cached before considered stale. The max-age value sets a timespan for how long to cache the resource (in seconds). In the first parameter it is necessary to inform public or private , and in the second parameter the timestamp value of max_age . $cache->cacheControl(\"public\", 31536000); While the Cache-Control header turns on client-side caching and sets the max-age of a resource the Expires header is used to specify a specific point in time the resource is no longer valid. Expires When accompanying the Cache-Control header, Expires simply sets a date from which the cached resource should no longer be considered valid. From this date forward the browser will request a fresh copy of the resource. Until then, the browsers local cached copy will be used: $cache->cacheControl(\"public\", 31536000); $cache->expires(); Time-based A time-based conditional request ensures that only if the requested resource has changed since the browser\u2019s copy was cached will the contents be transferred. If the cached copy is the most up-to-date then the server returns the 304 response code. To enable conditional requests the application specifies the last modified time of a resource via the Last-Modified response header. To use this condition, use the lastModified method after the cacheControl method. $cache->cacheControl(\"public\", 31536000); $cache->lastModified(); The next time the browser requests this resource it will only ask for the contents of the resource if they\u2019re unchanged since this date using the If-Modified-Since request header $cache->ifModifiedSince(); If the resource hasn\u2019t changed, the server will return with an empty body with the 304 response code. Etag The ETag (or Entity Tag) works in a similar way to the Last-Modified header except its value is a digest of the resources contents (for instance, an MD5 hash). This allows the server to identify if the cached contents of the resource are different to the most recent version. Use the eTag class parameter the value that will be cached. $cache->cacheControl(\"public\", 31536000); $cache->eTag('value'); Cache prevention Highly secure or variable resources often require no caching. For instance, anything involving a shopping cart checkout process. Unfortunately, merely omitting cache headers will not work as many modern web browsers cache items based on their own internal algorithms. In such cases it is necessary to tell the browser to explicitly to not cache items. In addition to public and private the Cache-Control header can specify no-cache and no-store which informs the browser to not cache the resources under any circumstances. $cache->noCacheControl(); Clear Solital Cache When using your project several times, it is common for several stored session files to appear. These files are located inside the app/Storage/session folder. If you are using the Wolf cache, then these files can double in size. If you need to, you can use the Vinci Console to clear the general cache, just the session cache, or just the Wolf cache. To clear the general cache, use: php vinci cache:clear If you only want to clear the session cache, use the --session option: php vinci cache:clear --session And to clear the cache of the app/Storage/cache/* folder, use the --cache option: php vinci cache:clear --cache","title":"Cache"},{"location":"cache/#how-to-use-psr6psr-16","text":"PSR-6 To use the PSR-6, you can follow the step by step guide here use Solital\\Core\\Cache\\Psr6\\CachePool; $pool = new CachePool(); $item = $pool->getItem('aaa'); $item->set(123); $pool->commit(); PSR-16 You can cache through PSR-16. To do this, perform the instance of the Cache class as follows: use Solital\\Cache\\SimpleCache; $cache = new SimpleCache(); $list = User::select()->get(); // The 'has' method checks whether the index exists if ($cache->has('list') == true) { echo '<h1>from cache</h1>'; // The 'get' method returns the cached value if it exists $cache->get('list'); } else { echo '<h1>created cache</h1>'; // The 'set' method creates the cached file $cache->set('list', $list, 20); } // Displays the original content of the $list variable echo '<h1>from original</h1>'; var_dump($list); To delete the cache that was created, use the delete method passing the cache key as a parameter. $cache->delete('list'); The has method checks whether the item key exists. If it exists, use the get method to retrieve the generated cache by passing the key value as a parameter. If it does not exist, the set method creates the cached file, passing in the first parameter the name of the key, the value that will be stored and the time (in int ) that this cached file will be valid. The syntax is similar to the single cache. But the getMultiple method needs an array containing the key values as a parameter. The setMultiple method generates the cache if it does not exist, but pass as an parameter an array in which the keys will be the indexes of the array, and in the last parameter spend the time that the cache will be valid. use Solital\\Cache\\SimpleCache; $cache = new SimpleCache(); $list = [ 'nome' => 'Harvey Specter', 'email' => 'specter@pearsonhardman.com' ]; $list2 = [ 'nome' => 'Louis Litt', 'email' => 'liitup@pearsonhardman.com' ]; $cache->getMultiple(['list1', 'list2']); echo '<h1>created cache</h1>'; $cache->setMultiple([ 'list1' => $list, 'list2' => $list2 ], 20); echo '<h1>from original</h1>'; print_r($list); print_r($list2); In the multiple cache, use deleteMultiple by passing an array containing the cache keys to delete the cached files generated with the setMultiple method. $cache->deleteMultiple([\"list1\", \"list2\"]);","title":"How to use - PSR6/PSR-16"},{"location":"cache/#clear-cache","text":"To clear the entire cache created with the Cache class, use the clear function. $cache->clear();","title":"Clear cache"},{"location":"cache/#http-cache","text":"Font by heroku The modern day developer has a wide variety of techniques and technologies available to improve application performance and end-user experience. One of the most frequently overlooked technologies is that of the HTTP cache. HTTP caching is a universally adopted specification across all modern web browsers, making its implementation in web applications simple. Appropriate use of these standards can benefit your application greatly, improving response times and reducing server load. However, incorrect caching can cause users to see out-of-date content and hard to debug issues. This article discusses the specifics of HTTP caching and in what scenarios to employ an HTTP cache header based strategy. use Solital\\Core\\Http\\HttpCache; $cache = new HttpCache();","title":"HTTP Cache"},{"location":"cache/#cache-control","text":"The Cache-Control header is the most important header to set as it effectively \u2018switches on\u2019 caching in the browser. With this header in place, and set with a value that enables caching, the browser will cache the file for as long as specified. Without this header the browser will re-request the file on each subsequent request. public resources can be cached not only by the end-user\u2019s browser but also by any intermediate proxies that may be serving many other users as well. private resources are bypassed by intermediate proxies and can only be cached by the end-client. The value of the Cache-Control header is a composite one, indicating whether the resource is public or private while also indicating the maximum amount of time it can be cached before considered stale. The max-age value sets a timespan for how long to cache the resource (in seconds). In the first parameter it is necessary to inform public or private , and in the second parameter the timestamp value of max_age . $cache->cacheControl(\"public\", 31536000); While the Cache-Control header turns on client-side caching and sets the max-age of a resource the Expires header is used to specify a specific point in time the resource is no longer valid.","title":"Cache-Control"},{"location":"cache/#expires","text":"When accompanying the Cache-Control header, Expires simply sets a date from which the cached resource should no longer be considered valid. From this date forward the browser will request a fresh copy of the resource. Until then, the browsers local cached copy will be used: $cache->cacheControl(\"public\", 31536000); $cache->expires();","title":"Expires"},{"location":"cache/#time-based","text":"A time-based conditional request ensures that only if the requested resource has changed since the browser\u2019s copy was cached will the contents be transferred. If the cached copy is the most up-to-date then the server returns the 304 response code. To enable conditional requests the application specifies the last modified time of a resource via the Last-Modified response header. To use this condition, use the lastModified method after the cacheControl method. $cache->cacheControl(\"public\", 31536000); $cache->lastModified(); The next time the browser requests this resource it will only ask for the contents of the resource if they\u2019re unchanged since this date using the If-Modified-Since request header $cache->ifModifiedSince(); If the resource hasn\u2019t changed, the server will return with an empty body with the 304 response code.","title":"Time-based"},{"location":"cache/#etag","text":"The ETag (or Entity Tag) works in a similar way to the Last-Modified header except its value is a digest of the resources contents (for instance, an MD5 hash). This allows the server to identify if the cached contents of the resource are different to the most recent version. Use the eTag class parameter the value that will be cached. $cache->cacheControl(\"public\", 31536000); $cache->eTag('value');","title":"Etag"},{"location":"cache/#cache-prevention","text":"Highly secure or variable resources often require no caching. For instance, anything involving a shopping cart checkout process. Unfortunately, merely omitting cache headers will not work as many modern web browsers cache items based on their own internal algorithms. In such cases it is necessary to tell the browser to explicitly to not cache items. In addition to public and private the Cache-Control header can specify no-cache and no-store which informs the browser to not cache the resources under any circumstances. $cache->noCacheControl();","title":"Cache prevention"},{"location":"cache/#clear-solital-cache","text":"When using your project several times, it is common for several stored session files to appear. These files are located inside the app/Storage/session folder. If you are using the Wolf cache, then these files can double in size. If you need to, you can use the Vinci Console to clear the general cache, just the session cache, or just the Wolf cache. To clear the general cache, use: php vinci cache:clear If you only want to clear the session cache, use the --session option: php vinci cache:clear --session And to clear the cache of the app/Storage/cache/* folder, use the --cache option: php vinci cache:clear --cache","title":"Clear Solital Cache"},{"location":"collection/","text":"Collection is a feature of Solital for creating custom data. It will make your life easier by providing personalized data without complexity in your data. Let's see a quick example: use Solital\\Core\\Resource\\Collection\\ArrayCollection; $values = [ ['account_id' => 'account-x10', 'product' => 'Chair'], ['account_id' => 'account-x10', 'product' => 'Bookcase'], ['account_id' => 'account-x11', 'product' => 'Desk'], ]; $collection = new ArrayCollection($values); // Or use helper $collection = collection($values); $grouped = $collection->groupBy('account_id')->toArray(); pre($grouped); OUTPUT Array ( [account-x10] => Array ( [0] => Array ( [account_id] => account-x10 [product] => Chair ) [1] => Array ( [account_id] => account-x10 [product] => Bookcase ) ) [account-x11] => Array ( [0] => Array ( [account_id] => account-x11 [product] => Desk ) ) ) all() The all method returns the underlying array represented by the data array: collection([1, 2, 3])->all(); avg() The avg method returns the average value of a given key: collection([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->avg('foo'); Output 20 collection([1, 1, 2, 4])->avg(); Output 2 chunk() The chunk method breaks into multiple collection([1, 2, 3, 4, 5, 6, 7]); $chunks = $make_data->chunk(4); $chunks->toArray(); Output [[1, 2, 3, 4], [5, 6, 7]] collapse() The collapse method collapses a data array of arrays into a single, flat data array: collection([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); $collapsed = $make_data->collapse(); $collapsed->all(); Output [1, 2, 3, 4, 5, 6, 7, 8, 9] combine() The combine method combines the values of the data array, as keys, with the values of another array or data array: collection(['name', 'age']); $combined = $make_data->combine(['George', 29]); $combined->all(); Output ['name' => 'George', 'age' => 29] concat() The concat method appends the given array or data array values onto the end of the data array: collection(['John Doe']); $concatenated = $make_data->concat(['Jane Doe'])->concat(['name' => 'Johnny Doe']); $concatenated->all(); Output ['John Doe', 'Jane Doe', 'Johnny Doe'] contains() The contains method determines whether the make_data contains a given item: collection(['name' => 'Desk', 'price' => 100]); $make_data->contains('Desk'); $make_data->contains('New York'); Output true false count() The count method returns the total number of items in the data array: collection([1, 2, 3, 4]); $make_data->count(); Output 4 countBy() The countBy method counts the occurences of values in the make_data. By default, the method counts the occurrences of every element: collection([1, 2, 2, 2, 3]); $counted = $make_data->countBy(); $counted->all(); Output [1 => 1, 2 => 3, 3 => 1] diff() The diff method compares the data array against another data array or a plain PHP array based on its values. This method will return the values in the original data that are not present in the given data array: collection([1, 2, 3, 4, 5]); $diff = $make_data->diff([2, 4, 6, 8]); $diff->all(); Output [1, 3, 5] diffAssoc() The diffAssoc method compares the data array against another data array or a plain PHP array based on its keys and values. This method will return the key / value pairs in the original data array that are not present in the given data array: collection([ 'color' => 'orange', 'type' => 'fruit', 'remain' => 6 ]); $diff = $make_data->diffAssoc([ 'color' => 'yellow', 'type' => 'fruit', 'remain' => 3, 'used' => 6 ]); $diff->all(); Output ['color' => 'orange', 'remain' => 6] diffKeys() The diffKeys method compares the data array against another data array or a plain PHP array based on its keys. This method will return the key / value pairs in the original data array that are not present in the given data array collection([ 'one' => 10, 'two' => 20, 'three' => 30, 'four' => 40, 'five' => 50, ]); $diff = $diff->diffKeys([ 'two' => 2, 'four' => 4, 'six' => 6, 'eight' => 8, ]); $diff->all(); Output ['one' => 10, 'three' => 30, 'five' => 50] except() The except method returns all items in the data array except for those with the specified keys: collection(['product_id' => 1, 'price' => 100, 'discount' => false]); $filtered = $make_data->except(['price', 'discount']); $filtered->all(); Output ['product_id' => 1] except_multiple() The except_multiple method returns all items in the data array except for those with the specified keys: collection([['product_id' => 1, 'price' => 100, 'discount' => false],['product_id' => 2, 'price' => 500, 'discount' => true]]); $filtered = $make_data->except_multiple(['price', 'discount']); $filtered->all(); Output Array ( [0] => Array ( [product_id] => 1 ) [1] => Array ( [product_id] => 2 ) ) filter() The filter method filters the data array using the given callback, keeping only those items that pass a given truth test: collection([1, 2, 3, 4]); $filtered = $make_data->filter(function ($value, $key) { return $value > 2; }); $filtered->all(); Output [3, 4] first() The first method returns the first element in the data array that passes a given truth test: collection([1, 2, 3, 4])->first(function ($value, $key) { return $value > 2; }); Output 3 firstWhere() The firstWhere method returns the first element in the data array with the given key / value pair: collection([ ['name' => 'Regena', 'age' => null], ['name' => 'Linda', 'age' => 14], ['name' => 'Diego', 'age' => 23], ['name' => 'Linda', 'age' => 84], ]); $make_data->firstWhere('name', 'Linda'); Output ['name' => 'Linda', 'age' => 14] flatMap() The flatMap method iterates through the data array and passes each value to the given callback. The callback is free to modify the item and return it, thus forming a new data array of modified items. Then, the array is flattened by a level: collection([ ['name' => 'Sally'], ['school' => 'Arkansas'], ['age' => 28] ]); $flattened = $make_data->flatMap(function ($values) { return array_map('strtoupper', $values); }); $flattened->all(); Output ['name' => 'SALLY', 'school' => 'ARKANSAS', 'age' => '28']; flatten() The flatten method flattens a multi-dimensional data array into a single dimension: collection(['name' => 'jony', 'languages' => ['php', 'javascript']]); $flattened = $make_data->flatten(); $flattened->all(); Output ['jony', 'php', 'javascript']; flip() The flip method swaps the data arrays's keys with their corresponding values: collection(['name' => 'Jony', 'library' => 'array_master']); $flipped = $make_data->flip(); $flipped->all(); Output ['jony' => 'name', 'array_master' => 'library'] forget() The forget method removes an item from the data array by its key: collection(['name' => 'Jony', 'library' => 'array_master']); $make_data->forget('name'); $make_data->all(); Output ['library' => 'array_master'] get() The get method returns the item at a given key. If the key does not exist, null is returned: collection(['name' => 'Jony', 'library' => 'array_master']); $value = $make_data->get('name'); Output Jony groupBy() The groupBy method groups the data arrays's items by a given key: collection([ ['account_id' => 'account-x10', 'product' => 'Chair'], ['account_id' => 'account-x10', 'product' => 'Bookcase'], ['account_id' => 'account-x11', 'product' => 'Desk'], ]); $grouped = $make_data->groupBy('account_id'); $grouped->toArray(); Output [ 'account-x10' => [ ['account_id' => 'account-x10', 'product' => 'Chair'], ['account_id' => 'account-x10', 'product' => 'Bookcase'], ], 'account-x11' => [ ['account_id' => 'account-x11', 'product' => 'Desk'], ], ] has() The has method determines if a given key exists in the data array: collection(['account_id' => 1, 'product' => 'Desk', 'amount' => 5]); $make_data->has('product'); Output true implode() The implode method joins the items in a dara array. Its arguments depend on the type of items in the dara array. If the data array contains arrays or objects, you should pass the key of the attributes you wish to join, and the \"glue\" string you wish to place between the values: collection([ ['account_id' => 1, 'product' => 'Desk'], ['account_id' => 2, 'product' => 'Chair'], ]); $make_data->implode('product', ', '); Output Desk, Chair intersect() The intersect method removes any values from the original data array that are not present in the given array or dara array. The resulting data array will preserve the original dara array's keys: collection(['Desk', 'Sofa', 'Chair']); $intersect = $make_data->intersect(['Desk', 'Chair', 'Bookcase']); $intersect->all(); Output [0 => 'Desk', 2 => 'Chair'] intersectByKeys() The intersectByKeys method removes any keys from the original data array that are not present in the given array or dara array: collection([ 'serial' => 'UX301', 'type' => 'screen', 'year' => 2009 ]); $intersect = $make_data->intersectByKeys([ 'reference' => 'UX404', 'type' => 'tab', 'year' => 2011 ]); $intersect->all(); Output ['type' => 'screen', 'year' => 2009] isEmpty() The isEmpty method returns true if the data array is empty; otherwise, false is returned: collection([])->isEmpty(); Output true isNotEmpty() The isNotEmpty method returns true if the data array is not empty; otherwise, false is returned: collection([])->isNotEmpty(); Output false keyBy() The keyBy method keys the data array by the given key. If multiple items have the same key, only the last one will appear in the new dara array: collection([ ['product_id' => 'prod-100', 'name' => 'Desk'], ['product_id' => 'prod-200', 'name' => 'Chair'], ]); $keyed = $make_data->keyBy('product_id'); $keyed->all(); Output [ 'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'], 'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'], ] keys() The keys method returns all of the data array's keys: collection([ 'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'], 'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'], ]); $keys = $make_data->keys(); Output ['prod-100', 'prod-200'] last() The last method returns the last element in the data array that passes a given truth test: collection([1, 2, 3, 4])->last(); Output 4 map() The map method iterates through the data array and passes each value to the given callback. The callback is free to modify the item and return it, thus forming a new data array of modified items: collection([1, 2, 3, 4, 5]); $multiplied = $make_data->map(function ($item, $key) { return $item * 2; }); $multiplied->all(); Output [2, 4, 6, 8, 10] mapWithKeys() collection([ [ 'name' => 'John', 'department' => 'Sales', 'email' => 'john@example.com' ], [ 'name' => 'Jane', 'department' => 'Marketing', 'email' => 'jane@example.com' ] ]); $keyed = $make_data->mapWithKeys(function ($item) { return [$item['email'] => $item['name']]; }); $keyed->all(); Output [ 'john@example.com' => 'John', 'jane@example.com' => 'Jane', ] max() The max method returns the maximum value of a given key: collection([['foo' => 10], ['foo' => 20]])->max('foo'); collection([['foo' => 10], ['foo' => 30]])->max('foo'); Output 20 30 median() The median method returns the median value of a given key: collection([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->median('foo'); Output 15 merge() collection(['product_id' => 1, 'price' => 100]); $merged = $make_data->merge(['price' => 200, 'discount' => false]); $merged->all(); Output ['product_id' => 1, 'price' => 200, 'discount' => false] min() The min method returns the minimum value of a given key: collection([['foo' => 10], ['foo' => 20]])->min('foo'); collection([1, 2, 3, 4, 5])->min(); Output 10 1 mode() The mode method returns the mode value of a given key: collection([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->mode('foo'); collection([1, 1, 2, 4])->mode(); Output [10] [1] only() The only method returns the items in the data array with the specified keys: collection(['product_id' => 1, 'name' => 'Desk', 'price' => 100, 'discount' => false]); $filtered = $make_data->only(['product_id', 'name']); $filtered->all(); Output ['product_id' => 1, 'name' => 'Desk'] pad() collection(['A', 'B', 'C']); $filtered = $make_data->pad(5, 0); $filtered->all(); Output ['A', 'B', 'C', 0, 0] partition() The partition method may be combined with the list PHP function to separate elements that pass a given truth test from those that do not: collection([1, 2, 3, 4, 5, 6]); list($underThree, $equalOrAboveThree) = $make_data->partition(function ($i) { return $i < 3; }); $underThree->all(); $equalOrAboveThree->all(); Output [1, 2] [3, 4, 5, 6] pipe() The pipe method passes the data array to the given callback and returns the result: collection([1, 2, 3]); $piped = $make_data->pipe(function ($make_data) { return $make_data->sum(); }); Output 6 pluck() The pluck method retrieves all of the values for a given key: collection([ ['product_id' => 'prod-100', 'name' => 'Desk'], ['product_id' => 'prod-200', 'name' => 'Chair'], ]); $plucked = $make_data->pluck('name'); $plucked->all(); Output ['Desk', 'Chair'] pop() The pop method removes and returns the last item from the data array: collection([1, 2, 3, 4, 5]); $make_data->pop(); $make_data->all(); Output 5 [1, 2, 3, 4] prepend() The prepend method adds an item to the beginning of the data array: collection([1, 2, 3, 4, 5]); $make_data->prepend(0); $make_data->all(); Output [0, 1, 2, 3, 4, 5] pull() The pull method removes and returns an item from the data array by its key: collection(['product_id' => 'prod-100', 'name' => 'Desk']); $make_data->pull('name'); $make_data->all(); Output 'Desk' ['product_id' => 'prod-100'] push() The push method appends an item to the end of the data array: collection([1, 2, 3, 4]); $make_data->push(5); $make_data->all(); Output [1, 2, 3, 4, 5] put() The put method sets the given key and value in the data array: collection(['product_id' => 1, 'name' => 'Desk']); $make_data->put('price', 100); $make_data->all(); Output ['product_id' => 1, 'name' => 'Desk', 'price' => 100] random() The random method returns a random item from the data array: collection([1, 2, 3, 4, 5]); $make_data->random(); Output 4 - (retrieved randomly) reduce() The reduce method reduces the data array to a single value, passing the result of each iteration into the subsequent iteration: collection([1, 2, 3]); $total = $make_data->reduce(function ($carry, $item) { return $carry + $item; }); Output 6 reject() The reject method filters the data array using the given callback. The callback should return true if the item should be removed from the resulting data array: collection([1, 2, 3, 4]); $filtered = $make_data->reject(function ($value, $key) { return $value > 2; }); $filtered->all(); Output [1, 2] reverse() The reverse method reverses the order of the data array's items, preserving the original keys: collection(['a', 'b', 'c', 'd', 'e']); $reversed = $make_data->reverse(); $reversed->all(); Output [ 4 => 'e', 3 => 'd', 2 => 'c', 1 => 'b', 0 => 'a', ] search() The search method searches the data array for the given value and returns its key if found. If the item is not found, false is returned. collection([2, 4, 6, 8]); $make_data->search(4); Output 1 shift() The shift method removes and returns the first item from the data array: collection([1, 2, 3, 4, 5]); $make_data->shift(); $make_data->all(); Output 1 [2, 3, 4, 5] shuffle() The shuffle method randomly shuffles the items in the data array: collection([1, 2, 3, 4, 5]); $shuffled = $make_data->shuffle(); $shuffled->all(); Output [3, 2, 5, 1, 4] - (generated randomly) slice() The slice method returns a slice of the data array starting at the given index: collection([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); $slice = $make_data->slice(4); $slice->all(); Output [5, 6, 7, 8, 9, 10] sort() The sort method sorts the data array. The sorted data array keeps the original array keys, so in this example we'll use the values method to reset the keys to consecutively numbered indexes: collection([5, 3, 1, 2, 4]); $sorted = $make_data->sort(); $sorted->values()->all(); Output [1, 2, 3, 4, 5] sortBy() collection([ ['name' => 'Desk', 'price' => 200], ['name' => 'Chair', 'price' => 100], ['name' => 'Bookcase', 'price' => 150], ]); $sorted = $make_data->sortBy('price'); $sorted->values()->all(); Output [ ['name' => 'Chair', 'price' => 100], ['name' => 'Bookcase', 'price' => 150], ['name' => 'Desk', 'price' => 200], ] sortByDesc() This method has the same signature as the sortBy method, but will sort the collection in the opposite order. sortKeys() The sortKeys method sorts the data array by the keys of the underlying associative array: collection([ 'id' => 22345, 'first' => 'John', 'last' => 'Doe', ]); $sorted = $make_data->sortKeys(); $sorted->all(); Output [ 'first' => 'John', 'id' => 22345, 'last' => 'Doe', ] splice() The splice method removes and returns a slice of items starting at the specified index: collection([1, 2, 3, 4, 5]); $chunk = $make_data->splice(2); $chunk->all(); Output [3, 4, 5] split() The split method breaks a data array into the given number of groups: collection([1, 2, 3, 4, 5]); $groups = $make_data->split(3); $groups->toArray(); Output [[1, 2], [3, 4], [5]] sum() The sum method returns the sum of all items in the data array: ............................. collection([1, 2, 3, 4, 5])->sum(); ............................. collection([ ['name' => 'JavaScript: The Good Parts', 'pages' => 176], ['name' => 'JavaScript: The Definitive Guide', 'pages' => 1096], ]); $make_data->sum('pages'); ............................. collection([ ['name' => 'Chair', 'colors' => ['Black']], ['name' => 'Desk', 'colors' => ['Black', 'Mahogany']], ['name' => 'Bookcase', 'colors' => ['Red', 'Beige', 'Brown']], ]); $make_data->sum(function ($product) { return count($product['colors']); }); Output 15 1272 6 take() The take method returns a new data array with the specified number of items: collection([0, 1, 2, 3, 4, 5]); $chunk = $make_data->take(3); $chunk->all(); Output [0, 1, 2] tap() The tap method passes the data array to the given callback, allowing you to \"tap\" into the data array at a specific point and do something with the items while not affecting the data array itself: collection([2, 4, 3, 1, 5]) ->sort() ->tap(function ($make_data) { Log::debug('Values after sorting', $make_data->values()->toArray()); }) ->shift(); Output 1 times() The static times method creates a new data array by invoking the callback a given amount of times: $make_data = Collection::times(10, function ($number) { return $number * 9; }); $make_data->all(); Output [9, 18, 27, 36, 45, 54, 63, 72, 81, 90] toJson() The toJson method converts the data array into a JSON serialized string: collection(['name' => 'Desk', 'price' => 200]); $make_data->toJson(); Output '{\"name\":\"Desk\", \"price\":200}' transform() The transform method iterates over the data array and calls the given callback with each item in the data array. The items in the data array will be replaced by the values returned by the callback: collection([1, 2, 3, 4, 5]); $make_data->transform(function ($item, $key) { return $item * 2; }); $make_data->all(); Output [2, 4, 6, 8, 10] union() union() The union method adds the given array to the data array. If the given array contains keys that are already in the original data array, the original data array's values will be preferred: collection([1 => ['a'], 2 => ['b']]); $union = $make_data->union([3 => ['c'], 1 => ['b']]); $union->all(); Output [1 => ['a'], 2 => ['b'], 3 => ['c']] unique() The only method returns the items in the data array with the specified keys: collection([1, 1, 2, 2, 3, 4, 2]); $unique = $make_data->unique(); $unique->values()->all(); collection([ ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'], ['name' => 'iPhone 5', 'brand' => 'Apple', 'type' => 'phone'], ['name' => 'Apple Watch', 'brand' => 'Apple', 'type' => 'watch'], ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'], ['name' => 'Galaxy Gear', 'brand' => 'Samsung', 'type' => 'watch'], ]); $unique = $make_data->unique('brand'); $unique->values()->all(); Output [1, 2, 3, 4] [ ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'], ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'], ] unless() The unless method will execute the given callback unless the first argument given to the method evaluates to true: collection([1, 2, 3]); $make_data->unless(true, function ($make_data) { return $make_data->push(4); }); $make_data->unless(false, function ($make_data) { return $make_data->push(5); }); $make_data->all(); Output [1, 2, 3, 5] values() The values method returns a new data array with the keys reset to consecutive integers: collection([ 10 => ['product' => 'Desk', 'price' => 200], 11 => ['product' => 'Desk', 'price' => 200] ]); $values = $make_data->values(); $values->all(); Output [ 0 => ['product' => 'Desk', 'price' => 200], 1 => ['product' => 'Desk', 'price' => 200], ] when() The when method will execute the given callback when the first argument given to the method evaluates to true: collection([1, 2, 3]); $make_data->when(true, function ($make_data) { return $make_data->push(4); }); $make_data->when(false, function ($make_data) { return $make_data->push(5); }); $make_data->all(); Output [1, 2, 3, 4] whenEmpty() The whenEmpty method will execute the given callback when the data array is empty: collection(['michael', 'tom']); $make_data->whenEmpty(function ($make_data) { return $make_data->push('adam'); }); $make_data->all(); // ['michael', 'tom'] $make_data = make_data); $make_data->whenEmpty(function ($make_data) { return $make_data->push('adam'); }); $make_data->all(); Output ['adam'] whenNotEmpty() The whenNotEmpty method will execute the given callback when the data array is not empty: collection(['michael', 'tom']); $make_data->whenNotEmpty(function ($make_data) { return $make_data->push('adam'); }); $make_data->all(); Output ['michael', 'tom', 'adam'] where() The where method filters the data array by a given key / value pair: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 100], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->where('price', 100); $filtered->all(); Output [ ['product' => 'Chair', 'price' => 100], ['product' => 'Door', 'price' => 100], ] whereBetween() The whereBetween method filters the data array within a given range: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 80], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Pencil', 'price' => 30], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereBetween('price', [100, 200]); $filtered->all(); Output [ ['product' => 'Desk', 'price' => 200], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ] whereIn() The whereIn method filters the data array by a given key / value contained within the given array: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 100], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereIn('price', [150, 200]); $filtered->all(); Output [ ['product' => 'Bookcase', 'price' => 150], ['product' => 'Desk', 'price' => 200], ] whereNotBetween() The whereNotBetween method filters the data array within a given range: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 80], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Pencil', 'price' => 30], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereNotBetween('price', [100, 200]); $filtered->all(); Output [ ['product' => 'Chair', 'price' => 80], ['product' => 'Pencil', 'price' => 30], ] whereNotIn() The whereNotIn method filters the data array by a given key / value not contained within the given array: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 100], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereNotIn('price', [150, 200]); $filtered->all(); Output ['product_id' => 1, 'name' => 'Desk'] wrap() The static wrap method wraps the given value in a data array when applicable: $make_data = Collection::wrap('John Doe'); $make_data->all(); Output ['John Doe'] zip() The zip method merges together the values of the given array with the values of the original data array at the corresponding index: collection(['Chair', 'Desk']); $zipped = $make_data->zip([100, 200]); $zipped->all(); Output [['Chair', 100], ['Desk', 200]]","title":"Collection"},{"location":"collection/#all","text":"The all method returns the underlying array represented by the data array: collection([1, 2, 3])->all();","title":"all()"},{"location":"collection/#avg","text":"The avg method returns the average value of a given key: collection([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->avg('foo'); Output 20 collection([1, 1, 2, 4])->avg(); Output 2","title":"avg()"},{"location":"collection/#chunk","text":"The chunk method breaks into multiple collection([1, 2, 3, 4, 5, 6, 7]); $chunks = $make_data->chunk(4); $chunks->toArray(); Output [[1, 2, 3, 4], [5, 6, 7]]","title":"chunk()"},{"location":"collection/#collapse","text":"The collapse method collapses a data array of arrays into a single, flat data array: collection([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); $collapsed = $make_data->collapse(); $collapsed->all(); Output [1, 2, 3, 4, 5, 6, 7, 8, 9]","title":"collapse()"},{"location":"collection/#combine","text":"The combine method combines the values of the data array, as keys, with the values of another array or data array: collection(['name', 'age']); $combined = $make_data->combine(['George', 29]); $combined->all(); Output ['name' => 'George', 'age' => 29]","title":"combine()"},{"location":"collection/#concat","text":"The concat method appends the given array or data array values onto the end of the data array: collection(['John Doe']); $concatenated = $make_data->concat(['Jane Doe'])->concat(['name' => 'Johnny Doe']); $concatenated->all(); Output ['John Doe', 'Jane Doe', 'Johnny Doe']","title":"concat()"},{"location":"collection/#contains","text":"The contains method determines whether the make_data contains a given item: collection(['name' => 'Desk', 'price' => 100]); $make_data->contains('Desk'); $make_data->contains('New York'); Output true false","title":"contains()"},{"location":"collection/#count","text":"The count method returns the total number of items in the data array: collection([1, 2, 3, 4]); $make_data->count(); Output 4","title":"count()"},{"location":"collection/#countby","text":"The countBy method counts the occurences of values in the make_data. By default, the method counts the occurrences of every element: collection([1, 2, 2, 2, 3]); $counted = $make_data->countBy(); $counted->all(); Output [1 => 1, 2 => 3, 3 => 1]","title":"countBy()"},{"location":"collection/#diff","text":"The diff method compares the data array against another data array or a plain PHP array based on its values. This method will return the values in the original data that are not present in the given data array: collection([1, 2, 3, 4, 5]); $diff = $make_data->diff([2, 4, 6, 8]); $diff->all(); Output [1, 3, 5]","title":"diff()"},{"location":"collection/#diffassoc","text":"The diffAssoc method compares the data array against another data array or a plain PHP array based on its keys and values. This method will return the key / value pairs in the original data array that are not present in the given data array: collection([ 'color' => 'orange', 'type' => 'fruit', 'remain' => 6 ]); $diff = $make_data->diffAssoc([ 'color' => 'yellow', 'type' => 'fruit', 'remain' => 3, 'used' => 6 ]); $diff->all(); Output ['color' => 'orange', 'remain' => 6]","title":"diffAssoc()"},{"location":"collection/#diffkeys","text":"The diffKeys method compares the data array against another data array or a plain PHP array based on its keys. This method will return the key / value pairs in the original data array that are not present in the given data array collection([ 'one' => 10, 'two' => 20, 'three' => 30, 'four' => 40, 'five' => 50, ]); $diff = $diff->diffKeys([ 'two' => 2, 'four' => 4, 'six' => 6, 'eight' => 8, ]); $diff->all(); Output ['one' => 10, 'three' => 30, 'five' => 50]","title":"diffKeys()"},{"location":"collection/#except","text":"The except method returns all items in the data array except for those with the specified keys: collection(['product_id' => 1, 'price' => 100, 'discount' => false]); $filtered = $make_data->except(['price', 'discount']); $filtered->all(); Output ['product_id' => 1]","title":"except()"},{"location":"collection/#except_multiple","text":"The except_multiple method returns all items in the data array except for those with the specified keys: collection([['product_id' => 1, 'price' => 100, 'discount' => false],['product_id' => 2, 'price' => 500, 'discount' => true]]); $filtered = $make_data->except_multiple(['price', 'discount']); $filtered->all(); Output Array ( [0] => Array ( [product_id] => 1 ) [1] => Array ( [product_id] => 2 ) )","title":"except_multiple()"},{"location":"collection/#filter","text":"The filter method filters the data array using the given callback, keeping only those items that pass a given truth test: collection([1, 2, 3, 4]); $filtered = $make_data->filter(function ($value, $key) { return $value > 2; }); $filtered->all(); Output [3, 4]","title":"filter()"},{"location":"collection/#first","text":"The first method returns the first element in the data array that passes a given truth test: collection([1, 2, 3, 4])->first(function ($value, $key) { return $value > 2; }); Output 3","title":"first()"},{"location":"collection/#firstwhere","text":"The firstWhere method returns the first element in the data array with the given key / value pair: collection([ ['name' => 'Regena', 'age' => null], ['name' => 'Linda', 'age' => 14], ['name' => 'Diego', 'age' => 23], ['name' => 'Linda', 'age' => 84], ]); $make_data->firstWhere('name', 'Linda'); Output ['name' => 'Linda', 'age' => 14]","title":"firstWhere()"},{"location":"collection/#flatmap","text":"The flatMap method iterates through the data array and passes each value to the given callback. The callback is free to modify the item and return it, thus forming a new data array of modified items. Then, the array is flattened by a level: collection([ ['name' => 'Sally'], ['school' => 'Arkansas'], ['age' => 28] ]); $flattened = $make_data->flatMap(function ($values) { return array_map('strtoupper', $values); }); $flattened->all(); Output ['name' => 'SALLY', 'school' => 'ARKANSAS', 'age' => '28'];","title":"flatMap()"},{"location":"collection/#flatten","text":"The flatten method flattens a multi-dimensional data array into a single dimension: collection(['name' => 'jony', 'languages' => ['php', 'javascript']]); $flattened = $make_data->flatten(); $flattened->all(); Output ['jony', 'php', 'javascript'];","title":"flatten()"},{"location":"collection/#flip","text":"The flip method swaps the data arrays's keys with their corresponding values: collection(['name' => 'Jony', 'library' => 'array_master']); $flipped = $make_data->flip(); $flipped->all(); Output ['jony' => 'name', 'array_master' => 'library']","title":"flip()"},{"location":"collection/#forget","text":"The forget method removes an item from the data array by its key: collection(['name' => 'Jony', 'library' => 'array_master']); $make_data->forget('name'); $make_data->all(); Output ['library' => 'array_master']","title":"forget()"},{"location":"collection/#get","text":"The get method returns the item at a given key. If the key does not exist, null is returned: collection(['name' => 'Jony', 'library' => 'array_master']); $value = $make_data->get('name'); Output Jony","title":"get()"},{"location":"collection/#groupby","text":"The groupBy method groups the data arrays's items by a given key: collection([ ['account_id' => 'account-x10', 'product' => 'Chair'], ['account_id' => 'account-x10', 'product' => 'Bookcase'], ['account_id' => 'account-x11', 'product' => 'Desk'], ]); $grouped = $make_data->groupBy('account_id'); $grouped->toArray(); Output [ 'account-x10' => [ ['account_id' => 'account-x10', 'product' => 'Chair'], ['account_id' => 'account-x10', 'product' => 'Bookcase'], ], 'account-x11' => [ ['account_id' => 'account-x11', 'product' => 'Desk'], ], ]","title":"groupBy()"},{"location":"collection/#has","text":"The has method determines if a given key exists in the data array: collection(['account_id' => 1, 'product' => 'Desk', 'amount' => 5]); $make_data->has('product'); Output true","title":"has()"},{"location":"collection/#implode","text":"The implode method joins the items in a dara array. Its arguments depend on the type of items in the dara array. If the data array contains arrays or objects, you should pass the key of the attributes you wish to join, and the \"glue\" string you wish to place between the values: collection([ ['account_id' => 1, 'product' => 'Desk'], ['account_id' => 2, 'product' => 'Chair'], ]); $make_data->implode('product', ', '); Output Desk, Chair","title":"implode()"},{"location":"collection/#intersect","text":"The intersect method removes any values from the original data array that are not present in the given array or dara array. The resulting data array will preserve the original dara array's keys: collection(['Desk', 'Sofa', 'Chair']); $intersect = $make_data->intersect(['Desk', 'Chair', 'Bookcase']); $intersect->all(); Output [0 => 'Desk', 2 => 'Chair']","title":"intersect()"},{"location":"collection/#intersectbykeys","text":"The intersectByKeys method removes any keys from the original data array that are not present in the given array or dara array: collection([ 'serial' => 'UX301', 'type' => 'screen', 'year' => 2009 ]); $intersect = $make_data->intersectByKeys([ 'reference' => 'UX404', 'type' => 'tab', 'year' => 2011 ]); $intersect->all(); Output ['type' => 'screen', 'year' => 2009]","title":"intersectByKeys()"},{"location":"collection/#isempty","text":"The isEmpty method returns true if the data array is empty; otherwise, false is returned: collection([])->isEmpty(); Output true","title":"isEmpty()"},{"location":"collection/#isnotempty","text":"The isNotEmpty method returns true if the data array is not empty; otherwise, false is returned: collection([])->isNotEmpty(); Output false","title":"isNotEmpty()"},{"location":"collection/#keyby","text":"The keyBy method keys the data array by the given key. If multiple items have the same key, only the last one will appear in the new dara array: collection([ ['product_id' => 'prod-100', 'name' => 'Desk'], ['product_id' => 'prod-200', 'name' => 'Chair'], ]); $keyed = $make_data->keyBy('product_id'); $keyed->all(); Output [ 'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'], 'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'], ]","title":"keyBy()"},{"location":"collection/#keys","text":"The keys method returns all of the data array's keys: collection([ 'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'], 'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'], ]); $keys = $make_data->keys(); Output ['prod-100', 'prod-200']","title":"keys()"},{"location":"collection/#last","text":"The last method returns the last element in the data array that passes a given truth test: collection([1, 2, 3, 4])->last(); Output 4","title":"last()"},{"location":"collection/#map","text":"The map method iterates through the data array and passes each value to the given callback. The callback is free to modify the item and return it, thus forming a new data array of modified items: collection([1, 2, 3, 4, 5]); $multiplied = $make_data->map(function ($item, $key) { return $item * 2; }); $multiplied->all(); Output [2, 4, 6, 8, 10]","title":"map()"},{"location":"collection/#mapwithkeys","text":"collection([ [ 'name' => 'John', 'department' => 'Sales', 'email' => 'john@example.com' ], [ 'name' => 'Jane', 'department' => 'Marketing', 'email' => 'jane@example.com' ] ]); $keyed = $make_data->mapWithKeys(function ($item) { return [$item['email'] => $item['name']]; }); $keyed->all(); Output [ 'john@example.com' => 'John', 'jane@example.com' => 'Jane', ]","title":"mapWithKeys()"},{"location":"collection/#max","text":"The max method returns the maximum value of a given key: collection([['foo' => 10], ['foo' => 20]])->max('foo'); collection([['foo' => 10], ['foo' => 30]])->max('foo'); Output 20 30","title":"max()"},{"location":"collection/#median","text":"The median method returns the median value of a given key: collection([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->median('foo'); Output 15","title":"median()"},{"location":"collection/#merge","text":"collection(['product_id' => 1, 'price' => 100]); $merged = $make_data->merge(['price' => 200, 'discount' => false]); $merged->all(); Output ['product_id' => 1, 'price' => 200, 'discount' => false]","title":"merge()"},{"location":"collection/#min","text":"The min method returns the minimum value of a given key: collection([['foo' => 10], ['foo' => 20]])->min('foo'); collection([1, 2, 3, 4, 5])->min(); Output 10 1","title":"min()"},{"location":"collection/#mode","text":"The mode method returns the mode value of a given key: collection([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->mode('foo'); collection([1, 1, 2, 4])->mode(); Output [10] [1]","title":"mode()"},{"location":"collection/#only","text":"The only method returns the items in the data array with the specified keys: collection(['product_id' => 1, 'name' => 'Desk', 'price' => 100, 'discount' => false]); $filtered = $make_data->only(['product_id', 'name']); $filtered->all(); Output ['product_id' => 1, 'name' => 'Desk']","title":"only()"},{"location":"collection/#pad","text":"collection(['A', 'B', 'C']); $filtered = $make_data->pad(5, 0); $filtered->all(); Output ['A', 'B', 'C', 0, 0]","title":"pad()"},{"location":"collection/#partition","text":"The partition method may be combined with the list PHP function to separate elements that pass a given truth test from those that do not: collection([1, 2, 3, 4, 5, 6]); list($underThree, $equalOrAboveThree) = $make_data->partition(function ($i) { return $i < 3; }); $underThree->all(); $equalOrAboveThree->all(); Output [1, 2] [3, 4, 5, 6]","title":"partition()"},{"location":"collection/#pipe","text":"The pipe method passes the data array to the given callback and returns the result: collection([1, 2, 3]); $piped = $make_data->pipe(function ($make_data) { return $make_data->sum(); }); Output 6","title":"pipe()"},{"location":"collection/#pluck","text":"The pluck method retrieves all of the values for a given key: collection([ ['product_id' => 'prod-100', 'name' => 'Desk'], ['product_id' => 'prod-200', 'name' => 'Chair'], ]); $plucked = $make_data->pluck('name'); $plucked->all(); Output ['Desk', 'Chair']","title":"pluck()"},{"location":"collection/#pop","text":"The pop method removes and returns the last item from the data array: collection([1, 2, 3, 4, 5]); $make_data->pop(); $make_data->all(); Output 5 [1, 2, 3, 4]","title":"pop()"},{"location":"collection/#prepend","text":"The prepend method adds an item to the beginning of the data array: collection([1, 2, 3, 4, 5]); $make_data->prepend(0); $make_data->all(); Output [0, 1, 2, 3, 4, 5]","title":"prepend()"},{"location":"collection/#pull","text":"The pull method removes and returns an item from the data array by its key: collection(['product_id' => 'prod-100', 'name' => 'Desk']); $make_data->pull('name'); $make_data->all(); Output 'Desk' ['product_id' => 'prod-100']","title":"pull()"},{"location":"collection/#push","text":"The push method appends an item to the end of the data array: collection([1, 2, 3, 4]); $make_data->push(5); $make_data->all(); Output [1, 2, 3, 4, 5]","title":"push()"},{"location":"collection/#put","text":"The put method sets the given key and value in the data array: collection(['product_id' => 1, 'name' => 'Desk']); $make_data->put('price', 100); $make_data->all(); Output ['product_id' => 1, 'name' => 'Desk', 'price' => 100]","title":"put()"},{"location":"collection/#random","text":"The random method returns a random item from the data array: collection([1, 2, 3, 4, 5]); $make_data->random(); Output 4 - (retrieved randomly)","title":"random()"},{"location":"collection/#reduce","text":"The reduce method reduces the data array to a single value, passing the result of each iteration into the subsequent iteration: collection([1, 2, 3]); $total = $make_data->reduce(function ($carry, $item) { return $carry + $item; }); Output 6","title":"reduce()"},{"location":"collection/#reject","text":"The reject method filters the data array using the given callback. The callback should return true if the item should be removed from the resulting data array: collection([1, 2, 3, 4]); $filtered = $make_data->reject(function ($value, $key) { return $value > 2; }); $filtered->all(); Output [1, 2]","title":"reject()"},{"location":"collection/#reverse","text":"The reverse method reverses the order of the data array's items, preserving the original keys: collection(['a', 'b', 'c', 'd', 'e']); $reversed = $make_data->reverse(); $reversed->all(); Output [ 4 => 'e', 3 => 'd', 2 => 'c', 1 => 'b', 0 => 'a', ]","title":"reverse()"},{"location":"collection/#search","text":"The search method searches the data array for the given value and returns its key if found. If the item is not found, false is returned. collection([2, 4, 6, 8]); $make_data->search(4); Output 1","title":"search()"},{"location":"collection/#shift","text":"The shift method removes and returns the first item from the data array: collection([1, 2, 3, 4, 5]); $make_data->shift(); $make_data->all(); Output 1 [2, 3, 4, 5]","title":"shift()"},{"location":"collection/#shuffle","text":"The shuffle method randomly shuffles the items in the data array: collection([1, 2, 3, 4, 5]); $shuffled = $make_data->shuffle(); $shuffled->all(); Output [3, 2, 5, 1, 4] - (generated randomly)","title":"shuffle()"},{"location":"collection/#slice","text":"The slice method returns a slice of the data array starting at the given index: collection([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); $slice = $make_data->slice(4); $slice->all(); Output [5, 6, 7, 8, 9, 10]","title":"slice()"},{"location":"collection/#sort","text":"The sort method sorts the data array. The sorted data array keeps the original array keys, so in this example we'll use the values method to reset the keys to consecutively numbered indexes: collection([5, 3, 1, 2, 4]); $sorted = $make_data->sort(); $sorted->values()->all(); Output [1, 2, 3, 4, 5]","title":"sort()"},{"location":"collection/#sortby","text":"collection([ ['name' => 'Desk', 'price' => 200], ['name' => 'Chair', 'price' => 100], ['name' => 'Bookcase', 'price' => 150], ]); $sorted = $make_data->sortBy('price'); $sorted->values()->all(); Output [ ['name' => 'Chair', 'price' => 100], ['name' => 'Bookcase', 'price' => 150], ['name' => 'Desk', 'price' => 200], ]","title":"sortBy()"},{"location":"collection/#sortbydesc","text":"This method has the same signature as the sortBy method, but will sort the collection in the opposite order.","title":"sortByDesc()"},{"location":"collection/#sortkeys","text":"The sortKeys method sorts the data array by the keys of the underlying associative array: collection([ 'id' => 22345, 'first' => 'John', 'last' => 'Doe', ]); $sorted = $make_data->sortKeys(); $sorted->all(); Output [ 'first' => 'John', 'id' => 22345, 'last' => 'Doe', ]","title":"sortKeys()"},{"location":"collection/#splice","text":"The splice method removes and returns a slice of items starting at the specified index: collection([1, 2, 3, 4, 5]); $chunk = $make_data->splice(2); $chunk->all(); Output [3, 4, 5]","title":"splice()"},{"location":"collection/#split","text":"The split method breaks a data array into the given number of groups: collection([1, 2, 3, 4, 5]); $groups = $make_data->split(3); $groups->toArray(); Output [[1, 2], [3, 4], [5]]","title":"split()"},{"location":"collection/#sum","text":"The sum method returns the sum of all items in the data array: ............................. collection([1, 2, 3, 4, 5])->sum(); ............................. collection([ ['name' => 'JavaScript: The Good Parts', 'pages' => 176], ['name' => 'JavaScript: The Definitive Guide', 'pages' => 1096], ]); $make_data->sum('pages'); ............................. collection([ ['name' => 'Chair', 'colors' => ['Black']], ['name' => 'Desk', 'colors' => ['Black', 'Mahogany']], ['name' => 'Bookcase', 'colors' => ['Red', 'Beige', 'Brown']], ]); $make_data->sum(function ($product) { return count($product['colors']); }); Output 15 1272 6","title":"sum()"},{"location":"collection/#take","text":"The take method returns a new data array with the specified number of items: collection([0, 1, 2, 3, 4, 5]); $chunk = $make_data->take(3); $chunk->all(); Output [0, 1, 2]","title":"take()"},{"location":"collection/#tap","text":"The tap method passes the data array to the given callback, allowing you to \"tap\" into the data array at a specific point and do something with the items while not affecting the data array itself: collection([2, 4, 3, 1, 5]) ->sort() ->tap(function ($make_data) { Log::debug('Values after sorting', $make_data->values()->toArray()); }) ->shift(); Output 1","title":"tap()"},{"location":"collection/#times","text":"The static times method creates a new data array by invoking the callback a given amount of times: $make_data = Collection::times(10, function ($number) { return $number * 9; }); $make_data->all(); Output [9, 18, 27, 36, 45, 54, 63, 72, 81, 90]","title":"times()"},{"location":"collection/#tojson","text":"The toJson method converts the data array into a JSON serialized string: collection(['name' => 'Desk', 'price' => 200]); $make_data->toJson(); Output '{\"name\":\"Desk\", \"price\":200}'","title":"toJson()"},{"location":"collection/#transform","text":"The transform method iterates over the data array and calls the given callback with each item in the data array. The items in the data array will be replaced by the values returned by the callback: collection([1, 2, 3, 4, 5]); $make_data->transform(function ($item, $key) { return $item * 2; }); $make_data->all(); Output [2, 4, 6, 8, 10]","title":"transform()"},{"location":"collection/#union","text":"union() The union method adds the given array to the data array. If the given array contains keys that are already in the original data array, the original data array's values will be preferred: collection([1 => ['a'], 2 => ['b']]); $union = $make_data->union([3 => ['c'], 1 => ['b']]); $union->all(); Output [1 => ['a'], 2 => ['b'], 3 => ['c']]","title":"union()"},{"location":"collection/#unique","text":"The only method returns the items in the data array with the specified keys: collection([1, 1, 2, 2, 3, 4, 2]); $unique = $make_data->unique(); $unique->values()->all(); collection([ ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'], ['name' => 'iPhone 5', 'brand' => 'Apple', 'type' => 'phone'], ['name' => 'Apple Watch', 'brand' => 'Apple', 'type' => 'watch'], ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'], ['name' => 'Galaxy Gear', 'brand' => 'Samsung', 'type' => 'watch'], ]); $unique = $make_data->unique('brand'); $unique->values()->all(); Output [1, 2, 3, 4] [ ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'], ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'], ]","title":"unique()"},{"location":"collection/#unless","text":"The unless method will execute the given callback unless the first argument given to the method evaluates to true: collection([1, 2, 3]); $make_data->unless(true, function ($make_data) { return $make_data->push(4); }); $make_data->unless(false, function ($make_data) { return $make_data->push(5); }); $make_data->all(); Output [1, 2, 3, 5]","title":"unless()"},{"location":"collection/#values","text":"The values method returns a new data array with the keys reset to consecutive integers: collection([ 10 => ['product' => 'Desk', 'price' => 200], 11 => ['product' => 'Desk', 'price' => 200] ]); $values = $make_data->values(); $values->all(); Output [ 0 => ['product' => 'Desk', 'price' => 200], 1 => ['product' => 'Desk', 'price' => 200], ]","title":"values()"},{"location":"collection/#when","text":"The when method will execute the given callback when the first argument given to the method evaluates to true: collection([1, 2, 3]); $make_data->when(true, function ($make_data) { return $make_data->push(4); }); $make_data->when(false, function ($make_data) { return $make_data->push(5); }); $make_data->all(); Output [1, 2, 3, 4]","title":"when()"},{"location":"collection/#whenempty","text":"The whenEmpty method will execute the given callback when the data array is empty: collection(['michael', 'tom']); $make_data->whenEmpty(function ($make_data) { return $make_data->push('adam'); }); $make_data->all(); // ['michael', 'tom'] $make_data = make_data); $make_data->whenEmpty(function ($make_data) { return $make_data->push('adam'); }); $make_data->all(); Output ['adam']","title":"whenEmpty()"},{"location":"collection/#whennotempty","text":"The whenNotEmpty method will execute the given callback when the data array is not empty: collection(['michael', 'tom']); $make_data->whenNotEmpty(function ($make_data) { return $make_data->push('adam'); }); $make_data->all(); Output ['michael', 'tom', 'adam']","title":"whenNotEmpty()"},{"location":"collection/#where","text":"The where method filters the data array by a given key / value pair: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 100], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->where('price', 100); $filtered->all(); Output [ ['product' => 'Chair', 'price' => 100], ['product' => 'Door', 'price' => 100], ]","title":"where()"},{"location":"collection/#wherebetween","text":"The whereBetween method filters the data array within a given range: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 80], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Pencil', 'price' => 30], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereBetween('price', [100, 200]); $filtered->all(); Output [ ['product' => 'Desk', 'price' => 200], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]","title":"whereBetween()"},{"location":"collection/#wherein","text":"The whereIn method filters the data array by a given key / value contained within the given array: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 100], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereIn('price', [150, 200]); $filtered->all(); Output [ ['product' => 'Bookcase', 'price' => 150], ['product' => 'Desk', 'price' => 200], ]","title":"whereIn()"},{"location":"collection/#wherenotbetween","text":"The whereNotBetween method filters the data array within a given range: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 80], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Pencil', 'price' => 30], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereNotBetween('price', [100, 200]); $filtered->all(); Output [ ['product' => 'Chair', 'price' => 80], ['product' => 'Pencil', 'price' => 30], ]","title":"whereNotBetween()"},{"location":"collection/#wherenotin","text":"The whereNotIn method filters the data array by a given key / value not contained within the given array: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 100], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereNotIn('price', [150, 200]); $filtered->all(); Output ['product_id' => 1, 'name' => 'Desk']","title":"whereNotIn()"},{"location":"collection/#wrap","text":"The static wrap method wraps the given value in a data array when applicable: $make_data = Collection::wrap('John Doe'); $make_data->all(); Output ['John Doe']","title":"wrap()"},{"location":"collection/#zip","text":"The zip method merges together the values of the given array with the values of the original data array at the corresponding index: collection(['Chair', 'Desk']); $zipped = $make_data->zip([100, 200]); $zipped->all(); Output [['Chair', 100], ['Desk', 200]]","title":"zip()"},{"location":"cryptography/","text":"Encrypt To create an encrypted key, use the Hash class together with the static encrypt function as shown below: use Solital\\Core\\Security\\Hash; $res = Hash::encrypt('word_to_encrypt'); pre($res); You can define how long this key will be valid. It can be 1 second, 1 hour or 1 year. by default the value is +1 hour . use Solital\\Core\\Security\\Hash; $res = Hash::encrypt('word_to_encrypt', '+1 month'); pre($res); Decrypt If you want to decrypt, use the decrypt function chained with the value method. use Solital\\Core\\Security\\Hash; $res = Hash::decrypt('word_to_decrypt')->value(); pre($res); Check value If you want to check if the encrypted key is still valid, use isValid . If you want to verify that the encrypted key is still valid, use isValid . the isValid method will return true if it is still valid, and false if it is already expired use Solital\\Core\\Security\\Hash; $res = Hash::decrypt('word_to_decrypt')->isValid(); pre($res); Sodium encryption Solital supports Sodium encryption. To enable, make sure that libsodium is installed in your development environment. You can use the Hash::checkSodium() method to check if libsodium is installed. Generating a sodium key First, you need to generate a sodium key. This key is automatically renewed with each new request, so it can be stored in a database, in the session or in another type of storage. use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); Encrypting and decrypting with Sodium Use the Hash::sodiumCrypt() (to encrypt), and Hash::sodiumDecrypt() (to decrypt) methods. Remember to use the key generated using the Hash::getSodiumKey() method. use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); # Crypt $encoded = Hash::sodiumCrypt(\"HashTest!\", $key); pre($encoded); # Decrypt $decoded = Hash::sodiumDecrypt($encoded, $key); pre($decoded);","title":"Cryptography"},{"location":"cryptography/#encrypt","text":"To create an encrypted key, use the Hash class together with the static encrypt function as shown below: use Solital\\Core\\Security\\Hash; $res = Hash::encrypt('word_to_encrypt'); pre($res); You can define how long this key will be valid. It can be 1 second, 1 hour or 1 year. by default the value is +1 hour . use Solital\\Core\\Security\\Hash; $res = Hash::encrypt('word_to_encrypt', '+1 month'); pre($res);","title":"Encrypt"},{"location":"cryptography/#decrypt","text":"If you want to decrypt, use the decrypt function chained with the value method. use Solital\\Core\\Security\\Hash; $res = Hash::decrypt('word_to_decrypt')->value(); pre($res);","title":"Decrypt"},{"location":"cryptography/#check-value","text":"If you want to check if the encrypted key is still valid, use isValid . If you want to verify that the encrypted key is still valid, use isValid . the isValid method will return true if it is still valid, and false if it is already expired use Solital\\Core\\Security\\Hash; $res = Hash::decrypt('word_to_decrypt')->isValid(); pre($res);","title":"Check value"},{"location":"cryptography/#sodium-encryption","text":"Solital supports Sodium encryption. To enable, make sure that libsodium is installed in your development environment. You can use the Hash::checkSodium() method to check if libsodium is installed.","title":"Sodium encryption"},{"location":"cryptography/#generating-a-sodium-key","text":"First, you need to generate a sodium key. This key is automatically renewed with each new request, so it can be stored in a database, in the session or in another type of storage. use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey();","title":"Generating a sodium key"},{"location":"cryptography/#encrypting-and-decrypting-with-sodium","text":"Use the Hash::sodiumCrypt() (to encrypt), and Hash::sodiumDecrypt() (to decrypt) methods. Remember to use the key generated using the Hash::getSodiumKey() method. use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); # Crypt $encoded = Hash::sodiumCrypt(\"HashTest!\", $key); pre($encoded); # Decrypt $decoded = Hash::sodiumDecrypt($encoded, $key); pre($decoded);","title":"Encrypting and decrypting with Sodium"},{"location":"csrf-protection/","text":"Introducion CSRF is one of the most well-known attacks, it has existed since the \u201cfoundation\u201d of the Web. It occurs when an HTTP request is made between sites in an attempt to impersonate a legitimate user. Whoever uses this type of attack usually focuses on doing so hoping that the target user will be authenticated on the site where the fraudulent request will be made, in order to have more privileges and access to operations. And the reason for the whole problem is how browsers handle Cookies. Any forms posting to POST , PUT or DELETE routes should include the CSRF-token. We strongly recommend that you enable CSRF-verification on your site to maximize security. The CSRF check is generated by default in Solital, but it is possible to extend this check. You can use the BaseCsrfVerifier to enable CSRF-validation on all request. If you need to disable verification for specific urls, please refer to the \"Custom CSRF-verifier\" section below. By default Solital will use the CookieTokenProvider class. This provider will store the security-token in a cookie on the clients machine. If you want to store the token elsewhere, please refer to the \"Creating custom Token Provider\" section below. Adding CSRF-verifier When you've created your CSRF-verifier you need to tell Solital that it should use it. You can do this by adding the following line in your routes.php file: Course::csrfVerifier(new \\Solital\\Core\\Http\\Middleware\\BaseCsrfVerifier()); Getting CSRF-token When posting to any of the urls that has CSRF-verification enabled, you need post your CSRF-token or else the request will get rejected. You can get the CSRF-token by calling the helper method: csrf_token(); You can also get the token directly: return Course::router()->getCsrfVerifier()->getTokenProvider()->setToken(); The default name/key for the input-field is csrf_token and is defined in the POST_KEY constant in the BaseCsrfVerifier class. You can change the key by overwriting the constant in your own CSRF-verifier class. Example: The example below will post to the current url with a hidden field \" csrf_token \". <form method=\"post\" action=\"{{ url(); }}\"> {{ csrf_token(); }} <!-- other input elements here --> </form>","title":"CSRF Protection"},{"location":"csrf-protection/#introducion","text":"CSRF is one of the most well-known attacks, it has existed since the \u201cfoundation\u201d of the Web. It occurs when an HTTP request is made between sites in an attempt to impersonate a legitimate user. Whoever uses this type of attack usually focuses on doing so hoping that the target user will be authenticated on the site where the fraudulent request will be made, in order to have more privileges and access to operations. And the reason for the whole problem is how browsers handle Cookies. Any forms posting to POST , PUT or DELETE routes should include the CSRF-token. We strongly recommend that you enable CSRF-verification on your site to maximize security. The CSRF check is generated by default in Solital, but it is possible to extend this check. You can use the BaseCsrfVerifier to enable CSRF-validation on all request. If you need to disable verification for specific urls, please refer to the \"Custom CSRF-verifier\" section below. By default Solital will use the CookieTokenProvider class. This provider will store the security-token in a cookie on the clients machine. If you want to store the token elsewhere, please refer to the \"Creating custom Token Provider\" section below.","title":"Introducion"},{"location":"csrf-protection/#adding-csrf-verifier","text":"When you've created your CSRF-verifier you need to tell Solital that it should use it. You can do this by adding the following line in your routes.php file: Course::csrfVerifier(new \\Solital\\Core\\Http\\Middleware\\BaseCsrfVerifier());","title":"Adding CSRF-verifier"},{"location":"csrf-protection/#getting-csrf-token","text":"When posting to any of the urls that has CSRF-verification enabled, you need post your CSRF-token or else the request will get rejected. You can get the CSRF-token by calling the helper method: csrf_token(); You can also get the token directly: return Course::router()->getCsrfVerifier()->getTokenProvider()->setToken(); The default name/key for the input-field is csrf_token and is defined in the POST_KEY constant in the BaseCsrfVerifier class. You can change the key by overwriting the constant in your own CSRF-verifier class. Example: The example below will post to the current url with a hidden field \" csrf_token \". <form method=\"post\" action=\"{{ url(); }}\"> {{ csrf_token(); }} <!-- other input elements here --> </form>","title":"Getting CSRF-token"},{"location":"date-and-time/","text":"It is possible to manipulate dates and times using the Convertime class. To begin, run the instance: use Solital\\Core\\Validation\\Convertime; $convertime = new Convertime(); Changing the timezone In the class constructor, you can define the timezone. By default, the default timezone is set to America/Sao_Paulo . $convertime = new Convertime(\"America/Fortaleza\"); You can change the timezone also in the bootstrap.yaml file: default_timezone: America/Fortaleza Format date To format a date, enter the date you want to convert and the format to be converted. $convertime = new Convertime(); $res = $convertime->formatDate('04/01/1999', 'Y-m-d'); /* Return 1999-01-04 */ pre($res); Add months to a date In some cases, you may need to add months to a specific date. To do this, use the addMonth class. This class is similar to the formatDate class, with the difference that you must enter in the last parameter the number of months that will be added to the date. This class already has conversion for days with 28, 29, 30 or 31 days. $convertime = new Convertime(); $res = $convertime->addMonth('1999-01-04', 'd/m/Y', 1); /* Return 1999-02-04 */ pre($res); Add days to a date To add days to a date, the addDays method works in a similar way to the addMonth method. $convertime = new Convertime(); $res = $convertime->addDays('1999-01-04', 'd/m/Y', 3); /* Return 1999-01-07 */ pre($res); Add time to another time It is possible to add a specific time to another time. For example: add 3 more hours at 13:00. $convertime = new Convertime(); $res = $convertime->addHour('13:00', '03:00'); /* Return 16:00 */ pre($res); Check if the date is weekend To check whether a certain date will be on a weekend, use the isWeekend() method. $convertime = new Convertime(); $res = $convertime->isWeekend('2021-07-18'); /* Return bool */ pre($res);","title":"Date and time"},{"location":"date-and-time/#changing-the-timezone","text":"In the class constructor, you can define the timezone. By default, the default timezone is set to America/Sao_Paulo . $convertime = new Convertime(\"America/Fortaleza\"); You can change the timezone also in the bootstrap.yaml file: default_timezone: America/Fortaleza","title":"Changing the timezone"},{"location":"date-and-time/#format-date","text":"To format a date, enter the date you want to convert and the format to be converted. $convertime = new Convertime(); $res = $convertime->formatDate('04/01/1999', 'Y-m-d'); /* Return 1999-01-04 */ pre($res);","title":"Format date"},{"location":"date-and-time/#add-months-to-a-date","text":"In some cases, you may need to add months to a specific date. To do this, use the addMonth class. This class is similar to the formatDate class, with the difference that you must enter in the last parameter the number of months that will be added to the date. This class already has conversion for days with 28, 29, 30 or 31 days. $convertime = new Convertime(); $res = $convertime->addMonth('1999-01-04', 'd/m/Y', 1); /* Return 1999-02-04 */ pre($res);","title":"Add months to a date"},{"location":"date-and-time/#add-days-to-a-date","text":"To add days to a date, the addDays method works in a similar way to the addMonth method. $convertime = new Convertime(); $res = $convertime->addDays('1999-01-04', 'd/m/Y', 3); /* Return 1999-01-07 */ pre($res);","title":"Add days to a date"},{"location":"date-and-time/#add-time-to-another-time","text":"It is possible to add a specific time to another time. For example: add 3 more hours at 13:00. $convertime = new Convertime(); $res = $convertime->addHour('13:00', '03:00'); /* Return 16:00 */ pre($res);","title":"Add time to another time"},{"location":"date-and-time/#check-if-the-date-is-weekend","text":"To check whether a certain date will be on a weekend, use the isWeekend() method. $convertime = new Convertime(); $res = $convertime->isWeekend('2021-07-18'); /* Return bool */ pre($res);","title":"Check if the date is weekend"},{"location":"dependency-container/","text":"Introduction Injecting dependencies can become a tedious task when many classes are involved. Before injecting a dependency it needs to be instantiated. So, we don't just take care of the \"injection\", we also need to have the knowledge of what objects it needs to work. A dependency injection container (DI Container) manages and automates instantiations. We tell him how an object should be created (this is the part that touches us, our knowledge about it) and then whenever we need it, we just need to use the container to obtain it. Solital implements the PSR-11, meaning you can easily create dependency containers. Consider this example: <?php class UserManager { private $mailer; public function __construct() { $this->mailer = new Mailer(); $this->mailer->setTransport('sendmail'); } public function setMailerTransport($transport) { $this->mailer->setTransport($transport); } } Here we have our UserManager service that is responsible for creating its Mailer dependency via setter injection. If we decide to later change the type of mailer that is used, and that mailer uses constructor injection rather than setter injection, we must alter our UserManager code, potentially breaking other methods that may use the setTransport method. Instead, the UserManager service should simply ask for a Mailer object, and get one. It should not care how it is created or what methods the mailer uses to configure itself, it just asks for one and receives one: class UserManager { private $mailer; public function __construct(Mailer $mailer) { $this->mailer = $mailer; } } The configuration of the mailer is now setup outside of the UserManager , and will not break anything if it is changed. So that leaves us with a question: Where should we write this \"wiring\" or configuration of the dependencies? That's where the container concept comes in. An IoC, or dependency injection container is the place where you would write up how your services should be created. Going back to the above example: <?php use Solital\\Core\\Container\\Container; $container = new Container(); $container->add('userManager', function($container) { $mailer = $container->get('mailer'); return new UserManager($mailer); }); $container->add('mailer', function() { $transport = 'gmail'; $mailer = new Mailer($transport); }); Now all we have to do is ask for the UserManager , and its Mailer dependency will be created for us. If we decide to change the transport methodback to sendmail at any point, all we have to do is change it in one place in the service configuration area. Usage Instantiation To use the container, simply create a new instance of the Container class: $container = new Container(); You may also optionally pass an array of service and parameter entries directly into the constructor: $entries = ['foo' => 'bar']; $container = new Container($entries); Adding Definitions Services are defined by invokable callback functions. Most commonly, this is a closure (anonymous function) that explains how to create a service: $myServiceDefinition = function() { $obj = new Service(); return $obj; }; Parameters are simple primitive values that should be accessed throughout your application. It is assumed that your entry is a parameter if it is not an invokable function. To add a service or parameter to the container, use the Container::add method. $container = new Container(); $container->add('myParameter', 'value'); $container->add('myService', function() { return new MyService(); }); The container can also be accessed like an array. So adding entries is as easy as using array notation: $container = new Container(); $container['myParameter'] = 'value'; $container['myService'] = function() { return new MyService(); }; When defining services, note that an instance of the container is always passed as an argument to the invokable callback. This allows you to resolve nested dependencies. In our synopsis, we used the example of a UserManager service who needed a Mailer object. We can define how to create the mailer in one entry, and how to create the user manager in a separate entry like this: $container = new Container(); $container['userManager'] = function($container) { // The user manager needs a mailer, so get that from the container first $mailer = $container->get('mailer'); // Now pass that to the UserManager return new UserManager($mailer); }; $container['mailer'] = function() { return new Mailer(); }; $userManager = $container->get('userManager'); This is known as manually wiring your dependencies. Entry Management Just as entries can be added to the container, they may be removed via Container::remove as well: $container = new Container(); $container['myParameter'] = 'value'; $container->remove('myParameter'); // or: unset($container['myParameter']); We can also check if the container contains as entry with Container::has : $container = new Container(); $container['myParameter'] = 'value'; $has = $container->has('myParameter'); // or: isset($container['myParameter']); var_dump($has); // outputs: true Lastly, we can get an array of all of the entry names in our container with Container::keys : $container = new Container(); $container['myParameter'] = 'value'; $entries = $container->keys(); var_dump($entries); // outputs: ['myParameter'] Retrieving Services and Parameters Once an entry is added to the container, we can resolve that entry by using the Container::get method, or via array access: $container = new Container(); $container['myParameter'] = 'value'; $myParameter = $container->get('myParameter'); var_dump($myParameter); // outputs: 'value' $container['myService'] = function() { return new MyService(); }; $myService = $container['myService']; var_dump($myService instanceof MyService::class); // outputs: true Note that the service definition is executed and the result of the callback is what is assigned to $myService , rather than the literal callback function. If you would like a callback function to be interpreted as a literal value, you can use the Container::protect method: $container = new Container(); $container->add('myService', $container->protect(function() { return new MyService(); })); $myServiceFactory = $container->get('myService'); var_dump($myServiceFactory instanceof \\Closure); // outputs: true By default, when the container resolves a service entry, that service will be \"shared\" across the life of the container. This means that when the container is asked for the service a second time, the same instance will be returned as the first. This is often times the desired behavior when dealing with database connections, mailers, and logger objects. It would be a waste of memory to create these types of objects multiple times. You would not want 20 different database connections open at the same time if you really only need one: $container = new Container(); $container->add('db', function() { ... // database configuration return new PDO(); }); $db = $container->get('db'); $db2 = $container->get('db'); var_dump($db === $db2); // outputs: true However, sometimes you do need to get a new instance of a service each time it is accessed. For those cases, simply define the service as a factory with Container::factory : $container = new Container(); $container->add('myService', $container->factory(function() { return new MyService(); })); $myService = $container->get('myService'); $myService2 = $container->get('myService'); var_dump($myService === $myService2); // outputs: false Extending Definitions Often times you need to modify a service after it has been created. This is often times called \"setter injection\" or \"decorating\". This can be achieved by using the Container::extend method. The extend method is passed the instance of the object and an instance of the container in that order. An extend will fail if: The entry does not exist The entry is a parameter The entry is currently being resolved The entry is protected The extend callback is not invokable Therefore, extending is meant to be done on existing service definitions only: $container = new Container(); $container['mailer'] = function() { return new Mailer(); }; $container->extend('mailer', function($mailer, $container) { $mailer->setTransport('sendmail'); $mailer->setUsername($container->get(...)); }); If, however, you leave the second argument empty and only assign an invokable callback, like so: $container->extend(function() {}); This will be treated as a global callback function that should be run on every resolve. This is also a cool way to see how inversion of control works. We can assign a callback to run whenever the container resolves any type of entry, and get some feedback about what it is creating. A great example of dependency injection comes from the Auryn container docs: class Car { private $engine; public function __construct(Engine $engine) { $this->engine = $engine; } } class Engine { private $sparkPlug; private $piston; public function __construct(SparkPlug $sparkPlug, Piston $piston) { $this->sparkPlug = $sparkPlug; $this->piston = $piston; } } As you can see we have a Car object that depends on an Engine object, and the Engine object depends on its own service objects SparkPlug and Piston . Using a normal object creation workflow, the wiring of these objects would look something like this: Application needs Car Car needs Engine so: Engine needs SparkPlug and Piston so: Engine creates SparkPlug Engine creates Piston Car creates engine Application creates Car However the wiring of objects using inversion of control looks like this: Application needs Car, which needs Engine, which needs SparkPlug and Piston so: Application creates SparkPlug and Piston Application creates Engine and gives it SparkPlug and Piston Application creates Car and gives it Engine You can see that the difference with inversion of control is that application (container) creates the dependencies in an inverted fashion, creating the lowest level dependencies first, and passing them up through the chain of services. This ensures that none of the services know how their dependencies are created, and that they are loosely coupled. We can have a look at this in action with something like this: $container = new Container(); // Create something to run on every resolve $container->extend(function($resolved, $container) { echo is_object($resolved) ? get_class($resolved) . ' created.<br />' : ''; }); // Define our services $container['sparkPlug'] = function() { return new SparkPlug(); }; $container['piston'] = function() { return new Piston(); }; $container['engine'] = function($c) { return new Engine($c['sparkPlug'], $c['piston']); }; $container['car'] = function($c) { return new Car($c['engine']); }; // Get our service $container->get('car'); This would then output the following: SparkPlug created. Piston created. Engine created. Car created. This is proof that the container uses the inversion of control principle since the global callback function gets called after each resolve. Service Providers Service providers are a way to organize your container entries. Service providers are nothing more than classes that implement the ServiceProvider interface that exposes a register method. The register method is always passed an instance of the container. For example, lets say that you have a suite of services that deal with user management. You could organize them into a single service provider class/file called UserServiceProvider . This class would then be responsible for adding all container entries related to user management. This simply provides a more organized and collected way of registering data in the container: class UserServiceProvider implements ServiceProvider { public function register(ContainerInterface $container) { $container->add('userManager', function() { ... }); $container->add('foo' ...); ... } }","title":"Dependency Container"},{"location":"dependency-container/#introduction","text":"Injecting dependencies can become a tedious task when many classes are involved. Before injecting a dependency it needs to be instantiated. So, we don't just take care of the \"injection\", we also need to have the knowledge of what objects it needs to work. A dependency injection container (DI Container) manages and automates instantiations. We tell him how an object should be created (this is the part that touches us, our knowledge about it) and then whenever we need it, we just need to use the container to obtain it. Solital implements the PSR-11, meaning you can easily create dependency containers. Consider this example: <?php class UserManager { private $mailer; public function __construct() { $this->mailer = new Mailer(); $this->mailer->setTransport('sendmail'); } public function setMailerTransport($transport) { $this->mailer->setTransport($transport); } } Here we have our UserManager service that is responsible for creating its Mailer dependency via setter injection. If we decide to later change the type of mailer that is used, and that mailer uses constructor injection rather than setter injection, we must alter our UserManager code, potentially breaking other methods that may use the setTransport method. Instead, the UserManager service should simply ask for a Mailer object, and get one. It should not care how it is created or what methods the mailer uses to configure itself, it just asks for one and receives one: class UserManager { private $mailer; public function __construct(Mailer $mailer) { $this->mailer = $mailer; } } The configuration of the mailer is now setup outside of the UserManager , and will not break anything if it is changed. So that leaves us with a question: Where should we write this \"wiring\" or configuration of the dependencies? That's where the container concept comes in. An IoC, or dependency injection container is the place where you would write up how your services should be created. Going back to the above example: <?php use Solital\\Core\\Container\\Container; $container = new Container(); $container->add('userManager', function($container) { $mailer = $container->get('mailer'); return new UserManager($mailer); }); $container->add('mailer', function() { $transport = 'gmail'; $mailer = new Mailer($transport); }); Now all we have to do is ask for the UserManager , and its Mailer dependency will be created for us. If we decide to change the transport methodback to sendmail at any point, all we have to do is change it in one place in the service configuration area.","title":"Introduction"},{"location":"dependency-container/#usage","text":"","title":"Usage"},{"location":"dependency-container/#instantiation","text":"To use the container, simply create a new instance of the Container class: $container = new Container(); You may also optionally pass an array of service and parameter entries directly into the constructor: $entries = ['foo' => 'bar']; $container = new Container($entries);","title":"Instantiation"},{"location":"dependency-container/#adding-definitions","text":"Services are defined by invokable callback functions. Most commonly, this is a closure (anonymous function) that explains how to create a service: $myServiceDefinition = function() { $obj = new Service(); return $obj; }; Parameters are simple primitive values that should be accessed throughout your application. It is assumed that your entry is a parameter if it is not an invokable function. To add a service or parameter to the container, use the Container::add method. $container = new Container(); $container->add('myParameter', 'value'); $container->add('myService', function() { return new MyService(); }); The container can also be accessed like an array. So adding entries is as easy as using array notation: $container = new Container(); $container['myParameter'] = 'value'; $container['myService'] = function() { return new MyService(); }; When defining services, note that an instance of the container is always passed as an argument to the invokable callback. This allows you to resolve nested dependencies. In our synopsis, we used the example of a UserManager service who needed a Mailer object. We can define how to create the mailer in one entry, and how to create the user manager in a separate entry like this: $container = new Container(); $container['userManager'] = function($container) { // The user manager needs a mailer, so get that from the container first $mailer = $container->get('mailer'); // Now pass that to the UserManager return new UserManager($mailer); }; $container['mailer'] = function() { return new Mailer(); }; $userManager = $container->get('userManager'); This is known as manually wiring your dependencies.","title":"Adding Definitions"},{"location":"dependency-container/#entry-management","text":"Just as entries can be added to the container, they may be removed via Container::remove as well: $container = new Container(); $container['myParameter'] = 'value'; $container->remove('myParameter'); // or: unset($container['myParameter']); We can also check if the container contains as entry with Container::has : $container = new Container(); $container['myParameter'] = 'value'; $has = $container->has('myParameter'); // or: isset($container['myParameter']); var_dump($has); // outputs: true Lastly, we can get an array of all of the entry names in our container with Container::keys : $container = new Container(); $container['myParameter'] = 'value'; $entries = $container->keys(); var_dump($entries); // outputs: ['myParameter']","title":"Entry Management"},{"location":"dependency-container/#retrieving-services-and-parameters","text":"Once an entry is added to the container, we can resolve that entry by using the Container::get method, or via array access: $container = new Container(); $container['myParameter'] = 'value'; $myParameter = $container->get('myParameter'); var_dump($myParameter); // outputs: 'value' $container['myService'] = function() { return new MyService(); }; $myService = $container['myService']; var_dump($myService instanceof MyService::class); // outputs: true Note that the service definition is executed and the result of the callback is what is assigned to $myService , rather than the literal callback function. If you would like a callback function to be interpreted as a literal value, you can use the Container::protect method: $container = new Container(); $container->add('myService', $container->protect(function() { return new MyService(); })); $myServiceFactory = $container->get('myService'); var_dump($myServiceFactory instanceof \\Closure); // outputs: true By default, when the container resolves a service entry, that service will be \"shared\" across the life of the container. This means that when the container is asked for the service a second time, the same instance will be returned as the first. This is often times the desired behavior when dealing with database connections, mailers, and logger objects. It would be a waste of memory to create these types of objects multiple times. You would not want 20 different database connections open at the same time if you really only need one: $container = new Container(); $container->add('db', function() { ... // database configuration return new PDO(); }); $db = $container->get('db'); $db2 = $container->get('db'); var_dump($db === $db2); // outputs: true However, sometimes you do need to get a new instance of a service each time it is accessed. For those cases, simply define the service as a factory with Container::factory : $container = new Container(); $container->add('myService', $container->factory(function() { return new MyService(); })); $myService = $container->get('myService'); $myService2 = $container->get('myService'); var_dump($myService === $myService2); // outputs: false","title":"Retrieving Services and Parameters"},{"location":"dependency-container/#extending-definitions","text":"Often times you need to modify a service after it has been created. This is often times called \"setter injection\" or \"decorating\". This can be achieved by using the Container::extend method. The extend method is passed the instance of the object and an instance of the container in that order. An extend will fail if: The entry does not exist The entry is a parameter The entry is currently being resolved The entry is protected The extend callback is not invokable Therefore, extending is meant to be done on existing service definitions only: $container = new Container(); $container['mailer'] = function() { return new Mailer(); }; $container->extend('mailer', function($mailer, $container) { $mailer->setTransport('sendmail'); $mailer->setUsername($container->get(...)); }); If, however, you leave the second argument empty and only assign an invokable callback, like so: $container->extend(function() {}); This will be treated as a global callback function that should be run on every resolve. This is also a cool way to see how inversion of control works. We can assign a callback to run whenever the container resolves any type of entry, and get some feedback about what it is creating. A great example of dependency injection comes from the Auryn container docs: class Car { private $engine; public function __construct(Engine $engine) { $this->engine = $engine; } } class Engine { private $sparkPlug; private $piston; public function __construct(SparkPlug $sparkPlug, Piston $piston) { $this->sparkPlug = $sparkPlug; $this->piston = $piston; } } As you can see we have a Car object that depends on an Engine object, and the Engine object depends on its own service objects SparkPlug and Piston . Using a normal object creation workflow, the wiring of these objects would look something like this: Application needs Car Car needs Engine so: Engine needs SparkPlug and Piston so: Engine creates SparkPlug Engine creates Piston Car creates engine Application creates Car However the wiring of objects using inversion of control looks like this: Application needs Car, which needs Engine, which needs SparkPlug and Piston so: Application creates SparkPlug and Piston Application creates Engine and gives it SparkPlug and Piston Application creates Car and gives it Engine You can see that the difference with inversion of control is that application (container) creates the dependencies in an inverted fashion, creating the lowest level dependencies first, and passing them up through the chain of services. This ensures that none of the services know how their dependencies are created, and that they are loosely coupled. We can have a look at this in action with something like this: $container = new Container(); // Create something to run on every resolve $container->extend(function($resolved, $container) { echo is_object($resolved) ? get_class($resolved) . ' created.<br />' : ''; }); // Define our services $container['sparkPlug'] = function() { return new SparkPlug(); }; $container['piston'] = function() { return new Piston(); }; $container['engine'] = function($c) { return new Engine($c['sparkPlug'], $c['piston']); }; $container['car'] = function($c) { return new Car($c['engine']); }; // Get our service $container->get('car'); This would then output the following: SparkPlug created. Piston created. Engine created. Car created. This is proof that the container uses the inversion of control principle since the global callback function gets called after each resolve.","title":"Extending Definitions"},{"location":"dependency-container/#service-providers","text":"Service providers are a way to organize your container entries. Service providers are nothing more than classes that implement the ServiceProvider interface that exposes a register method. The register method is always passed an instance of the container. For example, lets say that you have a suite of services that deal with user management. You could organize them into a single service provider class/file called UserServiceProvider . This class would then be responsible for adding all container entries related to user management. This simply provides a more organized and collected way of registering data in the container: class UserServiceProvider implements ServiceProvider { public function register(ContainerInterface $container) { $container->add('userManager', function() { ... }); $container->add('foo' ...); ... } }","title":"Service Providers"},{"location":"deploy/","text":"To deploy your project made in Solital Framework, do a git pull on your hosting. Then, update all components using composer update . Solital may receive some important updates during this period of development. Apache There is a htaccess file inside the public/ folder, but Apache needs to point to this folder. Therefore, in the root folder of your project, insert this other htaccess file below: RewriteEngine on # Force HTTPS RewriteCond %{HTTPS} off # Redirect to public/ with HTTPS RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301] RewriteCond %{HTTP_HOST} ^YOUR_DOMAIN.com$ [NC,OR] RewriteCond %{HTTP_HOST} ^www.YOUR_DOMAIN.com$ RewriteCond %{REQUEST_URI} !public/ RewriteRule (.*) /public/$1 [L] Replace YOUR_DOMAIN by the name of your primary domain. Nginx If you are using Nginx please make sure that url-rewriting is enabled. You can easily enable url-rewriting by adding the following configuration for the Nginx configuration-file for the demo-project. location / { try_files $uri $uri/ /index.php?$query_string; }","title":"Deploy"},{"location":"deploy/#apache","text":"There is a htaccess file inside the public/ folder, but Apache needs to point to this folder. Therefore, in the root folder of your project, insert this other htaccess file below: RewriteEngine on # Force HTTPS RewriteCond %{HTTPS} off # Redirect to public/ with HTTPS RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301] RewriteCond %{HTTP_HOST} ^YOUR_DOMAIN.com$ [NC,OR] RewriteCond %{HTTP_HOST} ^www.YOUR_DOMAIN.com$ RewriteCond %{REQUEST_URI} !public/ RewriteRule (.*) /public/$1 [L] Replace YOUR_DOMAIN by the name of your primary domain.","title":"Apache"},{"location":"deploy/#nginx","text":"If you are using Nginx please make sure that url-rewriting is enabled. You can easily enable url-rewriting by adding the following configuration for the Nginx configuration-file for the demo-project. location / { try_files $uri $uri/ /index.php?$query_string; }","title":"Nginx"},{"location":"dump/","text":"Sometimes it is necessary to dump the database. This process is very simple, just run the following command: php vinci db:dump Any dump files you run will be stored in app/Storage/dump . For Windows The process to perform the dump on Windows is a little different, you first need to edit the database.yaml file. You will need to indicate the location of mysqldump as shown below: dump_windows: mysql: C:\\xampp\\mysql\\bin\\mysqldump.exe pgsql: C:\\Program Files\\PostgreSQL\\14\\bin\\pg_dump.exe sqlite: Then run the command php vinci db:dump .","title":"Dump"},{"location":"dump/#for-windows","text":"The process to perform the dump on Windows is a little different, you first need to edit the database.yaml file. You will need to indicate the location of mysqldump as shown below: dump_windows: mysql: C:\\xampp\\mysql\\bin\\mysqldump.exe pgsql: C:\\Program Files\\PostgreSQL\\14\\bin\\pg_dump.exe sqlite: Then run the command php vinci db:dump .","title":"For Windows"},{"location":"environment-variables/","text":"The .env file has all the variables that Solital uses. Some are filled in by default, but others you need to edit as needed. Below we will see what each variable does: Displays all errors that Solital or PHP raises. Activate only in development mode ERRORS_DISPLAY=\"true\" Standard index that Solital uses to store session login. To learn more, see Authenticate INDEX_LOGIN=\"solital_index_login\" Database connection variables. To find out more, see Katrina ORM DB_DRIVE=\"\" DB_HOST=\"\" DB_NAME=\"\" DB_USER=\"\" DB_PASS=\"\" SQLITE_DIR=\"\" Variables of the Mailer class MAIL_DEBUG=\"\" MAIL_HOST=\"\" MAIL_USER=\"\" MAIL_PASS=\"\" MAIL_SECURITY=\"\" MAIL_PORT=\"\" Variables used in encryption. It is recommended that you add new values to these variables. FIRST_SECRET=\"first_secret\" SECOND_SECRET=\"second_secret\"","title":"Environment Variables"},{"location":"event-loop/","text":"PHP's new feature Fibers allows for easier creation of asynchronous applications, and a key component of designing such an application is the event loop. The event loop is responsible for monitoring external resources for interesting events such as new input data or state changes. Once an event is detected, the event loop will resume the fibers that are interested in that event so they can process it. There are many ways to implement such a loop, ranging from a trivial sleep and resume to a complex, multifeatured event monitoring system. In this article, we'll look at a few examples and build up on the complexity as we go. Below is an example of how to use EventLoop in your project: use Solital\\Core\\Queue\\EventLoop; $loop = new EventLoop(); $loop->defer(function() use ($loop){ $loop->sleep(0.2); foreach (range(1, 5) as $value) { echo $value; $loop->next(); } }); $loop->defer(function() use ($loop){ foreach (range(1, 10) as $value) { echo $value; $loop->next(); } }); $loop->run();","title":"Event Loop"},{"location":"events/","text":"Events This section will help you understand how to register your own callbacks to events in the router. It will also cover the basics of event-handlers; how to use the handlers provided with the router and how to create your own custom event-handlers. Available events This section contains all available events that can be registered using the EventHandler . All event callbacks will retrieve a EventArgument object as parameter. This object contains easy access to event-name, router- and request instance and any special event-arguments related to the given event. You can see what special event arguments each event returns in the list below. Name Special arguments Description EVENT_ALL - Fires when a event is triggered EVENT_INIT loadedRoutes Fires when router is initializing and before routes are loaded EVENT_LOAD loadedRoutes Fires when all routes has been loaded and rendered, just before the output is returned EVENT_ADD_ROUTE route Fires when route is added to the router EVENT_REWRITE rewriteUrl rewriteRoute Fires when a url-rewrite is and just before the routes are re-initialized EVENT_BOOT bootmanagers Fires when the router is booting. This happens just before boot-managers are rendered and before any routes has been loaded EVENT_RENDER_BOOTMANAGER bootmanagers bootmanager Fires before a boot-manager is rendered EVENT_LOAD_ROUTES routes Fires when the router is about to load all routes EVENT_FIND_ROUTE name Fires whenever the `findRoute` method is called within the `Router`. This usually happens when the router tries to find routes that contains a certain url, usually after the `EventHandler::EVENT_GET_URL` event EVENT_GET_URL name parameters getParams Fires whenever the `Router::getUrl` method or `url`-helper function is called and the router tries to find the route EVENT_MATCH_ROUTE route Fires when a route is matched and valid (correct request-type etc). and before the route is rendered EVENT_RENDER_ROUTE route Fires before a route is rendered EVENT_LOAD_EXCEPTIONS exception exceptionHandlers Fires when the router is loading exception-handlers EVENT_RENDER_EXCEPTION exception exceptionHandler exceptionHandlers Fires before the router is rendering a exception-handler EVENT_RENDER_MIDDLEWARES route middlewares Fires before middlewares for a route is rendered EVENT_RENDER_CSRF csrfVerifier Fires before the CSRF-verifier is rendered Registering new event To register a new event you need to create a new instance of the EventHandler object. On this object you can add as many callbacks as you like by calling the registerEvent method. When you've registered events, make sure to add it to the router by calling Course::addEventHandler() . We recommend that you add your event-handlers within your routes.php . Example: use Solital\\Core\\Course\\Handlers\\EventHandler; use Solital\\Core\\Course\\Event\\EventArgument; // --- your routes goes here --- $eventHandler = new EventHandler(); // Add event that fires when a route is rendered $eventHandler->register(EventHandler::EVENT_RENDER_ROUTE, function(EventArgument $argument) { // Get the route by using the special argument for this event. $route = $argument->route; // DO STUFF... }); Course::addEventHandler($eventHandler); Custom EventHandlers EventHandler is the class that manages events and must inherit from the EventHandlerInterface interface. The handler knows how to handle events for the given handler-type. Most of the time the basic \\Solital\\Core\\Course\\Handler\\EventHandler class will be more than enough for most people as you simply register an event which fires when triggered. Let's go over how to create your very own event-handler class. Below is a basic example of a custom event-handler called DatabaseDebugHandler . The idea of the sample below is to logs all events to the database when triggered. Hopefully it will be enough to give you an idea on how the event-handlers work. namespace Demo\\Handlers; use Solital\\Core\\Course\\Event\\EventArgument; use Solital\\Core\\Course\\Router; class DatabaseDebugHandler implements EventHandlerInterface { /** * Debug callback * @var \\Closure */ protected $callback; public function __construct() { $this->callback = function (EventArgument $argument) { // todo: store log in database }; } /** * Get events. * * @param string|null $name Filter events by name. * @return array */ public function getEvents(?string $name): array { return [ $name => [ $this->callback, ], ]; } /** * Fires any events registered with given event-name * * @param Router $router Router instance * @param string $name Event name * @param array ...$eventArgs Event arguments */ public function fireEvents(Router $router, string $name, ...$eventArgs): void { $callback = $this->callback; $callback(new EventArgument($router, $eventArgs)); } /** * Set debug callback * * @param \\Closure $event */ public function setCallback(\\Closure $event): void { $this->callback = $event; } } Using the PSR-14 It is possible to use the PSR-14 through the EventDispatcher class. You can create the test class below: class UserTest { public function testLow() { echo \"Running Low ...\"; } public function testNormal() { echo \"Running Normal ...\"; } public function testHigh() { echo \"Running High ...\"; } } Then, use the addListener method to add the event referring to the UserTest class. You can define the priority of each method and the order in which it will be executed. To do this, use a number in the last parameter of addListener . $provider = new ListenerProvider(); $event = new EventDispatcher($provider); $user = new UserTest(); $provider->addListener(function (UserTest $user) { $user->testLow(); }, 1); $provider->addListener(function (UserTest $user) { $user->testNormal(); }, 2); $provider->addListener(function (UserTest $user) { $user->testHigh(); }, 3); $event->dispatch($user); As defined in the priority, the result will be Running High... , Running Normal... and Running Low... .","title":"Events"},{"location":"events/#events","text":"This section will help you understand how to register your own callbacks to events in the router. It will also cover the basics of event-handlers; how to use the handlers provided with the router and how to create your own custom event-handlers.","title":"Events"},{"location":"events/#available-events","text":"This section contains all available events that can be registered using the EventHandler . All event callbacks will retrieve a EventArgument object as parameter. This object contains easy access to event-name, router- and request instance and any special event-arguments related to the given event. You can see what special event arguments each event returns in the list below. Name Special arguments Description EVENT_ALL - Fires when a event is triggered EVENT_INIT loadedRoutes Fires when router is initializing and before routes are loaded EVENT_LOAD loadedRoutes Fires when all routes has been loaded and rendered, just before the output is returned EVENT_ADD_ROUTE route Fires when route is added to the router EVENT_REWRITE rewriteUrl rewriteRoute Fires when a url-rewrite is and just before the routes are re-initialized EVENT_BOOT bootmanagers Fires when the router is booting. This happens just before boot-managers are rendered and before any routes has been loaded EVENT_RENDER_BOOTMANAGER bootmanagers bootmanager Fires before a boot-manager is rendered EVENT_LOAD_ROUTES routes Fires when the router is about to load all routes EVENT_FIND_ROUTE name Fires whenever the `findRoute` method is called within the `Router`. This usually happens when the router tries to find routes that contains a certain url, usually after the `EventHandler::EVENT_GET_URL` event EVENT_GET_URL name parameters getParams Fires whenever the `Router::getUrl` method or `url`-helper function is called and the router tries to find the route EVENT_MATCH_ROUTE route Fires when a route is matched and valid (correct request-type etc). and before the route is rendered EVENT_RENDER_ROUTE route Fires before a route is rendered EVENT_LOAD_EXCEPTIONS exception exceptionHandlers Fires when the router is loading exception-handlers EVENT_RENDER_EXCEPTION exception exceptionHandler exceptionHandlers Fires before the router is rendering a exception-handler EVENT_RENDER_MIDDLEWARES route middlewares Fires before middlewares for a route is rendered EVENT_RENDER_CSRF csrfVerifier Fires before the CSRF-verifier is rendered","title":"Available events"},{"location":"events/#registering-new-event","text":"To register a new event you need to create a new instance of the EventHandler object. On this object you can add as many callbacks as you like by calling the registerEvent method. When you've registered events, make sure to add it to the router by calling Course::addEventHandler() . We recommend that you add your event-handlers within your routes.php . Example: use Solital\\Core\\Course\\Handlers\\EventHandler; use Solital\\Core\\Course\\Event\\EventArgument; // --- your routes goes here --- $eventHandler = new EventHandler(); // Add event that fires when a route is rendered $eventHandler->register(EventHandler::EVENT_RENDER_ROUTE, function(EventArgument $argument) { // Get the route by using the special argument for this event. $route = $argument->route; // DO STUFF... }); Course::addEventHandler($eventHandler);","title":"Registering new event"},{"location":"events/#custom-eventhandlers","text":"EventHandler is the class that manages events and must inherit from the EventHandlerInterface interface. The handler knows how to handle events for the given handler-type. Most of the time the basic \\Solital\\Core\\Course\\Handler\\EventHandler class will be more than enough for most people as you simply register an event which fires when triggered. Let's go over how to create your very own event-handler class. Below is a basic example of a custom event-handler called DatabaseDebugHandler . The idea of the sample below is to logs all events to the database when triggered. Hopefully it will be enough to give you an idea on how the event-handlers work. namespace Demo\\Handlers; use Solital\\Core\\Course\\Event\\EventArgument; use Solital\\Core\\Course\\Router; class DatabaseDebugHandler implements EventHandlerInterface { /** * Debug callback * @var \\Closure */ protected $callback; public function __construct() { $this->callback = function (EventArgument $argument) { // todo: store log in database }; } /** * Get events. * * @param string|null $name Filter events by name. * @return array */ public function getEvents(?string $name): array { return [ $name => [ $this->callback, ], ]; } /** * Fires any events registered with given event-name * * @param Router $router Router instance * @param string $name Event name * @param array ...$eventArgs Event arguments */ public function fireEvents(Router $router, string $name, ...$eventArgs): void { $callback = $this->callback; $callback(new EventArgument($router, $eventArgs)); } /** * Set debug callback * * @param \\Closure $event */ public function setCallback(\\Closure $event): void { $this->callback = $event; } }","title":"Custom EventHandlers"},{"location":"events/#using-the-psr-14","text":"It is possible to use the PSR-14 through the EventDispatcher class. You can create the test class below: class UserTest { public function testLow() { echo \"Running Low ...\"; } public function testNormal() { echo \"Running Normal ...\"; } public function testHigh() { echo \"Running High ...\"; } } Then, use the addListener method to add the event referring to the UserTest class. You can define the priority of each method and the order in which it will be executed. To do this, use a number in the last parameter of addListener . $provider = new ListenerProvider(); $event = new EventDispatcher($provider); $user = new UserTest(); $provider->addListener(function (UserTest $user) { $user->testLow(); }, 1); $provider->addListener(function (UserTest $user) { $user->testNormal(); }, 2); $provider->addListener(function (UserTest $user) { $user->testHigh(); }, 3); $event->dispatch($user); As defined in the priority, the result will be Running High... , Running Normal... and Running Low... .","title":"Using the PSR-14"},{"location":"file-system/","text":"You can manipulate folders and files within Solital through the HandleFiles class, such as creating folders, removing folders, listing files and deleting files. use Solital\\Core\\FileSystem\\HandleFiles; $handle = new HandleFiles(); List files within a folder list multiple files Use the folder() method to define the folder containing the files in Solital to be listed. To list all files within that folder, chain the files() method. /** Array return */ $res = $handle->folder(\"folder_name\")->files(); pre($res); list single file /** String return */ $res = $handle->folder(\"folder_name\")->file('README.md'); pre($res); To list only a single file within the folder, use the file() method passing as a parameter the file you want to search for Check if a file exists To check if there is a file inside the folder, use fileExists() . /** Boolean return */ $res = $handle->folder(\"folder_name\")->fileExists(\"README.md\"); pre($res); You can delete the file if it exists, to do so enter true in the second parameter. /** Boolean return */ $res = $handle->folder(\"folder_name\")->fileExists(\"README.md\", true); pre($res); Create folder To create a folder inside Solital, use only the create() method. /** Boolean return */ $res = $handle->create(\"folder_name\"); pre($res); You can define the type of permission the folder will have. The default is 0777. /** Boolean return */ $res = $handle->create(\"folder_name\", 0755); pre($res); Remove folder To delete a folder inside Solital, use only the remove() method. This method will delete a folder if it is empty. /** Boolean return */ $res = $handle->remove(\"folder_name\"); pre($res); The remove() method checks for files inside the folder. If you want to delete the files inside the folder, pass false in the second parameter. /** Boolean return */ $res = $handle->remove(\"folder_name\", false); pre($res); Get and Put Contents It is possible to use the native PHP functions file_get_contents and file_put_contents at the same time. The getAndPutContents method performs this process. $res = $handle->getAndPutContents('file.txt', 'file_bkp.txt'); pre($res); Copy Make a copy of a file using the copy method. /** Boolean return */ $res = $handle->copy('file.txt', 'file_bkp.txt'); pre($res); If you want to delete the original photo after copying, use true . /** Boolean return */ $res = $handle->copy('file.txt', 'file_bkp.txt', true); pre($res); Handling permissions You can change and view file and folder permissions. List permissions The getPermission method lists the permissions that the file or folder has. /** Null|string return */ $res = $handle->getPermission('file.txt'); pre($res); List full permissions To return full permissions, use the getFullPermission method. /** String return */ $res = $handle->getFullPermission('file.txt'); pre($res); Change permissions The setPermission method changes the permissions that the file or folder will have. /** Boolean return */ $handle->setPermission('file.txt', 0777); Modify owner of the file Use the setOwner method to modify the owner of the file. /** Boolean return */ $res = $handle->setOwner('file.txt', 'root'); pre($res);","title":"File System"},{"location":"file-system/#list-files-within-a-folder","text":"list multiple files Use the folder() method to define the folder containing the files in Solital to be listed. To list all files within that folder, chain the files() method. /** Array return */ $res = $handle->folder(\"folder_name\")->files(); pre($res); list single file /** String return */ $res = $handle->folder(\"folder_name\")->file('README.md'); pre($res); To list only a single file within the folder, use the file() method passing as a parameter the file you want to search for","title":"List files within a folder"},{"location":"file-system/#check-if-a-file-exists","text":"To check if there is a file inside the folder, use fileExists() . /** Boolean return */ $res = $handle->folder(\"folder_name\")->fileExists(\"README.md\"); pre($res); You can delete the file if it exists, to do so enter true in the second parameter. /** Boolean return */ $res = $handle->folder(\"folder_name\")->fileExists(\"README.md\", true); pre($res);","title":"Check if a file exists"},{"location":"file-system/#create-folder","text":"To create a folder inside Solital, use only the create() method. /** Boolean return */ $res = $handle->create(\"folder_name\"); pre($res); You can define the type of permission the folder will have. The default is 0777. /** Boolean return */ $res = $handle->create(\"folder_name\", 0755); pre($res);","title":"Create folder"},{"location":"file-system/#remove-folder","text":"To delete a folder inside Solital, use only the remove() method. This method will delete a folder if it is empty. /** Boolean return */ $res = $handle->remove(\"folder_name\"); pre($res); The remove() method checks for files inside the folder. If you want to delete the files inside the folder, pass false in the second parameter. /** Boolean return */ $res = $handle->remove(\"folder_name\", false); pre($res);","title":"Remove folder"},{"location":"file-system/#get-and-put-contents","text":"It is possible to use the native PHP functions file_get_contents and file_put_contents at the same time. The getAndPutContents method performs this process. $res = $handle->getAndPutContents('file.txt', 'file_bkp.txt'); pre($res);","title":"Get and Put Contents"},{"location":"file-system/#copy","text":"Make a copy of a file using the copy method. /** Boolean return */ $res = $handle->copy('file.txt', 'file_bkp.txt'); pre($res); If you want to delete the original photo after copying, use true . /** Boolean return */ $res = $handle->copy('file.txt', 'file_bkp.txt', true); pre($res);","title":"Copy"},{"location":"file-system/#handling-permissions","text":"You can change and view file and folder permissions.","title":"Handling permissions"},{"location":"file-system/#list-permissions","text":"The getPermission method lists the permissions that the file or folder has. /** Null|string return */ $res = $handle->getPermission('file.txt'); pre($res);","title":"List permissions"},{"location":"file-system/#list-full-permissions","text":"To return full permissions, use the getFullPermission method. /** String return */ $res = $handle->getFullPermission('file.txt'); pre($res);","title":"List full permissions"},{"location":"file-system/#change-permissions","text":"The setPermission method changes the permissions that the file or folder will have. /** Boolean return */ $handle->setPermission('file.txt', 0777);","title":"Change permissions"},{"location":"file-system/#modify-owner-of-the-file","text":"Use the setOwner method to modify the owner of the file. /** Boolean return */ $res = $handle->setOwner('file.txt', 'root'); pre($res);","title":"Modify owner of the file"},{"location":"helpers/","text":"Helpers are functions that help the developer manipulate classes, without having to instantiate them. Here you will find the helpers that exist in Solital Framework. Some specific helpers are not listed on this page, but you can find them on the next pages of the documentation. Some helpers can be replaced by methods, as long as you use them inside a Controller. HTTP Handles the URI class. See more in routes . /** * @param string $name * @param mixed $parameters * @param null|array $getParams */ url(?string $name = null, $parameters = null, ?array $getParams) Handles the Response class. response() Handles the Request class. request() Get input class. See more in Input and params . /** * @param string|null $index: Parameter index name * @param string|null $defaultValue: Default return value * @param array ...$methods: Default methods * * @return mixed */ input(string $index = null, string $defaultValue = null, ...$methods) # With method $this->getRequestParams(string $index = null, string $defaultValue = null, ...$methods) Redirect to another route. /** * @param string $url: the route to which you will be redirected * @param int|null $code: HTTP code */ redirect(string $url, ?int $code = null) # Or, use a method $this->redirect(string $url, ?int $code = null) Defines a limit on requests that can be made at a certain time /** * @param string $key: key to identify the requisition * @param int $limit: number of times the request can be made * @param int $seconds: waiting time until it is possible to make the request again. * * @return bool */ request_limit(string $key, int $limit = 5, int $seconds = 60) # With method $this->requestLimit(string $key, int $limit = 5, int $seconds = 60) Checks if a value was previously sent in the requisition. /** * @param string $key: key to identify the requisition * @param string $value: value that will be added * * @return bool */ request_repeat(string $key, string $value) # With method $this->requestRepeat(string $key, string $value) Security Get current csrf-token. See more in CSRF Protection . csrf_token() Form method spoofing. /** * @param string $method: GET, POST, PUT or DELETE */ spoofing(string $method) Generate password hash using PHP Secure Password component /** * @param mixed $value: the user's password. * @param int $cost: which denotes the algorithmic cost that should be used. */ pass_hash($value, int $cost = 10) Checks the hash generated by the pass_hash helper or the PHP Secure Password component /** * @param mixed $value: the user's password. * @param string $hash: a hash created by `pass_hash()`. */ pass_verify($value, string $hash) Wolf Template See Wolf Template to use Wolf helpers. Load a CSS file into the public/assets/_css/ folder. /** * @param string $asset: CSS file name */ load_css(string $asset) Loads the minified CSS file created by the minify()->style() method. load_min_css() Load a Javascript file into the public/assets/_js/ folder. /** * @param string $asset: javascript file name */ load_js(string $asset) Loads the minified Javascript file created by the minify()->script() method. load_min_js() Load a image file into the public/assets/_img/ folder. /** * @param string $asset: image file name */ load_img(string $asset) Load a file into the public/assets/ folder. /** * @param string $asset: external file name */ load_file(string $asset) Output Formatted var_dump . /** * @param mixed $value: to format */ pre($value) cloner uses Symfony VarCloner function. See more . /** * @param mixed $var */ cloner($var) Displays the variable formatted in string. true to return as an array. /** * @param mixed $var * @param bool $length */ dumper($var, bool $length = false) It is possible to make use of Symfony dump function. dump($var) export uses the Symfony VarExport function. See more . /** * @param mixed $value */ export($value) Convert an array to JSON and display an error message in case of failure. /** * @param mixed $value: to JSON */ encodeJSON($value) Convert a JSON to an object and display an error message in case of failure. true to convert JSON to an array. /** * @param mixed $value: to JSON * @param bool $toArray: convert JSON object in array */ decodeJSON($value, bool $toArray = false) Write any message in the browser LOG, which can be viewed at any time. /** * @param mixed ...$messages * * @return void */ console_log(...$messages) Session Handles PHP sessions. To get a value from an existing session, leave the $value parameter empty. To create a new session, inform the session key in the first parameter, and the session value in the second parameter. See more in Session and Cookies . /** * @param string $key: index that will identify the session * @param mixed $value: session value * @param mixed $defaultValue: array of values (see Session class documentation) * @param bool $delete: if the value is `true`, the session will be deleted. * @param bool $take: returns the requested value and removes it from the session. * * @return mixed */ session(string $key, mixed $value = null, mixed $defaultValue = null, bool $delete = false, bool $take = false) Others Removes GET parameters in the URL and reloads the page without those parameters. remove_param() # With method $this->removeParamsUrl() Check if variable is JSON. /** * @param mixed $string: verify if value is JSON */ is_json($string) Get the current full URL. /** * @param string $uri */ get_url(string $uri = null) Returns trailing name component of path and get rid of trailing slashes/backslashes. /** * @param string $path * * @return string|null */ mb_basename(string $path) Implode an array as key-value pairs. The third parameter is the symbol to be used between key and value. /** * @param string $glue * @param array $array * @param string $symbol * * @return string */ mapped_implode(string $glue, array $array, string $symbol = '=') Manipulate the ArrayCollection class without having to instantiate it. /** * @param mixed $value * * @return ArrayCollection */ collection(mixed $value = null) Manipulate the Str class without having to instantiate it. /** * @param string $string * * @return Str */ str(string $string)","title":"Helpers"},{"location":"helpers/#http","text":"Handles the URI class. See more in routes . /** * @param string $name * @param mixed $parameters * @param null|array $getParams */ url(?string $name = null, $parameters = null, ?array $getParams) Handles the Response class. response() Handles the Request class. request() Get input class. See more in Input and params . /** * @param string|null $index: Parameter index name * @param string|null $defaultValue: Default return value * @param array ...$methods: Default methods * * @return mixed */ input(string $index = null, string $defaultValue = null, ...$methods) # With method $this->getRequestParams(string $index = null, string $defaultValue = null, ...$methods) Redirect to another route. /** * @param string $url: the route to which you will be redirected * @param int|null $code: HTTP code */ redirect(string $url, ?int $code = null) # Or, use a method $this->redirect(string $url, ?int $code = null) Defines a limit on requests that can be made at a certain time /** * @param string $key: key to identify the requisition * @param int $limit: number of times the request can be made * @param int $seconds: waiting time until it is possible to make the request again. * * @return bool */ request_limit(string $key, int $limit = 5, int $seconds = 60) # With method $this->requestLimit(string $key, int $limit = 5, int $seconds = 60) Checks if a value was previously sent in the requisition. /** * @param string $key: key to identify the requisition * @param string $value: value that will be added * * @return bool */ request_repeat(string $key, string $value) # With method $this->requestRepeat(string $key, string $value)","title":"HTTP"},{"location":"helpers/#security","text":"Get current csrf-token. See more in CSRF Protection . csrf_token() Form method spoofing. /** * @param string $method: GET, POST, PUT or DELETE */ spoofing(string $method) Generate password hash using PHP Secure Password component /** * @param mixed $value: the user's password. * @param int $cost: which denotes the algorithmic cost that should be used. */ pass_hash($value, int $cost = 10) Checks the hash generated by the pass_hash helper or the PHP Secure Password component /** * @param mixed $value: the user's password. * @param string $hash: a hash created by `pass_hash()`. */ pass_verify($value, string $hash)","title":"Security"},{"location":"helpers/#wolf-template","text":"See Wolf Template to use Wolf helpers. Load a CSS file into the public/assets/_css/ folder. /** * @param string $asset: CSS file name */ load_css(string $asset) Loads the minified CSS file created by the minify()->style() method. load_min_css() Load a Javascript file into the public/assets/_js/ folder. /** * @param string $asset: javascript file name */ load_js(string $asset) Loads the minified Javascript file created by the minify()->script() method. load_min_js() Load a image file into the public/assets/_img/ folder. /** * @param string $asset: image file name */ load_img(string $asset) Load a file into the public/assets/ folder. /** * @param string $asset: external file name */ load_file(string $asset)","title":"Wolf Template"},{"location":"helpers/#output","text":"Formatted var_dump . /** * @param mixed $value: to format */ pre($value) cloner uses Symfony VarCloner function. See more . /** * @param mixed $var */ cloner($var) Displays the variable formatted in string. true to return as an array. /** * @param mixed $var * @param bool $length */ dumper($var, bool $length = false) It is possible to make use of Symfony dump function. dump($var) export uses the Symfony VarExport function. See more . /** * @param mixed $value */ export($value) Convert an array to JSON and display an error message in case of failure. /** * @param mixed $value: to JSON */ encodeJSON($value) Convert a JSON to an object and display an error message in case of failure. true to convert JSON to an array. /** * @param mixed $value: to JSON * @param bool $toArray: convert JSON object in array */ decodeJSON($value, bool $toArray = false) Write any message in the browser LOG, which can be viewed at any time. /** * @param mixed ...$messages * * @return void */ console_log(...$messages)","title":"Output"},{"location":"helpers/#session","text":"Handles PHP sessions. To get a value from an existing session, leave the $value parameter empty. To create a new session, inform the session key in the first parameter, and the session value in the second parameter. See more in Session and Cookies . /** * @param string $key: index that will identify the session * @param mixed $value: session value * @param mixed $defaultValue: array of values (see Session class documentation) * @param bool $delete: if the value is `true`, the session will be deleted. * @param bool $take: returns the requested value and removes it from the session. * * @return mixed */ session(string $key, mixed $value = null, mixed $defaultValue = null, bool $delete = false, bool $take = false)","title":"Session"},{"location":"helpers/#others","text":"Removes GET parameters in the URL and reloads the page without those parameters. remove_param() # With method $this->removeParamsUrl() Check if variable is JSON. /** * @param mixed $string: verify if value is JSON */ is_json($string) Get the current full URL. /** * @param string $uri */ get_url(string $uri = null) Returns trailing name component of path and get rid of trailing slashes/backslashes. /** * @param string $path * * @return string|null */ mb_basename(string $path) Implode an array as key-value pairs. The third parameter is the symbol to be used between key and value. /** * @param string $glue * @param array $array * @param string $symbol * * @return string */ mapped_implode(string $glue, array $array, string $symbol = '=') Manipulate the ArrayCollection class without having to instantiate it. /** * @param mixed $value * * @return ArrayCollection */ collection(mixed $value = null) Manipulate the Str class without having to instantiate it. /** * @param string $string * * @return Str */ str(string $string)","title":"Others"},{"location":"http-client/","text":"Solital has a component to manipulate the HTTP client, useful for consuming API and making HTTP requests. Before, you will need to install the component using the command below: composer require solital/http-client Requirements PHP >= 8.0 CURL extension enabled Basic use To make basic use of the component, you will need to instantiate the HttpClient class. Then, call the request function, passing the method (GET, POST, ...) and the url as a parameter. Then return the data. use Solital\\HttpClient; $client = new HttpClient(); $client->request(\"GET\", \"http://api.url.com\"); $res = $client->toJson(); pre($res); Supported methods HttpClient supports the methods below. GET POST PUT DELETE PATCH OPTIONS Return types You can return the answer in json, array or object. The methods below show an example. $client = new HttpClient(); $client->request(\"GET\", \"http://api.url.com\"); /** Return json */ $res = $client->toJson(); /** Return array */ $res = $client->toArray(); /** Return object */ $res = $client->toObject(); pre($res); Sending data If you are using a POST or PUT request, for example, and need to send data to the HTTP header, you can pass an array with the values in the request method. $client = new HttpClient(); $res = $client->request(\"PUT\", \"http://api.url.com\", [ 'data' => 'your_data_values' ])->toJson(); echo $res; Custom Headers By default, HttpClient has the following headers: Content-Type: application/json Accept: application/json To add other headers to the request, use an array in the constructor on the instance. $headers = [ 'Content-Type: application/pdf' ]; $client = new HttpClient($headers); #... Enabling SSL verification HttpClient by default does not perform SSL verification. To enable verification, use the enableSSL method. $client = new HttpClient(); $client->enableSSL(); #... Authentication Basic Auth If you are handling an API with authentication in basic, you can use the basicAuth() method to do the authentication. The first parameter will be the username, while the second parameter will be the password. $client = new HttpClient(); $client->basicAuth('user', 'pass'); $client->request(\"GET\", \"http://api.url.com\"); $res = $client->toJson(); pre($res); Bearer authentication For authentications using the bearer token, you can use the bearerToken() method to provide the authentication token. $client = new HttpClient(); $http_client->bearerToken(\"2edac0d91305c9207d36eda3cbf2c0d7\"); $client->request(\"GET\", \"http://api.url.com\"); $res = $client->toJson(); pre($res); Securing your API You can secure your API URL using basic or digest authentication. First, instantiate the HttpAuth class: use Solital\\Http\\Auth\\HttpAuth; $auth = new HttpAuth(); With Basic Auth To secure your API using basic authentication, use the basic() method providing the username and password to authenticate. $auth = new HttpAuth(); $auth->basic('username', '123'); If you want, you can change the value of realm in the second parameter. $auth = new HttpAuth(); $auth->basic('username', '123', 'my_realm'); With Digest Auth To use digest to protect your API, use the digest() method. In this method, you must use an array to inform the username and password. You can define multiple users for this authentication type. $auth = new HttpAuth(); $auth->digest(['username_1' => 'password_1', 'username_2' => 'password_2', ...]); If you want, you can change the value of realm in the second parameter. $auth = new HttpAuth(); $auth->digest(['username_1' => 'password_1'], 'my_second_realm');","title":"HTTP Client"},{"location":"http-client/#requirements","text":"PHP >= 8.0 CURL extension enabled","title":"Requirements"},{"location":"http-client/#basic-use","text":"To make basic use of the component, you will need to instantiate the HttpClient class. Then, call the request function, passing the method (GET, POST, ...) and the url as a parameter. Then return the data. use Solital\\HttpClient; $client = new HttpClient(); $client->request(\"GET\", \"http://api.url.com\"); $res = $client->toJson(); pre($res);","title":"Basic use"},{"location":"http-client/#supported-methods","text":"HttpClient supports the methods below. GET POST PUT DELETE PATCH OPTIONS","title":"Supported methods"},{"location":"http-client/#return-types","text":"You can return the answer in json, array or object. The methods below show an example. $client = new HttpClient(); $client->request(\"GET\", \"http://api.url.com\"); /** Return json */ $res = $client->toJson(); /** Return array */ $res = $client->toArray(); /** Return object */ $res = $client->toObject(); pre($res);","title":"Return types"},{"location":"http-client/#sending-data","text":"If you are using a POST or PUT request, for example, and need to send data to the HTTP header, you can pass an array with the values in the request method. $client = new HttpClient(); $res = $client->request(\"PUT\", \"http://api.url.com\", [ 'data' => 'your_data_values' ])->toJson(); echo $res;","title":"Sending data"},{"location":"http-client/#custom-headers","text":"By default, HttpClient has the following headers: Content-Type: application/json Accept: application/json To add other headers to the request, use an array in the constructor on the instance. $headers = [ 'Content-Type: application/pdf' ]; $client = new HttpClient($headers); #...","title":"Custom Headers"},{"location":"http-client/#enabling-ssl-verification","text":"HttpClient by default does not perform SSL verification. To enable verification, use the enableSSL method. $client = new HttpClient(); $client->enableSSL(); #...","title":"Enabling SSL verification"},{"location":"http-client/#authentication","text":"","title":"Authentication"},{"location":"http-client/#basic-auth","text":"If you are handling an API with authentication in basic, you can use the basicAuth() method to do the authentication. The first parameter will be the username, while the second parameter will be the password. $client = new HttpClient(); $client->basicAuth('user', 'pass'); $client->request(\"GET\", \"http://api.url.com\"); $res = $client->toJson(); pre($res);","title":"Basic Auth"},{"location":"http-client/#bearer-authentication","text":"For authentications using the bearer token, you can use the bearerToken() method to provide the authentication token. $client = new HttpClient(); $http_client->bearerToken(\"2edac0d91305c9207d36eda3cbf2c0d7\"); $client->request(\"GET\", \"http://api.url.com\"); $res = $client->toJson(); pre($res);","title":"Bearer authentication"},{"location":"http-client/#securing-your-api","text":"You can secure your API URL using basic or digest authentication. First, instantiate the HttpAuth class: use Solital\\Http\\Auth\\HttpAuth; $auth = new HttpAuth();","title":"Securing your API"},{"location":"http-client/#with-basic-auth","text":"To secure your API using basic authentication, use the basic() method providing the username and password to authenticate. $auth = new HttpAuth(); $auth->basic('username', '123'); If you want, you can change the value of realm in the second parameter. $auth = new HttpAuth(); $auth->basic('username', '123', 'my_realm');","title":"With Basic Auth"},{"location":"http-client/#with-digest-auth","text":"To use digest to protect your API, use the digest() method. In this method, you must use an array to inform the username and password. You can define multiple users for this authentication type. $auth = new HttpAuth(); $auth->digest(['username_1' => 'password_1', 'username_2' => 'password_2', ...]); If you want, you can change the value of realm in the second parameter. $auth = new HttpAuth(); $auth->digest(['username_1' => 'password_1'], 'my_second_realm');","title":"With Digest Auth"},{"location":"input-and-params/","text":"Solital offers libraries and helpers that makes it easy to manage and manipulate input-parameters like $_POST , $_GET and $_FILE . You can use the InputHandler class to easily access and manage parameters from your request. The InputHandler class offers extended features such as copying/moving uploaded files directly on the object, getting file-extension, mime-type etc. Get single parameter value # With Helper input($index, $defaultValue, ...$methods); # With method $this->getRequestParams($index, $defaultValue, ...$methods); To quickly get a value from a parameter, you can use the input helper function or the getRequestParams method. The getRequestParams method can only be used inside a Controller. This will automatically trim the value and ensure that it's not empty. If it's empty the $defaultValue will be returned instead. Note: This function returns a string unless the parameters are grouped together, in that case it will return an array of values. Example: This example matches both POST and GET request-methods and if name is empty the default-value \"Guest\" will be returned. #With helper $name = input('name', 'Guest', 'post', 'get'); # With method $name = $this->getRequestParams('name', 'Guest', 'post', 'get'); Get parameter object When dealing with file-uploads it can be useful to retrieve the raw parameter object. Search for object with default-value across multiple or specific request-methods: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. #With Helper $object = input()->find($index, $defaultValue = null, ...$methods); # With method $object = $this->getRequestParams()->find($index, $defaultValue = null, ...$methods); Getting specific $_GET parameter as InputItem object: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. # With Helper $object = input()->get($index, $defaultValue = null); # With method $object = $this->getRequestParams()->get($index, $defaultValue = null); Getting specific $_POST parameter as InputItem object: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. # With Helper $object = input()->post($index, $defaultValue = null); # With method $object = $this->getRequestParams()->post($index, $defaultValue = null); Getting specific $_FILE parameter as InputFile object: The example below will return an InputFile object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputFile objects. # With Helper $object = input()->file($index, $defaultValue = null); # With method $object = $this->getRequestParams()->file($index, $defaultValue = null); Managing files Below you will find some code to help you upload files in a quick way. /** * From a form on the page like this * <input type=\"file\" name=\"images\" /> * * Only file */ $ext = input()->file('image')->getExtension(); $imgMain = 'IMG-'.uniqid().\".\".$ext; input()->file('image')->move(dirname(__DIR__).'/photos/'.$imgMain); /** * Loop through a collection of files uploaded from a form on the page like this * <input type=\"file\" name=\"images[]\" multiple /> * * Multiple files */ foreach ($photo as $photo) { $ext = $photo->getExtension(); $img = 'IMG-'.uniqid().\".\".$ext; $photo->move(dirname(__DIR__).'/photos/'.$img); } Or, if you use the getRequestParams method: /** * Only file */ $ext = $this->getRequestParams()->file('image')->getExtension(); $imgMain = 'IMG-'.uniqid().\".\".$ext; $this->getRequestParams()->file('image')->move(dirname(__DIR__).'/photos/'.$imgMain); /** * Multiple files */ foreach ($photo as $photo) { $ext = $photo->getExtension(); $img = 'IMG-'.uniqid().\".\".$ext; $photo->move(dirname(__DIR__).'/photos/'.$img); } Get all parameters In array: # Get all $values = input()->all(); # Only match specific keys $values = input()->all([ 'company_name', 'user_id' ]); In JSON: $values = input()->getAllJson(); All object implements the InputItemInterface interface and will always contain these methods: getIndex() - returns the index/key of the input. getName() - returns a human friendly name for the input (company_name will be Company Name etc). getValue() - returns the value of the input. InputFile has the same methods as above along with some other file-specific methods like: getFilename - get the filename. getTmpName() - get file temporary name. getSize() - get file size. move($destination) - move file to destination. getContents() - get file content. getType() - get mime-type for file. getError() - get file upload error. hasError() - returns bool if an error occurred while uploading (if getError is not 0). toArray() - returns raw array","title":"Input and params"},{"location":"input-and-params/#get-single-parameter-value","text":"# With Helper input($index, $defaultValue, ...$methods); # With method $this->getRequestParams($index, $defaultValue, ...$methods); To quickly get a value from a parameter, you can use the input helper function or the getRequestParams method. The getRequestParams method can only be used inside a Controller. This will automatically trim the value and ensure that it's not empty. If it's empty the $defaultValue will be returned instead. Note: This function returns a string unless the parameters are grouped together, in that case it will return an array of values. Example: This example matches both POST and GET request-methods and if name is empty the default-value \"Guest\" will be returned. #With helper $name = input('name', 'Guest', 'post', 'get'); # With method $name = $this->getRequestParams('name', 'Guest', 'post', 'get');","title":"Get single parameter value"},{"location":"input-and-params/#get-parameter-object","text":"When dealing with file-uploads it can be useful to retrieve the raw parameter object. Search for object with default-value across multiple or specific request-methods: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. #With Helper $object = input()->find($index, $defaultValue = null, ...$methods); # With method $object = $this->getRequestParams()->find($index, $defaultValue = null, ...$methods); Getting specific $_GET parameter as InputItem object: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. # With Helper $object = input()->get($index, $defaultValue = null); # With method $object = $this->getRequestParams()->get($index, $defaultValue = null); Getting specific $_POST parameter as InputItem object: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. # With Helper $object = input()->post($index, $defaultValue = null); # With method $object = $this->getRequestParams()->post($index, $defaultValue = null); Getting specific $_FILE parameter as InputFile object: The example below will return an InputFile object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputFile objects. # With Helper $object = input()->file($index, $defaultValue = null); # With method $object = $this->getRequestParams()->file($index, $defaultValue = null);","title":"Get parameter object"},{"location":"input-and-params/#managing-files","text":"Below you will find some code to help you upload files in a quick way. /** * From a form on the page like this * <input type=\"file\" name=\"images\" /> * * Only file */ $ext = input()->file('image')->getExtension(); $imgMain = 'IMG-'.uniqid().\".\".$ext; input()->file('image')->move(dirname(__DIR__).'/photos/'.$imgMain); /** * Loop through a collection of files uploaded from a form on the page like this * <input type=\"file\" name=\"images[]\" multiple /> * * Multiple files */ foreach ($photo as $photo) { $ext = $photo->getExtension(); $img = 'IMG-'.uniqid().\".\".$ext; $photo->move(dirname(__DIR__).'/photos/'.$img); } Or, if you use the getRequestParams method: /** * Only file */ $ext = $this->getRequestParams()->file('image')->getExtension(); $imgMain = 'IMG-'.uniqid().\".\".$ext; $this->getRequestParams()->file('image')->move(dirname(__DIR__).'/photos/'.$imgMain); /** * Multiple files */ foreach ($photo as $photo) { $ext = $photo->getExtension(); $img = 'IMG-'.uniqid().\".\".$ext; $photo->move(dirname(__DIR__).'/photos/'.$img); }","title":"Managing files"},{"location":"input-and-params/#get-all-parameters","text":"In array: # Get all $values = input()->all(); # Only match specific keys $values = input()->all([ 'company_name', 'user_id' ]); In JSON: $values = input()->getAllJson(); All object implements the InputItemInterface interface and will always contain these methods: getIndex() - returns the index/key of the input. getName() - returns a human friendly name for the input (company_name will be Company Name etc). getValue() - returns the value of the input. InputFile has the same methods as above along with some other file-specific methods like: getFilename - get the filename. getTmpName() - get file temporary name. getSize() - get file size. move($destination) - move file to destination. getContents() - get file content. getType() - get mime-type for file. getError() - get file upload error. hasError() - returns bool if an error occurred while uploading (if getError is not 0). toArray() - returns raw array","title":"Get all parameters"},{"location":"installation/","text":"Installing via Composer To download Solital, use the command below: composer create-project solital/solital project It only takes a few lines of code to get started: Course::get('/', function() { return 'Hello world'; }); Running To execute the project, use the built-in PHP server or create a virtual host: php -S localhost:8000 -t public/","title":"Installing"},{"location":"installation/#installing-via-composer","text":"To download Solital, use the command below: composer create-project solital/solital project It only takes a few lines of code to get started: Course::get('/', function() { return 'Hello world'; });","title":"Installing via Composer"},{"location":"installation/#running","text":"To execute the project, use the built-in PHP server or create a virtual host: php -S localhost:8000 -t public/","title":"Running"},{"location":"json/","text":"You can manipulate JSON using the JSON class or using the helpers encodeJSON and decodeJSON . The difference of this class for json_encode and json_decode is that you can automatically view errors when encoding/decoding a JSON, in addition to looking for a value within a JSON and reading external files. There are two ways to use this class, using the helpers mentioned above, or by instantiating the JSON class. # Instantiating the JSON class use Solital\\Core\\Resource\\JSON; $json = new JSON(); # Using the helpers encodeJSON and decodeJSON encodeJSON($json); decodeJSON($json); Predefined Constants By default, the JSON_UNESCAPED_UNICODE constant is defined in the constructor of the JSON class or the helper encodeJSON . It is possible to add more than one constant following the model below: # Class $json = new JSON(JSON_HEX_TAG | JSON_HEX_AMP | JSON_UNESCAPED_UNICODE); # Helper encodeJSON($json, JSON_HEX_TAG | JSON_HEX_AMP | JSON_UNESCAPED_UNICODE); Encode JSON The encode method creates a JSON from an array, or use the encodeJSON helper. $array = [\"name\" => \"Adith\u00fda\", \"age\" => 20]; # Class $json = new JSON(); $res = $json->encode($array); # Helper $res = encodeJSON($array); /* Return JSON */ pre($res); Decode JSON The decode method decodes JSON into an object or array. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; # Class $json = new JSON(); $res = $json->decode($json_file); # Helper $res = decodeJSON($json_file); /* Return object */ pre($res); To return an associative array, use true in the second parameter. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; # Class $json = new JSON(); $res = $json->decode($json_file, true); # Helper $res = decodeJSON($json_file, true); /* Return array */ pre($res); Returning a value in JSON If you need to read a value from the JSON file, use the inJson method. Inform JSON in the first parameter and the name of the key that contains the value in the second parameter. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; $json = new JSON(); $res = $json->inJson($json , 'Organization'); /* Return string */ pre($res); Read an external JSON file If you want to read an external file, use readFile . This method works in a similar way to the decode method. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; $json = new JSON(); $res = $json->readFile('data.json'); /* Return object */ pre($res); Returning in array $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; $json = new JSON(); $res = $json->readFile('data.json', true); /* Return array */ pre($res); Returning errors A JSON containing the type of error is returned whenever there is a failure to code or decode a JSON. Below is an example of how it is returned: { \"json_error\": \"Syntax error, malformed JSON\" } Enabling Exceptions To enable exceptions in case there is a Json reading error, change the value of the json_exception key to true . You can find this key in the bootstrap.yaml configuration file. json_exception: true","title":"JSON"},{"location":"json/#predefined-constants","text":"By default, the JSON_UNESCAPED_UNICODE constant is defined in the constructor of the JSON class or the helper encodeJSON . It is possible to add more than one constant following the model below: # Class $json = new JSON(JSON_HEX_TAG | JSON_HEX_AMP | JSON_UNESCAPED_UNICODE); # Helper encodeJSON($json, JSON_HEX_TAG | JSON_HEX_AMP | JSON_UNESCAPED_UNICODE);","title":"Predefined Constants"},{"location":"json/#encode-json","text":"The encode method creates a JSON from an array, or use the encodeJSON helper. $array = [\"name\" => \"Adith\u00fda\", \"age\" => 20]; # Class $json = new JSON(); $res = $json->encode($array); # Helper $res = encodeJSON($array); /* Return JSON */ pre($res);","title":"Encode JSON"},{"location":"json/#decode-json","text":"The decode method decodes JSON into an object or array. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; # Class $json = new JSON(); $res = $json->decode($json_file); # Helper $res = decodeJSON($json_file); /* Return object */ pre($res); To return an associative array, use true in the second parameter. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; # Class $json = new JSON(); $res = $json->decode($json_file, true); # Helper $res = decodeJSON($json_file, true); /* Return array */ pre($res);","title":"Decode JSON"},{"location":"json/#returning-a-value-in-json","text":"If you need to read a value from the JSON file, use the inJson method. Inform JSON in the first parameter and the name of the key that contains the value in the second parameter. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; $json = new JSON(); $res = $json->inJson($json , 'Organization'); /* Return string */ pre($res);","title":"Returning a value in JSON"},{"location":"json/#read-an-external-json-file","text":"If you want to read an external file, use readFile . This method works in a similar way to the decode method. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; $json = new JSON(); $res = $json->readFile('data.json'); /* Return object */ pre($res); Returning in array $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; $json = new JSON(); $res = $json->readFile('data.json', true); /* Return array */ pre($res);","title":"Read an external JSON file"},{"location":"json/#returning-errors","text":"A JSON containing the type of error is returned whenever there is a failure to code or decode a JSON. Below is an example of how it is returned: { \"json_error\": \"Syntax error, malformed JSON\" }","title":"Returning errors"},{"location":"json/#enabling-exceptions","text":"To enable exceptions in case there is a Json reading error, change the value of the json_exception key to true . You can find this key in the bootstrap.yaml configuration file. json_exception: true","title":"Enabling Exceptions"},{"location":"katrina-orm/","text":"Version Katrina ORM is currently at version 2.x . To read documentation for previous versions choose one of the links below. 1.x Getting Started Katrina ORM is a component that brings the object-oriented application development paradigm closer to the relational database paradigm. It helps to carry out common routines, such as the famous CRUD (create, read, edit and delete), in addition to having a data paging system. Katrina ORM uses the Active Record standard to manipulate the data in the database. Requirements PHP >= 8.0 PDO extension enabled Installation Katrina ORM is already installed by default in Solital. But if you are going to install in another project, use the command below to download via Composer. composer require solital/katrina Settings In Solital: # DATABASE CONFIG DB_DRIVE=\"your_drive\" DB_HOST=\"your_host\" DB_NAME=\"your_database_name\" DB_USER=\"your_user\" DB_PASS=\"your_password\" In another project: define('DB_CONFIG', [ 'DRIVE' => 'your_drive', 'HOST' => 'your_host', 'DBNAME' => 'your_database_name', 'USER' => 'your_user', 'PASS' => 'your_password' ]); For SQLite Some differences exist for connecting to an SQLite database. First, add an additional index called SQLITE_DIR in the DB_CONFIG constant. This constant must have the absolute path where the SQLite database file will be located. Then, assign the value sqlite in the index DRIVE . define('DB_CONFIG', [ 'DRIVE' => 'sqlite', 'DBNAME' => 'your_database_name.db', 'SQLITE_DIR' => '/path/to/file/' ]); In Solital: # DATABASE CONFIG DB_DRIVE=\"your_drive\" DB_HOST=\"your_host\" DB_NAME=\"your_database_name\" DB_USER=\"your_user\" DB_PASS=\"your_password\" SQLITE_DIR=\"/path/to/file/\" Initial structure To initialize the Katrina ORM in your Model, just extend the Katrina class. <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { } Changing default fields By default, your class table name is the class name itself, and the primary key name is id . You can change these settings using the $table and $id variables. <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { /** * @var null|string */ protected ?string $table = \"tb_user\"; /** * @var null|string */ protected ?string $id = \"id_user\"; /** * @var null|bool */ protected bool $timestamp = false; } SELECT To list all fields in the table, use all() as shown in the previous example. User::all(); To list a single value, use find() method; User::find(2); Or, use the select method: /** * Fetch all */ User::select()->get(); /** * Fetch only */ User::select()->where('id', 2)->getUnique(); /** * Fetch all with column name */ User::select(\"name\")->get(); WHERE If you need the WHERE clause, use where() method. /** * Katrina will look for a record that has `foo` in the table. */ User::select()->where(\"name\", \"foo\")->get(); /** * Katrina will look for a record whose age is greater than 10. */ User::select()->where(\"age\", 10, \">\")->get(); /** * Katrina will look for a record that is under the age of 10. */ User::select()->where(\"age\", 10, \"<\")->get(); AND/OR If there are more conditions for the where method, you can make use of the and/or methods: /** * With AND clause */ User::select()->where(\"brand\", 'visa')->and(\"cvv\", '502')->get(); /** * With OR clause */ User::select()->where(\"brand\", 'visa')->or(\"cvv\", '502')->get(); LIKE and BETWEEN You can combine the where method with other search methods such as like and between . /** * With LIKE clause */ User::select()->where(\"name\")->like(\"%foo%\")->get(); /** * With BETWEEN clause */ User::select()->where(\"age\")->between(10, 22)->get(); LIMIT User::select()->limit(0, 3)->get(); ORDER BY User::select()->order(\"name\")->get(); By default, the result will always return ascending. To return values descending, use false in the second parameter. User::select()->order(\"name\", false)->get(); GROUP BY The group by SQL command requires the use of a function. Use the group() method together with the Functions class (see here ). User::select(null, \"name, \" . Functions::count('*', 'qtd'))->group(\"name\")->get(); Using INNER JOIN The innerJoin() method returns the values of two tables that have a foreign key. The first parameter represents the table containing the foreign key. The second parameter represents the id of the foreign key. User::select() ->innerJoin(\"table1\", \"id1\") ->innerJoin(\"table2\", \"id2\") ->get(); If you need to use the WHERE clause, use the where() method. User::select() ->innerJoin(\"table1\", \"id1\") ->innerJoin(\"table2\", \"id2\") ->where(\"phone\", 123123123) ->get(); NOTE: If you have two or more tables where the column names are the same, remember to specify the table names in the where() method: User::select() ->innerJoin(\"table1\", \"id1\") ->innerJoin(\"table2\", \"id2\") ->where(\"table1.phone\", 123123123) ->get(); Custom SELECT You can create a custom SELECT statement. To do this, use the function customQuery . /** * Fetch Only */ User::customQuery(\"SELECT * FROM users\"); /** * Fetch All */ User::customQuery(\"SELECT * FROM users\", true); SELECT inside SELECT Some SQL queries need to have multiple SELECTs, and sometimes those SELECTs are inside other SELECTs. If you need such a query, follow the example: $sql = ORMTest::select(null, \"nome\")->where(\"nome\", \"brenno\")->rawQuery(); $result = ORMTest::select(null, \"nome, idade\")->where(\"nome\", Functions::subquery($sql))->get(); var_dump($result); The rawQuery() function will return an SQL string (you can use a var_dump() to parse the returned string). Then, to use that SQL string inside another query, use the subquery() function. Functions Katrina 2 supports SQL functions. You can use a function in an SQL query using the Function Method: use Katrina\\Functions\\Functions; User::select(null, \"name, \" . Functions::count('*', 'qtd'))->group(\"name\")->get(); Below is a list of all the functions present in Katrina ORM: Aggregate Functions Date Functions Math Functions avg($value) now() abs($value) count($expression = \"*\", $as = \"\") curdate() sum($value) max($value) date($value) truncate($number, $decimal_places) - hour($value) - - month($value) - - datediff($first_date, $second_date) - - day($date = null) - - currentTimestamp() - INSERT Katrina uses the ActiveRecord standard to insert and update database data. However, if you don't want to use the ActiveRecord pattern, you can use the insert() and update() methods. With ActiveRecord To insert data in the table, you must use the column name as a value. If your table has name , age and email columns, then the values should be used following that same sequence. Note the code below: $user = new User(); $user->name = \"Harvey Specter\"; $user->age = 40; $user->email = \"harvey@pearsonspecterlitt.com\"; $user->save(); With the insert method To save data, you must pass an array in which the keys will be the columns of the table. The values of these keys will be inserted into the database. User::insert([ 'name' => 'Harvey Specter', 'age' => 40, 'email' => 'harvey@pearsonspecterlitt.com' ]); If you want to retrieve the last ID entered, use the lastId() method. $res = User::insert([ 'name' => 'Harvey Specter', 'age' => 40, 'email' => 'harvey@pearsonspecterlitt.com' ])->lastId(); var_dump($res); UPDATE With ActiveRecord The process for updating a record in the table is very similar to inserting a record. However, you need to specify the id of your table: $user = new User(); $user->id = 1; $user->name = \"Harvey Specter\"; $user->age = 42; $user->email = \"harvey@specterlitt.com\"; $user->save(); With the update method The process for updating a value in the database using the update method is similar to using the insert method. The difference is that you will use the where method to define the values that will be updated. And to save those changes, the saveUpdate method must be present. User::update([ 'name' => 'Harvey Specter', 'age' => 42, 'email' => 'harvey@specterlitt.com' ])->where('id', 1)->saveUpdate(); Delete To delete a record from the table, use the delete() method. User::delete('id', 2); If you want to delete a row that has a foreign key in another table, the $safe_mode parameter must be changed to false : User::delete('id', 2, false); Manipulating tables Create a new table The createTable() method starts opening the table. After inserting the fields and data types that the tables will have, use closeTable() to close the table. For a better understanding see the syntax below. User::createTable(\"your_table_name\") /* Fields and table type */ ->int(\"id_user\")->primary()->increment() ->varchar(\"name\", 20)->unique()->notNull()->default(\"specter\") ->int(\"age\", 3)->unsigned()->notNull() ->varchar(\"email\", 30)->default(\"harvey.specter@gmail.com\")->notNull() ->varchar(\"profession\", 40) ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") /* Close the command to create the table */ ->closeTable(); For POSTGRESQL Postgresql doesn't natively support the AUTO_INCREMENT command. An alternative is to use the SERIAL command. So, if you are going to create a table using Postgresql as a database, use the serial() method. User::createTable(\"your_table_name\") ->serial('id_user')->primary() # ... List tables To have a list of all the tables in your database, use the listTables() method. User::listTables(); List columns To list the columns of a table, use the describeTable() method passing as a parameter the name of your table. User::describeTable('your_table'); Alter table The alter() method performs the procedures of adding, changing and deleting a field from the database table. Add new field Use add() method together with the data type to add a new field. (new User)->alter(\"your_table\")->varchar(\"username\", 20)->add(); Drop column Use the drop() method to delete a column from the table. (new User)->alter(\"your_table\")->drop(\"username\"); Modify column Use the modify SQL with the modify() method. (new User)->alter(\"your_table\")->varchar(\"name\", 100)->modify(); Rename table Use the rename() method to rename a database table. (new User)->alter(\"your_table_name\")->rename(\"new_table_name\"); Adding foreign key To add a foreign key to an already created table, use the constraint() method to add a constraint; foreign() to inform the column and references() to refer to the table. (new User)->alter(\"your_table\")->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\"); Truncate table To use the sql truncate command, use the truncate() method. (new User)->truncate(\"your_table\"); By default, the database checks the table's foreign key and locks the truncate command. To disable foreign key verification, enter true as a parameter. (new User)->truncate(\"your_table\", true); Procedure To call a database procedure, use the call() method. (new User)->call('procedure_name'); To use procedure parameters, pass the values in array format. (new User)->call('procedure_name' , ['param_1, param_2, param_3']); Transactions Transactions are typically implemented by \"saving-up\" your batch of changes to be applied all at once; this has the nice side effect of drastically improving the efficiency of those updates. In other words, transactions can make your scripts faster and potentially more robust (you still need to use them correctly to reap that benefit). try { $pdo = Connection::getInstance(); $pdo->beginTransaction(); // code... $pdo->commit(); } catch (\\PDOException $e) { $pdo->rollback(); echo $e->getMessage(); } Pagination The pagination() method creates a system for paging results. To initialize, the first parameter must be the table you want to use to start paging. The second parameter will list the amount of values that will be returned from the table as shown in the example below. $values = (new User)->pagination('your_table', 3); To retrieve the table values from the database, you can use the getRows() method. And to use pagination, use the getArrows() method. /** Returns table data */ $values->getRows(); /** Returns commands to advance or return */ $values->getArrows() To use pagination with relationship in another table, in the third parameter pass an array containing the name of the table that has a relationship with the current table, the column name of the current table that has the foreign key and the column name of the primary key of the another table. $values = (new User)->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key']); INNER JOIN If you want to use pagination with a table that has a foreign key, pass an array in the third parameter. In the first index, insert the name of the table that is linked to the current table, in the second index the name of the column that contains the foreign key and in the third index the column name of the primary key of the table that references the current table $values = (new User)->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key'], \"status=true\"); WHERE clause To use the WHERE clause, use the fourth parameter as shown below. $values = (new User)->pagination('your_table', 3, null, \"status=true\"); Transactions Wolf Template Data pagination is widely used in project templates. You can integrate pagination into Wolf Template as follows: $values = (new User)->pagination('your_table', 3); return view('home', [ 'values' => $values ]); In your template, retrieve the data like this: <table> <thead> <tr> <th>Name</th> <th>Age</th> <th>Gender</th> </tr> </thead> <tbody> {% foreach ($values->getRows() as $result): %} <tr> <td>{{ $result['name'] }}</td> <td>{{ $result['age'] }}</td> <td>{{ $result['gender'] }}</td> </tr> {% endforeach; %} </tbody> </table> {{ $values->getArrows(); }} The result will be as follows: Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female << 1 2 3 >> To change the arrows ( << and >> ), use the parameters of the getArrows() method. The result will be: {{ $values->getArrows('First', 'Last'); }} Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female First 2 3 Last Custom Pagination The pagination() method uses a basic SELECT statement. If you need to use a much more complex SELECT, consider using the customPagination() method. $values = (new User)->customPagination(\"SELECT created_at, order_status, idSession, SUM(idOrder) AS idOrder FROM `tb_order` GROUP BY created_at, order_status, idSession\", 3); Customizing arrows CSS You can customize the look of the arrows through the classes pagination_first_item , pagination_atual_item , pagination_others_itens and pagination_last_item . Below is a customization to serve as an example: .pagination_atual_item { background-color: #B5B5B5; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item, .pagination_others_itens, .pagination_last_item { background-color: #4682B4; color: #FFF; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; text-decoration: none; } .pagination_first_item:hover, .pagination_others_itens:hover, .pagination_last_item:hover { background-color: #0071E3; color: #FFF !important; transition: 0.2s; } Types of data Below is listed the attributes and data supported by Katrina ORM: String data Numerical data Date and time varchar(\"column_name\", size) tinyint(\"column_name\", size) date(\"column_name\") char(\"column_name\", size) smallint(\"column_name\", size) year(\"column_name\") tinytext(\"column_name\", size) mediumint(\"column_name\", size) time(\"column_name\") mediumtext(\"column_name\", size) bigint(\"column_name\", size) datetime(\"column_name\") longtext(\"column_name\", size) int(\"column_name\", size) timestamp(\"column_name\") text(\"column_name\") decimal(\"column_name\", value1, value2) - Attributes Boolean boolean(\"column_name\") default(\"default_value\") unique() - unsigned() - incremet() (MYSQL) - notNull() - primary() - after(\"column_name\") - first() - serial(\"id_table\") (POSTGRESQL) -","title":"Katrina ORM"},{"location":"katrina-orm/#version","text":"Katrina ORM is currently at version 2.x . To read documentation for previous versions choose one of the links below. 1.x","title":"Version"},{"location":"katrina-orm/#getting-started","text":"Katrina ORM is a component that brings the object-oriented application development paradigm closer to the relational database paradigm. It helps to carry out common routines, such as the famous CRUD (create, read, edit and delete), in addition to having a data paging system. Katrina ORM uses the Active Record standard to manipulate the data in the database.","title":"Getting Started"},{"location":"katrina-orm/#requirements","text":"PHP >= 8.0 PDO extension enabled","title":"Requirements"},{"location":"katrina-orm/#installation","text":"Katrina ORM is already installed by default in Solital. But if you are going to install in another project, use the command below to download via Composer. composer require solital/katrina","title":"Installation"},{"location":"katrina-orm/#settings","text":"In Solital: # DATABASE CONFIG DB_DRIVE=\"your_drive\" DB_HOST=\"your_host\" DB_NAME=\"your_database_name\" DB_USER=\"your_user\" DB_PASS=\"your_password\" In another project: define('DB_CONFIG', [ 'DRIVE' => 'your_drive', 'HOST' => 'your_host', 'DBNAME' => 'your_database_name', 'USER' => 'your_user', 'PASS' => 'your_password' ]);","title":"Settings"},{"location":"katrina-orm/#for-sqlite","text":"Some differences exist for connecting to an SQLite database. First, add an additional index called SQLITE_DIR in the DB_CONFIG constant. This constant must have the absolute path where the SQLite database file will be located. Then, assign the value sqlite in the index DRIVE . define('DB_CONFIG', [ 'DRIVE' => 'sqlite', 'DBNAME' => 'your_database_name.db', 'SQLITE_DIR' => '/path/to/file/' ]); In Solital: # DATABASE CONFIG DB_DRIVE=\"your_drive\" DB_HOST=\"your_host\" DB_NAME=\"your_database_name\" DB_USER=\"your_user\" DB_PASS=\"your_password\" SQLITE_DIR=\"/path/to/file/\"","title":"For SQLite"},{"location":"katrina-orm/#initial-structure","text":"To initialize the Katrina ORM in your Model, just extend the Katrina class. <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { }","title":"Initial structure"},{"location":"katrina-orm/#changing-default-fields","text":"By default, your class table name is the class name itself, and the primary key name is id . You can change these settings using the $table and $id variables. <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { /** * @var null|string */ protected ?string $table = \"tb_user\"; /** * @var null|string */ protected ?string $id = \"id_user\"; /** * @var null|bool */ protected bool $timestamp = false; }","title":"Changing default fields"},{"location":"katrina-orm/#select","text":"To list all fields in the table, use all() as shown in the previous example. User::all(); To list a single value, use find() method; User::find(2); Or, use the select method: /** * Fetch all */ User::select()->get(); /** * Fetch only */ User::select()->where('id', 2)->getUnique(); /** * Fetch all with column name */ User::select(\"name\")->get(); WHERE If you need the WHERE clause, use where() method. /** * Katrina will look for a record that has `foo` in the table. */ User::select()->where(\"name\", \"foo\")->get(); /** * Katrina will look for a record whose age is greater than 10. */ User::select()->where(\"age\", 10, \">\")->get(); /** * Katrina will look for a record that is under the age of 10. */ User::select()->where(\"age\", 10, \"<\")->get(); AND/OR If there are more conditions for the where method, you can make use of the and/or methods: /** * With AND clause */ User::select()->where(\"brand\", 'visa')->and(\"cvv\", '502')->get(); /** * With OR clause */ User::select()->where(\"brand\", 'visa')->or(\"cvv\", '502')->get(); LIKE and BETWEEN You can combine the where method with other search methods such as like and between . /** * With LIKE clause */ User::select()->where(\"name\")->like(\"%foo%\")->get(); /** * With BETWEEN clause */ User::select()->where(\"age\")->between(10, 22)->get(); LIMIT User::select()->limit(0, 3)->get(); ORDER BY User::select()->order(\"name\")->get(); By default, the result will always return ascending. To return values descending, use false in the second parameter. User::select()->order(\"name\", false)->get(); GROUP BY The group by SQL command requires the use of a function. Use the group() method together with the Functions class (see here ). User::select(null, \"name, \" . Functions::count('*', 'qtd'))->group(\"name\")->get();","title":"SELECT"},{"location":"katrina-orm/#using-inner-join","text":"The innerJoin() method returns the values of two tables that have a foreign key. The first parameter represents the table containing the foreign key. The second parameter represents the id of the foreign key. User::select() ->innerJoin(\"table1\", \"id1\") ->innerJoin(\"table2\", \"id2\") ->get(); If you need to use the WHERE clause, use the where() method. User::select() ->innerJoin(\"table1\", \"id1\") ->innerJoin(\"table2\", \"id2\") ->where(\"phone\", 123123123) ->get(); NOTE: If you have two or more tables where the column names are the same, remember to specify the table names in the where() method: User::select() ->innerJoin(\"table1\", \"id1\") ->innerJoin(\"table2\", \"id2\") ->where(\"table1.phone\", 123123123) ->get();","title":"Using INNER JOIN"},{"location":"katrina-orm/#custom-select","text":"You can create a custom SELECT statement. To do this, use the function customQuery . /** * Fetch Only */ User::customQuery(\"SELECT * FROM users\"); /** * Fetch All */ User::customQuery(\"SELECT * FROM users\", true);","title":"Custom SELECT"},{"location":"katrina-orm/#select-inside-select","text":"Some SQL queries need to have multiple SELECTs, and sometimes those SELECTs are inside other SELECTs. If you need such a query, follow the example: $sql = ORMTest::select(null, \"nome\")->where(\"nome\", \"brenno\")->rawQuery(); $result = ORMTest::select(null, \"nome, idade\")->where(\"nome\", Functions::subquery($sql))->get(); var_dump($result); The rawQuery() function will return an SQL string (you can use a var_dump() to parse the returned string). Then, to use that SQL string inside another query, use the subquery() function.","title":"SELECT inside SELECT"},{"location":"katrina-orm/#functions","text":"Katrina 2 supports SQL functions. You can use a function in an SQL query using the Function Method: use Katrina\\Functions\\Functions; User::select(null, \"name, \" . Functions::count('*', 'qtd'))->group(\"name\")->get(); Below is a list of all the functions present in Katrina ORM: Aggregate Functions Date Functions Math Functions avg($value) now() abs($value) count($expression = \"*\", $as = \"\") curdate() sum($value) max($value) date($value) truncate($number, $decimal_places) - hour($value) - - month($value) - - datediff($first_date, $second_date) - - day($date = null) - - currentTimestamp() -","title":"Functions"},{"location":"katrina-orm/#insert","text":"Katrina uses the ActiveRecord standard to insert and update database data. However, if you don't want to use the ActiveRecord pattern, you can use the insert() and update() methods. With ActiveRecord To insert data in the table, you must use the column name as a value. If your table has name , age and email columns, then the values should be used following that same sequence. Note the code below: $user = new User(); $user->name = \"Harvey Specter\"; $user->age = 40; $user->email = \"harvey@pearsonspecterlitt.com\"; $user->save(); With the insert method To save data, you must pass an array in which the keys will be the columns of the table. The values of these keys will be inserted into the database. User::insert([ 'name' => 'Harvey Specter', 'age' => 40, 'email' => 'harvey@pearsonspecterlitt.com' ]); If you want to retrieve the last ID entered, use the lastId() method. $res = User::insert([ 'name' => 'Harvey Specter', 'age' => 40, 'email' => 'harvey@pearsonspecterlitt.com' ])->lastId(); var_dump($res);","title":"INSERT"},{"location":"katrina-orm/#update","text":"With ActiveRecord The process for updating a record in the table is very similar to inserting a record. However, you need to specify the id of your table: $user = new User(); $user->id = 1; $user->name = \"Harvey Specter\"; $user->age = 42; $user->email = \"harvey@specterlitt.com\"; $user->save(); With the update method The process for updating a value in the database using the update method is similar to using the insert method. The difference is that you will use the where method to define the values that will be updated. And to save those changes, the saveUpdate method must be present. User::update([ 'name' => 'Harvey Specter', 'age' => 42, 'email' => 'harvey@specterlitt.com' ])->where('id', 1)->saveUpdate();","title":"UPDATE"},{"location":"katrina-orm/#delete","text":"To delete a record from the table, use the delete() method. User::delete('id', 2); If you want to delete a row that has a foreign key in another table, the $safe_mode parameter must be changed to false : User::delete('id', 2, false);","title":"Delete"},{"location":"katrina-orm/#manipulating-tables","text":"","title":"Manipulating tables"},{"location":"katrina-orm/#create-a-new-table","text":"The createTable() method starts opening the table. After inserting the fields and data types that the tables will have, use closeTable() to close the table. For a better understanding see the syntax below. User::createTable(\"your_table_name\") /* Fields and table type */ ->int(\"id_user\")->primary()->increment() ->varchar(\"name\", 20)->unique()->notNull()->default(\"specter\") ->int(\"age\", 3)->unsigned()->notNull() ->varchar(\"email\", 30)->default(\"harvey.specter@gmail.com\")->notNull() ->varchar(\"profession\", 40) ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") /* Close the command to create the table */ ->closeTable(); For POSTGRESQL Postgresql doesn't natively support the AUTO_INCREMENT command. An alternative is to use the SERIAL command. So, if you are going to create a table using Postgresql as a database, use the serial() method. User::createTable(\"your_table_name\") ->serial('id_user')->primary() # ...","title":"Create a new table"},{"location":"katrina-orm/#list-tables","text":"To have a list of all the tables in your database, use the listTables() method. User::listTables();","title":"List tables"},{"location":"katrina-orm/#list-columns","text":"To list the columns of a table, use the describeTable() method passing as a parameter the name of your table. User::describeTable('your_table');","title":"List columns"},{"location":"katrina-orm/#alter-table","text":"The alter() method performs the procedures of adding, changing and deleting a field from the database table. Add new field Use add() method together with the data type to add a new field. (new User)->alter(\"your_table\")->varchar(\"username\", 20)->add(); Drop column Use the drop() method to delete a column from the table. (new User)->alter(\"your_table\")->drop(\"username\"); Modify column Use the modify SQL with the modify() method. (new User)->alter(\"your_table\")->varchar(\"name\", 100)->modify(); Rename table Use the rename() method to rename a database table. (new User)->alter(\"your_table_name\")->rename(\"new_table_name\");","title":"Alter table"},{"location":"katrina-orm/#adding-foreign-key","text":"To add a foreign key to an already created table, use the constraint() method to add a constraint; foreign() to inform the column and references() to refer to the table. (new User)->alter(\"your_table\")->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\");","title":"Adding foreign key"},{"location":"katrina-orm/#truncate-table","text":"To use the sql truncate command, use the truncate() method. (new User)->truncate(\"your_table\"); By default, the database checks the table's foreign key and locks the truncate command. To disable foreign key verification, enter true as a parameter. (new User)->truncate(\"your_table\", true);","title":"Truncate table"},{"location":"katrina-orm/#procedure","text":"To call a database procedure, use the call() method. (new User)->call('procedure_name'); To use procedure parameters, pass the values in array format. (new User)->call('procedure_name' , ['param_1, param_2, param_3']);","title":"Procedure"},{"location":"katrina-orm/#transactions","text":"Transactions are typically implemented by \"saving-up\" your batch of changes to be applied all at once; this has the nice side effect of drastically improving the efficiency of those updates. In other words, transactions can make your scripts faster and potentially more robust (you still need to use them correctly to reap that benefit). try { $pdo = Connection::getInstance(); $pdo->beginTransaction(); // code... $pdo->commit(); } catch (\\PDOException $e) { $pdo->rollback(); echo $e->getMessage(); }","title":"Transactions"},{"location":"katrina-orm/#pagination","text":"The pagination() method creates a system for paging results. To initialize, the first parameter must be the table you want to use to start paging. The second parameter will list the amount of values that will be returned from the table as shown in the example below. $values = (new User)->pagination('your_table', 3); To retrieve the table values from the database, you can use the getRows() method. And to use pagination, use the getArrows() method. /** Returns table data */ $values->getRows(); /** Returns commands to advance or return */ $values->getArrows() To use pagination with relationship in another table, in the third parameter pass an array containing the name of the table that has a relationship with the current table, the column name of the current table that has the foreign key and the column name of the primary key of the another table. $values = (new User)->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key']); INNER JOIN If you want to use pagination with a table that has a foreign key, pass an array in the third parameter. In the first index, insert the name of the table that is linked to the current table, in the second index the name of the column that contains the foreign key and in the third index the column name of the primary key of the table that references the current table $values = (new User)->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key'], \"status=true\"); WHERE clause To use the WHERE clause, use the fourth parameter as shown below. $values = (new User)->pagination('your_table', 3, null, \"status=true\"); Transactions Wolf Template Data pagination is widely used in project templates. You can integrate pagination into Wolf Template as follows: $values = (new User)->pagination('your_table', 3); return view('home', [ 'values' => $values ]); In your template, retrieve the data like this: <table> <thead> <tr> <th>Name</th> <th>Age</th> <th>Gender</th> </tr> </thead> <tbody> {% foreach ($values->getRows() as $result): %} <tr> <td>{{ $result['name'] }}</td> <td>{{ $result['age'] }}</td> <td>{{ $result['gender'] }}</td> </tr> {% endforeach; %} </tbody> </table> {{ $values->getArrows(); }} The result will be as follows: Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female << 1 2 3 >> To change the arrows ( << and >> ), use the parameters of the getArrows() method. The result will be: {{ $values->getArrows('First', 'Last'); }} Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female First 2 3 Last","title":"Pagination"},{"location":"katrina-orm/#custom-pagination","text":"The pagination() method uses a basic SELECT statement. If you need to use a much more complex SELECT, consider using the customPagination() method. $values = (new User)->customPagination(\"SELECT created_at, order_status, idSession, SUM(idOrder) AS idOrder FROM `tb_order` GROUP BY created_at, order_status, idSession\", 3); Customizing arrows CSS You can customize the look of the arrows through the classes pagination_first_item , pagination_atual_item , pagination_others_itens and pagination_last_item . Below is a customization to serve as an example: .pagination_atual_item { background-color: #B5B5B5; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item, .pagination_others_itens, .pagination_last_item { background-color: #4682B4; color: #FFF; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; text-decoration: none; } .pagination_first_item:hover, .pagination_others_itens:hover, .pagination_last_item:hover { background-color: #0071E3; color: #FFF !important; transition: 0.2s; }","title":"Custom Pagination"},{"location":"katrina-orm/#types-of-data","text":"Below is listed the attributes and data supported by Katrina ORM: String data Numerical data Date and time varchar(\"column_name\", size) tinyint(\"column_name\", size) date(\"column_name\") char(\"column_name\", size) smallint(\"column_name\", size) year(\"column_name\") tinytext(\"column_name\", size) mediumint(\"column_name\", size) time(\"column_name\") mediumtext(\"column_name\", size) bigint(\"column_name\", size) datetime(\"column_name\") longtext(\"column_name\", size) int(\"column_name\", size) timestamp(\"column_name\") text(\"column_name\") decimal(\"column_name\", value1, value2) - Attributes Boolean boolean(\"column_name\") default(\"default_value\") unique() - unsigned() - incremet() (MYSQL) - notNull() - primary() - after(\"column_name\") - first() - serial(\"id_table\") (POSTGRESQL) -","title":"Types of data"},{"location":"katrina1/","text":"Getting Started Katrina ORM is a component to bring the object-oriented application development paradigm closer to the relational database paradigm. It helps when carrying out common routines, such as the famous CRUD (create, read, edit and delete), in addition to having a login and data paging system. Requirements PHP >= 7.2 (Compatible with PHP 8) PHP PDO extension enabled Installation Katrina ORM is already installed by default in Solital. But if you are going to install in another project, use the command below to download via Composer. composer require solital/katrina Settings In Solital: # DATABASE CONFIG DB_DRIVE=\"your_drive\" DB_HOST=\"your_host\" DB_NAME=\"your_database_name\" DB_USER=\"your_user\" DB_PASS=\"your_password\" In another project: define('DB_CONFIG', [ 'DRIVE' => 'your_drive', 'HOST' => 'your_host', 'DBNAME' => 'your_database_name', 'USER' => 'your_user', 'PASS' => 'your_password' ]); For SQLite Some differences exist for connecting to an SQLite database. First, add an additional index called SQLITE_DIR in the DB_CONFIG constant. This constant must have the absolute path where the SQLite database file will be located. Then, assign the value sqlite in the index DRIVE . define('DB_CONFIG', [ 'DRIVE' => 'sqlite', 'DBNAME' => 'your_database_name.db', 'SQLITE_DIR' => '/path/to/file/' ]); In Solital: # DATABASE CONFIG DB_DRIVE=\"your_drive\" DB_HOST=\"your_host\" DB_NAME=\"your_database_name\" DB_USER=\"your_user\" DB_PASS=\"your_password\" SQLITE_DIR=\"/path/to/file/\" Initial structure You can use katrina in two ways: 1\u00b0) In Solital, extend the model already created and define the variables $table , $primaryKey and $columns in your model's constructor as listed below: <?php namespace Solital\\Components\\Model; use Solital\\Components\\Model\\Model; class User extends Model { public function __construct() { $this->table = 'your_database_table'; $this->primaryKey = 'primary_key_of_the_table'; $this->columns = [ 'first_column_of_the_table', 'second column of the table', #... ]; } public function get() { return $this->instance()->select()->build(\"ALL\"); } } 2\u00b0) Or if you are using it in another project <?php use Katrina\\Katrina as Katrina; class User { # String private $table = 'your_database_table'; # String private $primaryKey = 'primary_key_of_the_table'; # Array private $columns = [ 'first_column_of_the_table', 'second column of the table', #... ]; public function instance() { $katrina = new Katrina($this->table, $this->columnPrimaryKey, $this->columns); return $katrina; } public function get() { return $this->instance()->select()->build(\"ALL\"); } } Data manipulation - CRUD List To list all fields in the table, use select() as shown in the previous example. By default, the method will list all fields in the table. public function get() { return $this->instance()->select()->build(\"ALL\"); } To list a single value, pass the table field id as a parameter, and in build() method use ONLY . public function get() { return $this->instance()->select(3)->build(\"ONLY\"); } To specify which fields you want to list, pass the values \u200b\u200bas parameters. public function get() { return $this->instance()->select(null, null, \"name, city, country\")->build(\"ALL\"); } WHERE If you need the WHERE clause, use the second parameter. public function get() { return $this->instance()->select(null, 'name=\"Clark\"', \"name, city, country\") ->build(\"ALL\"); } With primary key: public function get() { return $this->instance()->select(3, 'name=\"Clark\"', \"name, city, country\") ->build(\"ONLY\"); } LIMIT public function get() { return $this->instance()->select()->limit(2, 5)->build(\"ALL\"); } LIKE The LIKE operator must always be used with the WHERE . public function get() { return $this->instance()->select(null, \"name\")->like(\"%Harvey%\")->build(\"ALL\"); } ORDER BY public function get() { return $this->instance()->select()->order(\"name\")->build(\"ALL\"); } By default, the result will always return ascending. To return values descending, use false in the second parameter. public function get() { return $this->instance()->select()->order(\"name\", false)->build(\"ALL\"); } BETWEEN The BETWEEN operator must always be used with the WHERE . public function get() { return $this->instance()->select(null, \"age\")->between(18, 25)->build(\"ALL\"); } Listing foreign key The innerJoin() method returns the values of two tables that have a foreign key. The first parameter will be the name of the table that has a relationship with the current table. The second will be an array containing in the first index the column name of the current table that has the foreign key, and in the second index the column name of the primary key of the other table. To make it easier, see an example below. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"]) ->build(\"ALL\"); } If you need to use the WHERE clause, pass the command in the third parameter as shown below. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"], \"order_status=true\")->build(\"ALL\"); } You can inform which fields you want to return. \"a\" is your main table while \"b\" is your table that has the foreign key. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"], \"order_status=true\", \"a.idPerson, a.name, b.street\", \"address\", \"idAddress\")->build(\"ALL\"); } Custom SELECT You can create a custom SELECT statement. To do this, use the function customQueryOnly to return a single value from the database, and customQueryAll to return all values from the database. public function getAll() { return $this->instance()->customQueryAll(\"SELECT a.idSession, SUM(b.price) AS price, SUM(a.qtd) AS qtd FROM tb_order a INNER JOIN tb_product b WHERE MONTH( a.created_at) = MONTH(NOW()) GROUP BY a.idSession\"); } public function getOnly() { return $this->instance()->customQueryOnly(\"SELECT a.idSession, SUM(b.price) AS price, SUM(a.qtd) AS qtd FROM tb_order a INNER JOIN tb_product b WHERE MONTH( a.created_at) = MONTH(NOW()) GROUP BY a.idSession\"); } Insert The insert() method inserts the values \u200b\u200binto the table. It is NOT necessary to use build() method to insert the data. To do this, create an array with the values \u200b\u200bthat the method will receive /** * Return bool */ public function insert() { $res = $this->instance()->insert(['Clark', 'Metropolis', 'EUA']); return $res; } To return the last insert ID, pass a true in the second parameter. /** * Return array * * ['res'] => 'true', * ['lastId'] => '2' */ public function insert() { $res = $this->instance()->insert(['Clark', 'Metropolis', 'EUA'], true); return $res; } Update The update() method updates the values \u200b\u200bin the table. It is NOT necessary to use build() method to update the data. The process is similar to the insert method. The first parameter is the columns that will be updated, the second parameter the values \u200b\u200band the third the row id . You can use an integer or a string in the third parameter public function update() { $res = $this->instance()->update(['name', 'age'], ['Specter', '41'], \"id=3\"); return $res; } Or public function update() { $res = $this->instance()->update(['name', 'age'], ['Specter', '41'], 3); return $res; } Delete The delete() method deletes the values \u200b\u200bin the table. Enter the value of the line to be deleted, the value being the primary key. public function delete() { $res = $this->instance()->delete(3)->build(); return $res; } Or a string public function delete() { $res = $this->instance()->delete(\"Bruce\")->build(); return $res; } By default, the delete method uses the column name of the primary key to delete the row, but you can use the name of another column using the second parameter. public function delete() { $res = $this->instance()->delete(\"Bruce\", \"name\")->build(); return $res; } ** Force delete with foreign key ** In some cases there may be a need to delete a record with the foreign key from another table. To disable foreign key checking, you can use the third parameter as true . public function delete() { $res = $this->instance()->delete(3, null, true)->build(); return $res; } Manipulating tables Create a new table The createTable() method starts opening the table. After inserting the fields and data types that the tables will have, use closeTable() to close the table. For a better understanding see the syntax below. $res = $this->instance() /* Starts the table by specifying its name */ ->createTable(\"your_table_name\") /* Fields and table type */ ->int(\"id_orm\")->primary()->increment() ->varchar(\"name\", 20)->unique()->notNull()->default(\"specter\") ->int(\"age\", 3)->unsigned()->notNull() ->varchar(\"email\", 30)->default(\"harvey.specter@gmail.com\")->notNull() ->varchar(\"profession\", 40) ->int(\"tipo\") ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") /* Close the command to create the table */ ->closeTable() /* Compile the code above */ ->build(); List tables To have a list of all the tables in your database, use the listTables() method by passing ALL in the build() method. public function get() { $res = $this->instance()->listTables()->build(\"ALL\"); return $res; } List columns To list the columns of a table, use the describeTable() method passing as a parameter the name of your table together with ALL in the build() public function get() { $res = $this->instance()->describeTable(\"your_table\")->build(\"ALL\"); return $res; } Alter table The alter() method performs the procedures of adding, changing and deleting a field from the database table. Add new field Use add() method together with the data type to add a new field. public function get() { $res = $this->instance() ->alter(\"message\")->add() ->varchar(\"first_field\", 10) ->build(); } Drop column Use the drop() method to delete a column from the table. public function get() { $res = $this->instance() ->alter(\"message\")->drop(\"type\") ->build(); } Modify column Use the modify SQL with the modify() method. public function get() { $res = $this->instance() ->alter(\"message\")->modify() ->varchar(\"person_type\", 100) ->build(); } Change column Use the change() method to change a column. As a parameter, pass the current column name. public function get() { $res = $this->instance() ->alter(\"message\")->change(\"person_type\") ->varchar(\"type\", 100) ->build(); } Rename table Use the rename() method to rename a database table. Use the first parameter the current table name and the second parameter the new table name. public function get() { $res = $this->instance() ->rename(\"message\", \"new_message\") ->build(); } Adding foreign key To add a foreign key to an already created table, use the addConstraint() method to add a constraint; foreign() to inform the column and references() to refer to the table. public function get() { $res = $this->instance() ->alter(\"message\")->addConstraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") ->build(); } NOTE: if you are creating a new table, use the constraint() method instead of addConstraint() as shown below: #... ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") #... Drop table To delete a table from the database, use the dropTable() method. public function get() { $res = $this->instance() ->dropTable(\"message\") ->build(); } Truncate table To use the sql truncate command, use the truncate() method. public function get() { $res = $this->instance() ->truncate() ->build(); } By default, the database checks the table's foreign key and locks the truncate command. To disable foreign key verification, enter true as a parameter. public function get() { $res = $this->instance() ->truncate(true) ->build(); } Procedure To call a database procedure, use the call() method. public function get() { $res = $this->instance()->call('procedure_name'); return $res; } To use procedure parameters, pass the values in array format. public function get() { $res = $this->instance()->call('procedure_name' , ['param_1, param_2, param_3']); return $res; } Pagination The pagination() method creates a system for paging results. To initialize, the first parameter must be the table you want to use to start paging. The second parameter will list the amount of values that will be returned from the table as shown in the example below. public function get() { $res = $this->instance()->pagination('your_table', 3); return $res; } The above method will return an array containing rows indexes that will return values, and arrows that will return commands for pagination. To use pagination with relationship in another table, in the third parameter pass an array containing the name of the table that has a relationship with the current table, the column name of the current table that has the foreign key and the column name of the primary key of the another table. public function get() { $res = $this->instance()->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key']); return $res; } INNER JOIN If you want to use pagination with a table that has a foreign key, pass an array in the third parameter. In the first index, insert the name of the table that is linked to the current table, in the second index the name of the column that contains the foreign key and in the third index the column name of the primary key of the table that references the current table public function get() { $res = $this->instance()->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key'], \"status=true\"); return $res; } WHERE clause To use the WHERE clause, use the fourth parameter as shown below. public function get() { $res = $this->instance()->pagination('your_table', 3, null, \"status=true\"); return $res; } Wolf Templte To use in the Wolf template, use it this way. $html = $this->instance()->pagination('your_table', 3); Wolf::loadView('home', [ 'rows' => $html['rows'], 'arrows' => $html['arrows'] ]); And in your view, return the results that way. <table> <thead> <tr> <th>Name</th> <th>Age</th> <th>Gender</th> </tr> </thead> <tbody> <?php foreach ($rows as $r): ?> <tr> <td><?= $r['name'] ?></td> <td><?= $r['age'] ?></td> <td><?= $r['gender'] ?></td> </tr> <?php endforeach; ?> </tbody> </table> <?php echo $arrows; The result will be as follows: Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female << 1 2 3 >> To change the arrows ( << and >> ), use the last two parameters of the pagination() method. The result will be: public function get() { $res = $this->instance()->pagination('your_table', 3, null, null, \"First\", \"Last\"); return $res; } Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female First 1 2 3 Last Custom Pagination If you have a very complex SELECT statement, you can use the customPagination method. This method already has a LIMIT by default, in addition to being able to change the name of the arrows. public function get() { $res = $this->instance()->customPagination(\"SELECT created_at, order_status, idSession, SUM(idOrder) AS idOrder FROM `tb_order` GROUP BY created_at, order_status, idSession\", 3, \"First\", \"Last\"); return $res; } Customizing arrows CSS You can customize the look of the arrows through the classes pagination_first_item , pagination_atual_item , pagination_others_itens and pagination_last_item . Below is a customization to serve as an example: .pagination_atual_item { background-color: #B5B5B5; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item, .pagination_others_itens, .pagination_last_item { background-color: #4682B4; color: #FFF; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item:hover, .pagination_others_itens:hover, .pagination_last_item:hover { background-color: #0071E3; color: #FFF !important; transition: 0.2s; } Types of data Below is listed the attributes and data supported by Katrina ORM: String data Types varchar(\"column_name\", size) char(\"column_name\", size) tinytext(\"column_name\", size) mediumtext(\"column_name\", size) longtext(\"column_name\", size) text(\"column_name\") Numerical data Types tinyint(\"column_name\", size) smallint(\"column_name\", size) mediumint(\"column_name\", size) bigint(\"column_name\", size) int(\"column_name\", size) decimal(\"column_name\", value1, value2) Date and time Types date(\"column_name\") year(\"column_name\") time(\"column_name\") datetime(\"column_name\") timestamp(\"column_name\") Boolean Types boolean(\"column_name\") Attributes Types default(\"default_value\") unique() unsigned() incremet() notNull() primary() after(\"column_name\") first()","title":"Katrina1"},{"location":"katrina1/#getting-started","text":"Katrina ORM is a component to bring the object-oriented application development paradigm closer to the relational database paradigm. It helps when carrying out common routines, such as the famous CRUD (create, read, edit and delete), in addition to having a login and data paging system.","title":"Getting Started"},{"location":"katrina1/#requirements","text":"PHP >= 7.2 (Compatible with PHP 8) PHP PDO extension enabled","title":"Requirements"},{"location":"katrina1/#installation","text":"Katrina ORM is already installed by default in Solital. But if you are going to install in another project, use the command below to download via Composer. composer require solital/katrina","title":"Installation"},{"location":"katrina1/#settings","text":"In Solital: # DATABASE CONFIG DB_DRIVE=\"your_drive\" DB_HOST=\"your_host\" DB_NAME=\"your_database_name\" DB_USER=\"your_user\" DB_PASS=\"your_password\" In another project: define('DB_CONFIG', [ 'DRIVE' => 'your_drive', 'HOST' => 'your_host', 'DBNAME' => 'your_database_name', 'USER' => 'your_user', 'PASS' => 'your_password' ]);","title":"Settings"},{"location":"katrina1/#for-sqlite","text":"Some differences exist for connecting to an SQLite database. First, add an additional index called SQLITE_DIR in the DB_CONFIG constant. This constant must have the absolute path where the SQLite database file will be located. Then, assign the value sqlite in the index DRIVE . define('DB_CONFIG', [ 'DRIVE' => 'sqlite', 'DBNAME' => 'your_database_name.db', 'SQLITE_DIR' => '/path/to/file/' ]); In Solital: # DATABASE CONFIG DB_DRIVE=\"your_drive\" DB_HOST=\"your_host\" DB_NAME=\"your_database_name\" DB_USER=\"your_user\" DB_PASS=\"your_password\" SQLITE_DIR=\"/path/to/file/\"","title":"For SQLite"},{"location":"katrina1/#initial-structure","text":"You can use katrina in two ways: 1\u00b0) In Solital, extend the model already created and define the variables $table , $primaryKey and $columns in your model's constructor as listed below: <?php namespace Solital\\Components\\Model; use Solital\\Components\\Model\\Model; class User extends Model { public function __construct() { $this->table = 'your_database_table'; $this->primaryKey = 'primary_key_of_the_table'; $this->columns = [ 'first_column_of_the_table', 'second column of the table', #... ]; } public function get() { return $this->instance()->select()->build(\"ALL\"); } } 2\u00b0) Or if you are using it in another project <?php use Katrina\\Katrina as Katrina; class User { # String private $table = 'your_database_table'; # String private $primaryKey = 'primary_key_of_the_table'; # Array private $columns = [ 'first_column_of_the_table', 'second column of the table', #... ]; public function instance() { $katrina = new Katrina($this->table, $this->columnPrimaryKey, $this->columns); return $katrina; } public function get() { return $this->instance()->select()->build(\"ALL\"); } }","title":"Initial structure"},{"location":"katrina1/#data-manipulation-crud","text":"","title":"Data manipulation - CRUD"},{"location":"katrina1/#list","text":"To list all fields in the table, use select() as shown in the previous example. By default, the method will list all fields in the table. public function get() { return $this->instance()->select()->build(\"ALL\"); } To list a single value, pass the table field id as a parameter, and in build() method use ONLY . public function get() { return $this->instance()->select(3)->build(\"ONLY\"); } To specify which fields you want to list, pass the values \u200b\u200bas parameters. public function get() { return $this->instance()->select(null, null, \"name, city, country\")->build(\"ALL\"); } WHERE If you need the WHERE clause, use the second parameter. public function get() { return $this->instance()->select(null, 'name=\"Clark\"', \"name, city, country\") ->build(\"ALL\"); } With primary key: public function get() { return $this->instance()->select(3, 'name=\"Clark\"', \"name, city, country\") ->build(\"ONLY\"); } LIMIT public function get() { return $this->instance()->select()->limit(2, 5)->build(\"ALL\"); } LIKE The LIKE operator must always be used with the WHERE . public function get() { return $this->instance()->select(null, \"name\")->like(\"%Harvey%\")->build(\"ALL\"); } ORDER BY public function get() { return $this->instance()->select()->order(\"name\")->build(\"ALL\"); } By default, the result will always return ascending. To return values descending, use false in the second parameter. public function get() { return $this->instance()->select()->order(\"name\", false)->build(\"ALL\"); } BETWEEN The BETWEEN operator must always be used with the WHERE . public function get() { return $this->instance()->select(null, \"age\")->between(18, 25)->build(\"ALL\"); }","title":"List"},{"location":"katrina1/#listing-foreign-key","text":"The innerJoin() method returns the values of two tables that have a foreign key. The first parameter will be the name of the table that has a relationship with the current table. The second will be an array containing in the first index the column name of the current table that has the foreign key, and in the second index the column name of the primary key of the other table. To make it easier, see an example below. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"]) ->build(\"ALL\"); } If you need to use the WHERE clause, pass the command in the third parameter as shown below. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"], \"order_status=true\")->build(\"ALL\"); } You can inform which fields you want to return. \"a\" is your main table while \"b\" is your table that has the foreign key. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"], \"order_status=true\", \"a.idPerson, a.name, b.street\", \"address\", \"idAddress\")->build(\"ALL\"); }","title":"Listing foreign key"},{"location":"katrina1/#custom-select","text":"You can create a custom SELECT statement. To do this, use the function customQueryOnly to return a single value from the database, and customQueryAll to return all values from the database. public function getAll() { return $this->instance()->customQueryAll(\"SELECT a.idSession, SUM(b.price) AS price, SUM(a.qtd) AS qtd FROM tb_order a INNER JOIN tb_product b WHERE MONTH( a.created_at) = MONTH(NOW()) GROUP BY a.idSession\"); } public function getOnly() { return $this->instance()->customQueryOnly(\"SELECT a.idSession, SUM(b.price) AS price, SUM(a.qtd) AS qtd FROM tb_order a INNER JOIN tb_product b WHERE MONTH( a.created_at) = MONTH(NOW()) GROUP BY a.idSession\"); }","title":"Custom SELECT"},{"location":"katrina1/#insert","text":"The insert() method inserts the values \u200b\u200binto the table. It is NOT necessary to use build() method to insert the data. To do this, create an array with the values \u200b\u200bthat the method will receive /** * Return bool */ public function insert() { $res = $this->instance()->insert(['Clark', 'Metropolis', 'EUA']); return $res; } To return the last insert ID, pass a true in the second parameter. /** * Return array * * ['res'] => 'true', * ['lastId'] => '2' */ public function insert() { $res = $this->instance()->insert(['Clark', 'Metropolis', 'EUA'], true); return $res; }","title":"Insert"},{"location":"katrina1/#update","text":"The update() method updates the values \u200b\u200bin the table. It is NOT necessary to use build() method to update the data. The process is similar to the insert method. The first parameter is the columns that will be updated, the second parameter the values \u200b\u200band the third the row id . You can use an integer or a string in the third parameter public function update() { $res = $this->instance()->update(['name', 'age'], ['Specter', '41'], \"id=3\"); return $res; } Or public function update() { $res = $this->instance()->update(['name', 'age'], ['Specter', '41'], 3); return $res; }","title":"Update"},{"location":"katrina1/#delete","text":"The delete() method deletes the values \u200b\u200bin the table. Enter the value of the line to be deleted, the value being the primary key. public function delete() { $res = $this->instance()->delete(3)->build(); return $res; } Or a string public function delete() { $res = $this->instance()->delete(\"Bruce\")->build(); return $res; } By default, the delete method uses the column name of the primary key to delete the row, but you can use the name of another column using the second parameter. public function delete() { $res = $this->instance()->delete(\"Bruce\", \"name\")->build(); return $res; } ** Force delete with foreign key ** In some cases there may be a need to delete a record with the foreign key from another table. To disable foreign key checking, you can use the third parameter as true . public function delete() { $res = $this->instance()->delete(3, null, true)->build(); return $res; }","title":"Delete"},{"location":"katrina1/#manipulating-tables","text":"","title":"Manipulating tables"},{"location":"katrina1/#create-a-new-table","text":"The createTable() method starts opening the table. After inserting the fields and data types that the tables will have, use closeTable() to close the table. For a better understanding see the syntax below. $res = $this->instance() /* Starts the table by specifying its name */ ->createTable(\"your_table_name\") /* Fields and table type */ ->int(\"id_orm\")->primary()->increment() ->varchar(\"name\", 20)->unique()->notNull()->default(\"specter\") ->int(\"age\", 3)->unsigned()->notNull() ->varchar(\"email\", 30)->default(\"harvey.specter@gmail.com\")->notNull() ->varchar(\"profession\", 40) ->int(\"tipo\") ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") /* Close the command to create the table */ ->closeTable() /* Compile the code above */ ->build();","title":"Create a new table"},{"location":"katrina1/#list-tables","text":"To have a list of all the tables in your database, use the listTables() method by passing ALL in the build() method. public function get() { $res = $this->instance()->listTables()->build(\"ALL\"); return $res; }","title":"List tables"},{"location":"katrina1/#list-columns","text":"To list the columns of a table, use the describeTable() method passing as a parameter the name of your table together with ALL in the build() public function get() { $res = $this->instance()->describeTable(\"your_table\")->build(\"ALL\"); return $res; }","title":"List columns"},{"location":"katrina1/#alter-table","text":"The alter() method performs the procedures of adding, changing and deleting a field from the database table. Add new field Use add() method together with the data type to add a new field. public function get() { $res = $this->instance() ->alter(\"message\")->add() ->varchar(\"first_field\", 10) ->build(); } Drop column Use the drop() method to delete a column from the table. public function get() { $res = $this->instance() ->alter(\"message\")->drop(\"type\") ->build(); } Modify column Use the modify SQL with the modify() method. public function get() { $res = $this->instance() ->alter(\"message\")->modify() ->varchar(\"person_type\", 100) ->build(); } Change column Use the change() method to change a column. As a parameter, pass the current column name. public function get() { $res = $this->instance() ->alter(\"message\")->change(\"person_type\") ->varchar(\"type\", 100) ->build(); } Rename table Use the rename() method to rename a database table. Use the first parameter the current table name and the second parameter the new table name. public function get() { $res = $this->instance() ->rename(\"message\", \"new_message\") ->build(); }","title":"Alter table"},{"location":"katrina1/#adding-foreign-key","text":"To add a foreign key to an already created table, use the addConstraint() method to add a constraint; foreign() to inform the column and references() to refer to the table. public function get() { $res = $this->instance() ->alter(\"message\")->addConstraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") ->build(); } NOTE: if you are creating a new table, use the constraint() method instead of addConstraint() as shown below: #... ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") #...","title":"Adding foreign key"},{"location":"katrina1/#drop-table","text":"To delete a table from the database, use the dropTable() method. public function get() { $res = $this->instance() ->dropTable(\"message\") ->build(); }","title":"Drop table"},{"location":"katrina1/#truncate-table","text":"To use the sql truncate command, use the truncate() method. public function get() { $res = $this->instance() ->truncate() ->build(); } By default, the database checks the table's foreign key and locks the truncate command. To disable foreign key verification, enter true as a parameter. public function get() { $res = $this->instance() ->truncate(true) ->build(); }","title":"Truncate table"},{"location":"katrina1/#procedure","text":"To call a database procedure, use the call() method. public function get() { $res = $this->instance()->call('procedure_name'); return $res; } To use procedure parameters, pass the values in array format. public function get() { $res = $this->instance()->call('procedure_name' , ['param_1, param_2, param_3']); return $res; }","title":"Procedure"},{"location":"katrina1/#pagination","text":"The pagination() method creates a system for paging results. To initialize, the first parameter must be the table you want to use to start paging. The second parameter will list the amount of values that will be returned from the table as shown in the example below. public function get() { $res = $this->instance()->pagination('your_table', 3); return $res; } The above method will return an array containing rows indexes that will return values, and arrows that will return commands for pagination. To use pagination with relationship in another table, in the third parameter pass an array containing the name of the table that has a relationship with the current table, the column name of the current table that has the foreign key and the column name of the primary key of the another table. public function get() { $res = $this->instance()->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key']); return $res; } INNER JOIN If you want to use pagination with a table that has a foreign key, pass an array in the third parameter. In the first index, insert the name of the table that is linked to the current table, in the second index the name of the column that contains the foreign key and in the third index the column name of the primary key of the table that references the current table public function get() { $res = $this->instance()->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key'], \"status=true\"); return $res; } WHERE clause To use the WHERE clause, use the fourth parameter as shown below. public function get() { $res = $this->instance()->pagination('your_table', 3, null, \"status=true\"); return $res; } Wolf Templte To use in the Wolf template, use it this way. $html = $this->instance()->pagination('your_table', 3); Wolf::loadView('home', [ 'rows' => $html['rows'], 'arrows' => $html['arrows'] ]); And in your view, return the results that way. <table> <thead> <tr> <th>Name</th> <th>Age</th> <th>Gender</th> </tr> </thead> <tbody> <?php foreach ($rows as $r): ?> <tr> <td><?= $r['name'] ?></td> <td><?= $r['age'] ?></td> <td><?= $r['gender'] ?></td> </tr> <?php endforeach; ?> </tbody> </table> <?php echo $arrows; The result will be as follows: Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female << 1 2 3 >> To change the arrows ( << and >> ), use the last two parameters of the pagination() method. The result will be: public function get() { $res = $this->instance()->pagination('your_table', 3, null, null, \"First\", \"Last\"); return $res; } Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female First 1 2 3 Last","title":"Pagination"},{"location":"katrina1/#custom-pagination","text":"If you have a very complex SELECT statement, you can use the customPagination method. This method already has a LIMIT by default, in addition to being able to change the name of the arrows. public function get() { $res = $this->instance()->customPagination(\"SELECT created_at, order_status, idSession, SUM(idOrder) AS idOrder FROM `tb_order` GROUP BY created_at, order_status, idSession\", 3, \"First\", \"Last\"); return $res; } Customizing arrows CSS You can customize the look of the arrows through the classes pagination_first_item , pagination_atual_item , pagination_others_itens and pagination_last_item . Below is a customization to serve as an example: .pagination_atual_item { background-color: #B5B5B5; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item, .pagination_others_itens, .pagination_last_item { background-color: #4682B4; color: #FFF; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item:hover, .pagination_others_itens:hover, .pagination_last_item:hover { background-color: #0071E3; color: #FFF !important; transition: 0.2s; }","title":"Custom Pagination"},{"location":"katrina1/#types-of-data","text":"Below is listed the attributes and data supported by Katrina ORM: String data Types varchar(\"column_name\", size) char(\"column_name\", size) tinytext(\"column_name\", size) mediumtext(\"column_name\", size) longtext(\"column_name\", size) text(\"column_name\") Numerical data Types tinyint(\"column_name\", size) smallint(\"column_name\", size) mediumint(\"column_name\", size) bigint(\"column_name\", size) int(\"column_name\", size) decimal(\"column_name\", value1, value2) Date and time Types date(\"column_name\") year(\"column_name\") time(\"column_name\") datetime(\"column_name\") timestamp(\"column_name\") Boolean Types boolean(\"column_name\") Attributes Types default(\"default_value\") unique() unsigned() incremet() notNull() primary() after(\"column_name\") first()","title":"Types of data"},{"location":"logger/","text":"First, every Logger has a channel , which is a name that will be associated with each entry of the logger log, and each part of the application can have a logger with a different channel to better differentiate them, facilitating the filtering of information, To the Logger must be added one or more handlers that are components that record the logs in certain ways, like the classic files or sockets and databases for example. Another important concept in the use of logs is the level of the log record, not all information has the same \u201cimportance\u201d in the log, or the same urgency to be dealt with, so entries in a log are categorized by levels: DEBUG: Debug information. INFO: Interesting events. For example: a user performed SQL login or logs. NOTICE: Normal but significant events. WARNING: Exceptional occurrences, but not errors. For example: Use of deprecated APIs, inappropriate use of an API. In general things that are not wrong but need attention. ERROR: Runtime errors that do not require immediate action, but must be logged and monitored. CRITICAL: Critical conditions. For example: An application component is not available, an unexpected exception has occurred. ALERT: Immediate action must be taken. Example: System crashed, database is unavailable, etc. It should trigger an alert for the person in charge to take action as soon as possible. EMERGENCY: Emergency: The system is unusable. Usage Create the logger instance with a channel id, use Psr\\Log\\LogLevel; use Solital\\Core\\Logger\\Logger; use Solital\\Core\\Logger\\Entry\\MemoryInfo; use Solital\\Core\\Logger\\Handler\\SyslogHandler; use Solital\\Core\\Logger\\Handler\\TerminalHandler; // with channel id $logger = new Logger('MyApp'); // log every warning to syslog $logger->addHandler( LogLevel::WARNING, new SyslogHandler() ); // log to terminal for MemoryInfo entry $logger->addHandler( LogLevel::INFO, new TerminalHandler(), MemoryInfo::class // handle this log object only ); // log a text message $logger->warning('a warning message'); // log memory usage $logger->info(new MemoryInfo()); If you are using a Controller, you don't need to instantiate the Logger class. Just use $this->logger() method: $this->logger('MyApp')->addHandler( LogLevel::WARNING, new SyslogHandler() )->warning('a warning message'); Concepts Log entry A log entry is a message in the form of an object. It solves the problem of 'WHAT TO BE SENT OUT' . It has a message template, and some processors to process its context. For example, Entry\\MemoryInfo is a predefined log entry with a message template of {memory_used}M memory used , peak usage is {memory_peak}M and one Processor\\MemoryProcessor processor. // with predefined template and processor $logger->warning(new MemoryInfo()); // use new template $logger->warning(new MemoryInfo('Peak memory usage is {memory_peak}M')); Entry\\LogEntry is the log entry prototype used whenever text message is to be logged // using LogEntry $logger->info('test only'); To define your own log entry, use Solital\\Core\\Logger\\Entry\\LogEntry; class MyMessage extends LogEntry { // message template protected $message = 'your {template}'; } // add handler $logger->addHandler( 'warning', // level function(LogEntry $entry) { // a handler echo (string) $entry; }, MyMessage::class // handle this type of message only ); // output: 'your wow' $logger->error(new MyMessage(), ['template' => 'wow']); Processor Processors are associated with log entry classes. They solve the problem of 'WHAT EXTRA INFO TO SENT OUT' . They will inject information into entries' context. Processors are callable(LogEntryInterface $entry) , use Solital\\Core\\Logger\\Processor\\ProcessorAbstract; // closure $processor1 = function(LogEntry $entry) { }; // invokable object $processor2 = new class() { public function __invoke(LogEntry $entry) { } } // extends class Processor3 extends ProcessorAbstract { protected function updateContext(array $context): array { $context['bingo'] = 'wow'; return $context; } } Processors are attached to log entries either in the entry class definition as follows, class MyMessage extends LogEntry { // message template protected $message = 'your {template}'; // define processors for this class protected static function classProcessors(): array { return [ function(LogEntry $entry) { $context = $entry->getContext(); $context['template'] = 'wow'; $entry->setContext($context); }, new myProcessor(), ]; } } or during the handler attachment use Solital\\Core\\Logger\\Handler\\SyslogHandler; // will also add 'Processor1' and 'Processor2' to 'MyMessage' class $logger->addHandler( 'info', new SyslogHandler(), MyMessage::addProcessor( new Processor1(), new Processor2(), ... ) ); Handler Handlers solve the problem of 'WHERE TO SEND MESSAGE' . They take a log entry object and send it to somewhere. Handlers takes the form of callable(LogEntryInterface $entry) as follows, use Solital\\Core\\Logger\\Handler\\HandlerAbstract; $handler1 = function(LogEntry $entry) { echo (string) $entry; } $handler2 = new class() { public function __invoke(LogEntry $entry) { } } class Handler3 extends HandlerAbstract { protected function write(LogEntryInterface $entry) { echo $this->>getFormatter()->format($entry); } } Handlers are added to the $logger with specific log level and type of log message they are going to handle (default is LogEntryInterface ). $logger->addHandler( LogLevel::WARNING, new TerminalHandler(), LogEntryInterface::class // this is the default anyway ); Formatter Formatters solve the problem of 'HOW MESSAGE WILL BE PRESENTED'' . Each handler of the type Handler\\HandlerAbstract may have formatter specified during its initiation. use Solital\\Core\\Logger\\Handler\\TerminalHandler; use Solital\\Core\\Logger\\Formatter\\AnsiFormatter; // use ANSI Color formatter $handler = new TerminalHandler(new AnsiFormatter()); // add handler handles 'ConsoleMessage' ONLY $logger->addHandler('debug', $handler, ConsoleMessage::class); // log to console $logger->info(new ConsoleMessage('exited with error.')); // this will goes handlers handling 'LogEntry' $logger->info('exited with error'); APIs LoggerInterface related See [PSR-3][PSR-3] for standard related APIs. Solital\\Core\\Logger\\Logger related __construct(string $channel) Create the logger with a channel id. addHandler(string $level, callable $handler, string $entryClass, int $priority = 50): $this Add one handler to specified channel with the priority. Solital\\Core\\Logger\\Entry\\LogEntry related static function addProcessor(callable ...$callables): string This method will returns called class name. Auto log Solital generates a log file whenever a critical system error occurs. Log files are stored in app/Storage/log/ . To disable the creation of these files, open the bootstrap.yaml file and change the enabled_log_files key to false : logs: enabled_log_files: false","title":"Logger"},{"location":"logger/#usage","text":"Create the logger instance with a channel id, use Psr\\Log\\LogLevel; use Solital\\Core\\Logger\\Logger; use Solital\\Core\\Logger\\Entry\\MemoryInfo; use Solital\\Core\\Logger\\Handler\\SyslogHandler; use Solital\\Core\\Logger\\Handler\\TerminalHandler; // with channel id $logger = new Logger('MyApp'); // log every warning to syslog $logger->addHandler( LogLevel::WARNING, new SyslogHandler() ); // log to terminal for MemoryInfo entry $logger->addHandler( LogLevel::INFO, new TerminalHandler(), MemoryInfo::class // handle this log object only ); // log a text message $logger->warning('a warning message'); // log memory usage $logger->info(new MemoryInfo()); If you are using a Controller, you don't need to instantiate the Logger class. Just use $this->logger() method: $this->logger('MyApp')->addHandler( LogLevel::WARNING, new SyslogHandler() )->warning('a warning message');","title":"Usage"},{"location":"logger/#concepts","text":"Log entry A log entry is a message in the form of an object. It solves the problem of 'WHAT TO BE SENT OUT' . It has a message template, and some processors to process its context. For example, Entry\\MemoryInfo is a predefined log entry with a message template of {memory_used}M memory used , peak usage is {memory_peak}M and one Processor\\MemoryProcessor processor. // with predefined template and processor $logger->warning(new MemoryInfo()); // use new template $logger->warning(new MemoryInfo('Peak memory usage is {memory_peak}M')); Entry\\LogEntry is the log entry prototype used whenever text message is to be logged // using LogEntry $logger->info('test only'); To define your own log entry, use Solital\\Core\\Logger\\Entry\\LogEntry; class MyMessage extends LogEntry { // message template protected $message = 'your {template}'; } // add handler $logger->addHandler( 'warning', // level function(LogEntry $entry) { // a handler echo (string) $entry; }, MyMessage::class // handle this type of message only ); // output: 'your wow' $logger->error(new MyMessage(), ['template' => 'wow']); Processor Processors are associated with log entry classes. They solve the problem of 'WHAT EXTRA INFO TO SENT OUT' . They will inject information into entries' context. Processors are callable(LogEntryInterface $entry) , use Solital\\Core\\Logger\\Processor\\ProcessorAbstract; // closure $processor1 = function(LogEntry $entry) { }; // invokable object $processor2 = new class() { public function __invoke(LogEntry $entry) { } } // extends class Processor3 extends ProcessorAbstract { protected function updateContext(array $context): array { $context['bingo'] = 'wow'; return $context; } } Processors are attached to log entries either in the entry class definition as follows, class MyMessage extends LogEntry { // message template protected $message = 'your {template}'; // define processors for this class protected static function classProcessors(): array { return [ function(LogEntry $entry) { $context = $entry->getContext(); $context['template'] = 'wow'; $entry->setContext($context); }, new myProcessor(), ]; } } or during the handler attachment use Solital\\Core\\Logger\\Handler\\SyslogHandler; // will also add 'Processor1' and 'Processor2' to 'MyMessage' class $logger->addHandler( 'info', new SyslogHandler(), MyMessage::addProcessor( new Processor1(), new Processor2(), ... ) ); Handler Handlers solve the problem of 'WHERE TO SEND MESSAGE' . They take a log entry object and send it to somewhere. Handlers takes the form of callable(LogEntryInterface $entry) as follows, use Solital\\Core\\Logger\\Handler\\HandlerAbstract; $handler1 = function(LogEntry $entry) { echo (string) $entry; } $handler2 = new class() { public function __invoke(LogEntry $entry) { } } class Handler3 extends HandlerAbstract { protected function write(LogEntryInterface $entry) { echo $this->>getFormatter()->format($entry); } } Handlers are added to the $logger with specific log level and type of log message they are going to handle (default is LogEntryInterface ). $logger->addHandler( LogLevel::WARNING, new TerminalHandler(), LogEntryInterface::class // this is the default anyway ); Formatter Formatters solve the problem of 'HOW MESSAGE WILL BE PRESENTED'' . Each handler of the type Handler\\HandlerAbstract may have formatter specified during its initiation. use Solital\\Core\\Logger\\Handler\\TerminalHandler; use Solital\\Core\\Logger\\Formatter\\AnsiFormatter; // use ANSI Color formatter $handler = new TerminalHandler(new AnsiFormatter()); // add handler handles 'ConsoleMessage' ONLY $logger->addHandler('debug', $handler, ConsoleMessage::class); // log to console $logger->info(new ConsoleMessage('exited with error.')); // this will goes handlers handling 'LogEntry' $logger->info('exited with error');","title":"Concepts"},{"location":"logger/#apis","text":"LoggerInterface related See [PSR-3][PSR-3] for standard related APIs. Solital\\Core\\Logger\\Logger related __construct(string $channel) Create the logger with a channel id. addHandler(string $level, callable $handler, string $entryClass, int $priority = 50): $this Add one handler to specified channel with the priority. Solital\\Core\\Logger\\Entry\\LogEntry related static function addProcessor(callable ...$callables): string This method will returns called class name.","title":"APIs"},{"location":"logger/#auto-log","text":"Solital generates a log file whenever a critical system error occurs. Log files are stored in app/Storage/log/ . To disable the creation of these files, open the bootstrap.yaml file and change the enabled_log_files key to false : logs: enabled_log_files: false","title":"Auto log"},{"location":"mailer-component/","text":"Mailer is Solital's default class for sending emails. The Mailer class uses the PHPMailer component to send emails. In addition, you can create email queues asynchronously, and also use another email account to test your project. To use this component, first edit the .env file. MAIL_DEBUG=\"0\" MAIL_HOST=\"mail.yourhost.com\" MAIL_USER=\"email@your_email.com\" MAIL_PASS=\"your_password\" MAIL_SECURITY=\"tls\" MAIL_PORT=\"587\" The code below shows the use of the Mailer class: use Solital\\Core\\Resource\\Mail\\Mailer; $mailer = new Mailer(); // Add sender and recipient information $mailer->add('sender_email@gmail.com', 'Sender name', 'recipient_email@gmail.com', 'Recipient name'); // Send a file by email (OPTIONAL) $mailer->attach('image.png', 'image_name'); // Send an image in HTML (OPTIONAL) $mailer->embeddedImage('image.png', 'image', 'image'); // Send email $mailer->send('E-mail test', '<h1>E-mail test</h1><p>cid:image</p>'); // If there is an error if ($mailer->error()) { echo $mailer->error(); } E-mail queues To create an email queue, first check your database is connected. All emails will be saved in a database to be sent later. The process is similar to sending a standard email, the difference is the use of the queue() method. // Add sender and recipient information $mailer->add('sender_email@gmail.com', 'Sender name', 'recipient_email@gmail.com', 'Recipient name'); // Send email $mailer->queue('E-mail test', '<h1>E-mail test</h1>'); After the emails are saved in the database, use the sendQueue() method to send all the emails. You can set a delay in seconds for sending the emails (default is 5 seconds). $mailer = new Mailer(); $mailer->sendQueue(); // Delay 10 seconds $mailer->sendQueue(10);","title":"Mailer"},{"location":"mailer-component/#e-mail-queues","text":"To create an email queue, first check your database is connected. All emails will be saved in a database to be sent later. The process is similar to sending a standard email, the difference is the use of the queue() method. // Add sender and recipient information $mailer->add('sender_email@gmail.com', 'Sender name', 'recipient_email@gmail.com', 'Recipient name'); // Send email $mailer->queue('E-mail test', '<h1>E-mail test</h1>'); After the emails are saved in the database, use the sendQueue() method to send all the emails. You can set a delay in seconds for sending the emails (default is 5 seconds). $mailer = new Mailer(); $mailer->sendQueue(); // Delay 10 seconds $mailer->sendQueue(10);","title":"E-mail queues"},{"location":"mask/","text":"StrMask is a Solital class to make masks for a string In your PHP application, use the static method apply of Mask: use Solital\\Core\\Resource\\Str\\StrMask; $output = StrMask::apply($inputValue, $maskExpression, $config); Arguments $inputValue : string - The input value to apply mask. $maskExpression : string - The mask expression for $output. $config : array - The configuration for operation Patterns The patterns are used to filter $inputValue: Code Meaning **0** digits (like 0 to 9 numbers) **9** digits (like 0 to 9 numbers), but optional **A** letters (uppercase or lowercase) and digits **S** only letters (uppercase or lowercase) Special chars Special chars are used in mask expressions to format output: / ( ) . : - space + , @ Thousand separator You can format a number in thousand separator and control precision. The mask keys are: separator : Input 1234.56 is ouputed as 1 234.56 dot_separator : Input 1234,56 is ouputed as 1.234,56 comma_separator : Input 1234.56 is ouputed as 1,234.56 To manage precision, keys shall be suffixed by .{Number} . Example: separator.1 : Input 1234.56743 is ouputed as 1 234.5 dot_separator.4 : Input 1234,56743 is ouputed as 1.234,5674 comma_separator.2 : Input 1234.56743 is ouputed as 1,234.56 Time validation You can format a time according limit: Mask Meaning **H** Input value shall be inside 0 and 2. **h** Input value shall be inside 0 and 3. **m** Input value shall be inside 0 and 4. **s** Input value shall be inside 0 and 5. Percent validation You can format a value from $inputValue as a percent and manage the precision. Use the key percent to have a extract value from $inputValue within 0 to 100. Suffix the key with .{Number} to manage precision ( percent.2 ). Example: $output = StrMask::apply(\"99.4125\", \"percent.2\"); // $output contains: 99.41 Prefix and suffix You have possibility to set suffix and prefix in output: $output = StrMask::apply(\"0102030405\", \"00 00 00 00 00\", [ \"prefix\" => \"My phone is \", \"suffix\" => \"!\" ]); // $output contains: My phone is 01 02 03 04 05!","title":"Mask"},{"location":"mask/#arguments","text":"$inputValue : string - The input value to apply mask. $maskExpression : string - The mask expression for $output. $config : array - The configuration for operation","title":"Arguments"},{"location":"mask/#patterns","text":"The patterns are used to filter $inputValue: Code Meaning **0** digits (like 0 to 9 numbers) **9** digits (like 0 to 9 numbers), but optional **A** letters (uppercase or lowercase) and digits **S** only letters (uppercase or lowercase)","title":"Patterns"},{"location":"mask/#special-chars","text":"Special chars are used in mask expressions to format output: / ( ) . : - space + , @","title":"Special chars"},{"location":"mask/#thousand-separator","text":"You can format a number in thousand separator and control precision. The mask keys are: separator : Input 1234.56 is ouputed as 1 234.56 dot_separator : Input 1234,56 is ouputed as 1.234,56 comma_separator : Input 1234.56 is ouputed as 1,234.56 To manage precision, keys shall be suffixed by .{Number} . Example: separator.1 : Input 1234.56743 is ouputed as 1 234.5 dot_separator.4 : Input 1234,56743 is ouputed as 1.234,5674 comma_separator.2 : Input 1234.56743 is ouputed as 1,234.56","title":"Thousand separator"},{"location":"mask/#time-validation","text":"You can format a time according limit: Mask Meaning **H** Input value shall be inside 0 and 2. **h** Input value shall be inside 0 and 3. **m** Input value shall be inside 0 and 4. **s** Input value shall be inside 0 and 5.","title":"Time validation"},{"location":"mask/#percent-validation","text":"You can format a value from $inputValue as a percent and manage the precision. Use the key percent to have a extract value from $inputValue within 0 to 100. Suffix the key with .{Number} to manage precision ( percent.2 ). Example: $output = StrMask::apply(\"99.4125\", \"percent.2\"); // $output contains: 99.41","title":"Percent validation"},{"location":"mask/#prefix-and-suffix","text":"You have possibility to set suffix and prefix in output: $output = StrMask::apply(\"0102030405\", \"00 00 00 00 00\", [ \"prefix\" => \"My phone is \", \"suffix\" => \"!\" ]); // $output contains: My phone is 01 02 03 04 05!","title":"Prefix and suffix"},{"location":"messages/","text":"Message is a component for displaying alerts in views rendered with Wolf Template. With it, it is possible to display a message of success, error or any other type of message. By default, this class is already instantiated in the Controller class. NOTE: if you do not extend the Controller class, you will need to instantiate the Message class. use Solital\\Core\\Resource\\Message; $message = new Message(); How to use You can create a message using the new() method in controller, or using the messages() helper: /** With method */ $this->message->new('msg.test', 'Just a test message displayed in the view!'); /** With helper */ message('msg.test', 'Just a test message displayed in the view!'); To retrieve this message, use the get method. /** With method */ echo $this->message->get('msg.test'); /** With helper */ echo message('msg.test'); Using in Wolf Template To make use of this component in Wolf, the method of creating the message is exactly the same. The code represents a practical and recommended method of retrieving the message. <?php namespace Solital\\Components\\Controller; use Solital\\Core\\Http\\Controller\\Controller; class UserController extends Controller { /** * Construct */ public function __construct() { parent::_construct(); } /** * @return void */ public function home(): void { return view('home', [ 'msg' => $this->message->get('msg.test') // or use \"message('msg.test')\" ]); } /** * @return void */ public function generate(): void { $this->message->new('msg.test', 'Just a test message displayed in the view!'); // message('msg.test', 'Just a test message displayed in the view!'); } In your view, display the message this way: <div> {% if ($msg): %} <p>{{ $msg }}</p> {% endif; %} </div>","title":"Messages"},{"location":"messages/#how-to-use","text":"You can create a message using the new() method in controller, or using the messages() helper: /** With method */ $this->message->new('msg.test', 'Just a test message displayed in the view!'); /** With helper */ message('msg.test', 'Just a test message displayed in the view!'); To retrieve this message, use the get method. /** With method */ echo $this->message->get('msg.test'); /** With helper */ echo message('msg.test');","title":"How to use"},{"location":"messages/#using-in-wolf-template","text":"To make use of this component in Wolf, the method of creating the message is exactly the same. The code represents a practical and recommended method of retrieving the message. <?php namespace Solital\\Components\\Controller; use Solital\\Core\\Http\\Controller\\Controller; class UserController extends Controller { /** * Construct */ public function __construct() { parent::_construct(); } /** * @return void */ public function home(): void { return view('home', [ 'msg' => $this->message->get('msg.test') // or use \"message('msg.test')\" ]); } /** * @return void */ public function generate(): void { $this->message->new('msg.test', 'Just a test message displayed in the view!'); // message('msg.test', 'Just a test message displayed in the view!'); } In your view, display the message this way: <div> {% if ($msg): %} <p>{{ $msg }}</p> {% endif; %} </div>","title":"Using in Wolf Template"},{"location":"middleware/","text":"The middleware in web applications is the mid-layer between the HTTP request and the application logic. The middleware process incoming requests and execute the code before the controller\u2019s actions. One of the main functions is filtering HTTP requests from the user\u2019s browser before the actual application logic. Create middleware The process to create a Middleware is quite simple: you can use the Vinci Console to create a middleware class. This class will be stored in app/Middleware/ . Command: php vinci create:middleware UserMiddleware Class: <?php namespace Solital\\Middleware; use Solital\\Core\\Http\\Middleware\\BaseMiddlewareInterface; class UserMiddleware implements BaseMiddlewareInterface { /** * @return void */ public function handle(): void { // ... } } Basic Middleware To assign middleware to all routes within a group, you may use the middleware key in the group attribute array. Middleware are executed in the order they are listed in the array: Course::group(['prefix' => '/admin', 'middleware' => '\\Solital\\Middleware\\UserMiddleware'], function () { Course::get(\"/login\", \"UserController@login\")->name('login'); Course::put(\"/logout\", \"UserController@logout\")->name('logout'); }); Use a helper If you don't want to type the entire middleware namespace, you can configure it in the middleware.yaml file and use the middleware helper. middleware.yaml middleware: login: \\Solital\\Middleware\\UserMiddleware routes.php Course::group(['prefix' => '/admin', 'middleware' => middleware('login')], function () { Course::get(\"/login\", \"UserController@login\")->name('login'); Course::put(\"/logout\", \"UserController@logout\")->name('logout'); }); Adding Middleware If you only have one route that needs to add middleware, use the addMiddleware method. Course::match(['get', 'post'], '/user/login', 'UserMiddleware@login')->addMiddleware('\\Solital\\Middleware\\UserMiddleware:guest');","title":"Middleware"},{"location":"middleware/#create-middleware","text":"The process to create a Middleware is quite simple: you can use the Vinci Console to create a middleware class. This class will be stored in app/Middleware/ . Command: php vinci create:middleware UserMiddleware Class: <?php namespace Solital\\Middleware; use Solital\\Core\\Http\\Middleware\\BaseMiddlewareInterface; class UserMiddleware implements BaseMiddlewareInterface { /** * @return void */ public function handle(): void { // ... } }","title":"Create middleware"},{"location":"middleware/#basic-middleware","text":"To assign middleware to all routes within a group, you may use the middleware key in the group attribute array. Middleware are executed in the order they are listed in the array: Course::group(['prefix' => '/admin', 'middleware' => '\\Solital\\Middleware\\UserMiddleware'], function () { Course::get(\"/login\", \"UserController@login\")->name('login'); Course::put(\"/logout\", \"UserController@logout\")->name('logout'); });","title":"Basic Middleware"},{"location":"middleware/#use-a-helper","text":"If you don't want to type the entire middleware namespace, you can configure it in the middleware.yaml file and use the middleware helper. middleware.yaml middleware: login: \\Solital\\Middleware\\UserMiddleware routes.php Course::group(['prefix' => '/admin', 'middleware' => middleware('login')], function () { Course::get(\"/login\", \"UserController@login\")->name('login'); Course::put(\"/logout\", \"UserController@logout\")->name('logout'); });","title":"Use a helper"},{"location":"middleware/#adding-middleware","text":"If you only have one route that needs to add middleware, use the addMiddleware method. Course::match(['get', 'post'], '/user/login', 'UserMiddleware@login')->addMiddleware('\\Solital\\Middleware\\UserMiddleware:guest');","title":"Adding Middleware"},{"location":"migrations/","text":"Introduction Basically, it consists of maintaining the versioning of an application's database and manipulating it through code, enabling the sharing of all its change history. This makes life a lot easier for any development team, as it makes it possible to change the application schema just by executing the code responsible for it, which is also versioned and shared with the rest of the project. Creating migrations All migrations are stored in app/Database/Migrations . To create a migration, you must use the Vinci Console. php vinci create:migration If you want, you can give the migration a name. php vinci create:migration user You can create a migration with a ready-made structure to create a table in the database, for that use the word create in the argument. php vinci create:migration create_user Structure of the migration Below is the structure of a standard migration: <?php namespace Solital\\Database\\Migrations; use Solital\\Core\\Database\\Migrations\\Migration; class Migration20211220193145 extends Migration { /** * Run migration * * @return mixed */ public function up() { // } /** * Roolback migration * * @return mixed */ public function down() { // } } If you used the word create in the argument, the default structure changes a bit like this: <?php namespace Solital\\Database\\Migrations; use Katrina\\Katrina; use Solital\\Core\\Database\\Migrations\\Migration; class Migration20211220193145 extends Migration { /** * Run migration * * @return mixed */ public function up() { Katrina::createTable(\"user\") ->int('id')->primary() // ... ->createdUpdateAt() ->closeTable(); } /** * Roolback migration * * @return mixed */ public function down() { Katrina::dropTable(\"user\"); } } Running migrations To run migrations, it's simple: run the command below: php vinci migrate If you have a new migration or one that hasn't been run, use the --status option. php vinci migrate --status Rollback migrations If you want to roll back a migration, use the --rollback option. php vinci migrate --rollback The previous command will roll back all migrations created using the up() method. To limit the number of migrations, assign a value to --rollback . php vinci migrate --rollback=3","title":"Migrations"},{"location":"migrations/#introduction","text":"Basically, it consists of maintaining the versioning of an application's database and manipulating it through code, enabling the sharing of all its change history. This makes life a lot easier for any development team, as it makes it possible to change the application schema just by executing the code responsible for it, which is also versioned and shared with the rest of the project.","title":"Introduction"},{"location":"migrations/#creating-migrations","text":"All migrations are stored in app/Database/Migrations . To create a migration, you must use the Vinci Console. php vinci create:migration If you want, you can give the migration a name. php vinci create:migration user You can create a migration with a ready-made structure to create a table in the database, for that use the word create in the argument. php vinci create:migration create_user","title":"Creating migrations"},{"location":"migrations/#structure-of-the-migration","text":"Below is the structure of a standard migration: <?php namespace Solital\\Database\\Migrations; use Solital\\Core\\Database\\Migrations\\Migration; class Migration20211220193145 extends Migration { /** * Run migration * * @return mixed */ public function up() { // } /** * Roolback migration * * @return mixed */ public function down() { // } } If you used the word create in the argument, the default structure changes a bit like this: <?php namespace Solital\\Database\\Migrations; use Katrina\\Katrina; use Solital\\Core\\Database\\Migrations\\Migration; class Migration20211220193145 extends Migration { /** * Run migration * * @return mixed */ public function up() { Katrina::createTable(\"user\") ->int('id')->primary() // ... ->createdUpdateAt() ->closeTable(); } /** * Roolback migration * * @return mixed */ public function down() { Katrina::dropTable(\"user\"); } }","title":"Structure of the migration"},{"location":"migrations/#running-migrations","text":"To run migrations, it's simple: run the command below: php vinci migrate If you have a new migration or one that hasn't been run, use the --status option. php vinci migrate --status","title":"Running migrations"},{"location":"migrations/#rollback-migrations","text":"If you want to roll back a migration, use the --rollback option. php vinci migrate --rollback The previous command will roll back all migrations created using the up() method. To limit the number of migrations, assign a value to --rollback . php vinci migrate --rollback=3","title":"Rollback migrations"},{"location":"queue/","text":"Queues in Solital are easy to use. First, you'll need to create them using the Vinci Console: php vinci create:queue UserQueue The queues will be stored inside the app/Queue folder. The structure that will be created is similar to this: <?php use Solital\\Core\\Queue\\Queue; class UserQueue extends Queue { public function dispatch() { # ... } } All code must be added in the dispatch() method Running a queue To run a queue, you will need to run the command: php vinci queue This command will run all queues you have created. Some queues that Solital creates will also run. You can run a specific queue. For that, use the --class option. php vinci queue --class=UserQueue","title":"Queue"},{"location":"queue/#running-a-queue","text":"To run a queue, you will need to run the command: php vinci queue This command will run all queues you have created. Some queues that Solital creates will also run. You can run a specific queue. For that, use the --class option. php vinci queue --class=UserQueue","title":"Running a queue"},{"location":"recovery-password/","text":"Setting This procedure uses the forgot method to define the database table. The columns method the form's email field. In the values method, the e-mail that will be sent the recovery link is informed in the first parameter, and in the second parameter the URL that will be contained in the e-mail to change the password. The register method will check and send the email. /** * @return void */ public function forgotPost(): void { $email = input()->post('email')->getValue(); $res = Auth::forgot('auth_users') ->columns('username') ->values($email, url('change')) ->register(); if ($res == true) { $this->message->new('forgot', 'Link sent to your email!'); response()->redirect(url('forgot')); } } Setting expiration time By default, the link sent is valid for 1 hour. You can change this behavior using the timeHash() method. Auth::forgot('auth_users') ->columns('username') ->values($email, url('change')) # Here the code ->timeHash('+2 hours') ->register(); Changing email fields By default, \"User\" is sent as the name of the sender and recipient. \"Forgot Password\" as the title of the email. To change these fields, use the fields() function. Auth::forgot('auth_users') ->columns('username') ->values($email, url('change')) # Here the code ->fields('name_sender', 'name_recipient', 'subject') ->register(); Changing default email If you need to change the default password recovery email, you must first use the generateLink() function. This function generates a new link in which the user will be redirected when changing the password. First, it is necessary to inform the user's email, the route he will access to change the password, and the length of time that this link will be valid. The code below shows an example of this use: $msg = \"<h1>Retrieve your password</h1>\"; $msg .= \"<p>Click the link below to change your password</p>\"; $msg .= \"<a href='\".generateLink($email, url('change'), '+2 hours').\"'>Change Here!!</a>\"; Auth::forgot('auth_users') ->columns('username') ->values($email, url('change')) # Here the code ->fields('name_sender', 'name_recipient', 'subject', $msg) ->register(); Validade link To validate the information by clicking on the email link, you can use the structure below: /** * @param string $hash * * @return void */ public function change($hash): void { $res = Hash::decrypt($hash)->isValid(); if ($res == true) { $email = Hash::decrypt($hash)->value(); return view('auth.change-pass-form', [ 'title' => 'Change Password', 'email' => $email, 'hash' => $hash ]); } else { $this->message->new('login', 'The informed link has already expired!'); response()->redirect(url('auth')); } } Changing the password This procedure uses the change method to define the database table. The columns method defines the database user and password fields. The values method defines the user's email in the first parameter, and the new password in the second parameter. The register method will check and change the email. Auth::change('auth_users') ->columns('username', 'password') ->values($email, $pass) ->register(); Password recovery structure You can create a predefined password recovery framework. To do so, use the php vinci auth:skeleton --forgot command. This command creates a controller with the name ForgotController . With it you will have all the basis to create a password recovery system. If you want to remove this structure, use php vinci auth:skeleton --forgot --remove .","title":"Recovery Password"},{"location":"recovery-password/#setting","text":"This procedure uses the forgot method to define the database table. The columns method the form's email field. In the values method, the e-mail that will be sent the recovery link is informed in the first parameter, and in the second parameter the URL that will be contained in the e-mail to change the password. The register method will check and send the email. /** * @return void */ public function forgotPost(): void { $email = input()->post('email')->getValue(); $res = Auth::forgot('auth_users') ->columns('username') ->values($email, url('change')) ->register(); if ($res == true) { $this->message->new('forgot', 'Link sent to your email!'); response()->redirect(url('forgot')); } }","title":"Setting"},{"location":"recovery-password/#setting-expiration-time","text":"By default, the link sent is valid for 1 hour. You can change this behavior using the timeHash() method. Auth::forgot('auth_users') ->columns('username') ->values($email, url('change')) # Here the code ->timeHash('+2 hours') ->register();","title":"Setting expiration time"},{"location":"recovery-password/#changing-email-fields","text":"By default, \"User\" is sent as the name of the sender and recipient. \"Forgot Password\" as the title of the email. To change these fields, use the fields() function. Auth::forgot('auth_users') ->columns('username') ->values($email, url('change')) # Here the code ->fields('name_sender', 'name_recipient', 'subject') ->register();","title":"Changing email fields"},{"location":"recovery-password/#changing-default-email","text":"If you need to change the default password recovery email, you must first use the generateLink() function. This function generates a new link in which the user will be redirected when changing the password. First, it is necessary to inform the user's email, the route he will access to change the password, and the length of time that this link will be valid. The code below shows an example of this use: $msg = \"<h1>Retrieve your password</h1>\"; $msg .= \"<p>Click the link below to change your password</p>\"; $msg .= \"<a href='\".generateLink($email, url('change'), '+2 hours').\"'>Change Here!!</a>\"; Auth::forgot('auth_users') ->columns('username') ->values($email, url('change')) # Here the code ->fields('name_sender', 'name_recipient', 'subject', $msg) ->register();","title":"Changing default email"},{"location":"recovery-password/#validade-link","text":"To validate the information by clicking on the email link, you can use the structure below: /** * @param string $hash * * @return void */ public function change($hash): void { $res = Hash::decrypt($hash)->isValid(); if ($res == true) { $email = Hash::decrypt($hash)->value(); return view('auth.change-pass-form', [ 'title' => 'Change Password', 'email' => $email, 'hash' => $hash ]); } else { $this->message->new('login', 'The informed link has already expired!'); response()->redirect(url('auth')); } }","title":"Validade link"},{"location":"recovery-password/#changing-the-password","text":"This procedure uses the change method to define the database table. The columns method defines the database user and password fields. The values method defines the user's email in the first parameter, and the new password in the second parameter. The register method will check and change the email. Auth::change('auth_users') ->columns('username', 'password') ->values($email, $pass) ->register();","title":"Changing the password"},{"location":"recovery-password/#password-recovery-structure","text":"You can create a predefined password recovery framework. To do so, use the php vinci auth:skeleton --forgot command. This command creates a controller with the name ForgotController . With it you will have all the basis to create a password recovery system. If you want to remove this structure, use php vinci auth:skeleton --forgot --remove .","title":"Password recovery structure"},{"location":"routes/","text":"Basic routing Below is a very basic example of setting up a route. First parameter is the url which the route should match - next parameter is a Closure or callback function that will be triggered once the route matches. Course::get('/', function() { return 'Hello world'; }); Available methods Here you can see a list over all available routes: Course::get($url, $callback, $settings); Course::post($url, $callback, $settings); Course::put($url, $callback, $settings); Course::patch($url, $callback, $settings); Course::delete($url, $callback, $settings); Course::options($url, $callback, $settings); Multiple HTTP-verbs Sometimes you might need to create a route that accepts multiple HTTP-verbs. If you need to match all HTTP-verbs you can use the any method. Course::match(['get', 'post'], '/', function() { // ... }); Course::any('foo', function() { // ... }); We've created a simple method which matches GET and POST which is most commonly used: Course::form('foo', function() { // ... }); Default Base Path This will allows users to set a default basepath for all url requests, which will be prepended to all url parameters. Course::setDefaultBasepath('/forum') Route parameters Required parameters You'll properly wondering by know how you parse parameters from your urls. For example, you might want to capture the users id from an url. You can do so by defining route-parameters. Course::get('/user/{id}', function ($userId) { return 'User with id: ' . $userId; }); You may define as many route parameters as required by your route: Course::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) { // ... }); Note: Route parameters are always encased within {} braces and should consist of alphabetic characters. Route parameters may not contain a - character. Use an underscore _ instead. Optional parameters Occasionally you may need to specify a route parameter, but make the presence of that route parameter optional. You may do so by placing a ? mark after the parameter name. Make sure to give the route's corresponding variable a default value: Course::get('/user/{name?}', function ($name = null) { return $name; }); Course::get('/user/{name?}', function ($name = 'Simon') { return $name; }); Regular expression constraints You may constrain the format of your route parameters using the where method on a route instance. The where method accepts the name of the parameter and a regular expression defining how the parameter should be constrained: Course::get('/user/{name}', function ($name) { // ... do stuff })->where('name', '[A-Za-z]+'); Course::get('/user/{id}', function ($id) { // ... do stuff })->where('id', '[0-9]+'); Course::get('/user/{id}/{name}', function ($id, $name) { // ... do stuff })->where(['id' => '[0-9]+', 'name' => '[a-z]+']); Regular expression route-match You can define a regular-expression match for the entire route if you wish. This is useful if you for example are creating a model-box which loads urls from ajax. The example below is using the following regular expression: /ajax/([\\w]+)/?([0-9]+)?/? which basically just matches /ajax/ and exspects the next parameter to be a string - and the next to be a number (but optional). Matches: /ajax/abc/ , /ajax/abc/123/ Won't match: /ajax/ Match groups specified in the regex will be passed on as parameters: Course::all('/ajax/abc/123', function($param1, $param2) { // param1 = abc // param2 = 123 })->setMatch('/\\/ajax\\/([\\w]+)\\/?([0-9]+)?\\/?/is'); Custom regex for matching parameters By default Solital uses the \\w regular expression when matching parameters. This decision was made with speed and reliability in mind, as this match will match both letters, number and most of the used symbols on the internet. However, sometimes it can be necessary to add a custom regular expression to match more advanced characters like - etc. Instead of adding a custom regular expression to all your parameters, you can simply add a global regular expression which will be used on all the parameters on the route. Note: If you the regular expression to be available across, we recommend using the global parameter on a group as demonstrated in the examples below. Example This example will ensure that all parameters use the [\\w\\-]+ regular expression when parsing. Course::get('/path/{parameter}', 'VideoController@home', ['defaultParameterRegex' => '[\\w\\-]+']); You can also apply this setting to a group if you need multiple routes to use your custom regular expression when parsing parameters. Course::group(['defaultParameterRegex' => '[\\w\\-]+'], function() { Course::get('/path/{parameter}', 'VideoController@home'); }); Named routes Named routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route by chaining the name method onto the route definition: Course::get('/user/profile', function () { // Your code here })->name('profile'); You can also specify names for Controller-actions: Course::get('/user/profile', 'UserController@profile')->name('profile'); Generating URLs To Named Routes Once you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via the global url helper-function (see helpers section): // Generating URLs... $url = url('profile'); If the named route defines parameters, you may pass the parameters as the second argument to the url function. The given parameters will automatically be inserted into the URL in their correct positions: Course::get('/user/{id}/profile', function ($id) { // })->name('profile'); $url = url('profile', ['id' => 1]); For more information on urls, please see the Urls section. Router groups Route groups allow you to share route attributes, such as middleware or namespaces, across a large number of routes without needing to define those attributes on each individual route. Shared attributes are specified in an array format as the first parameter to the Course::group method. Namespaces Solital already has the default namespace to search for controllers ( Solital\\Components\\Controller ) Note Group namespaces will only be added to routes with relative callbacks. For example if your route has an absolute callback like UserController@home , the namespace from the route will not be prepended. To fix this you can make the callback relative by removing the \\ in the beginning of the callback. Course::group(['namespace' => 'Admin'], function () { // Controllers Within The \"App\\Http\\Controllers\\Admin\" Namespace }); Subdomain-routing Route groups may also be used to handle sub-domain routing. Sub-domains may be assigned route parameters just like route urls, allowing you to capture a portion of the sub-domain for usage in your route or controller. The sub-domain may be specified using the domain key on the group attribute array: Course::group(['domain' => '{account}.myapp.com'], function () { Course::get('/user/{id}', function ($account, $id) { // }); }); Route prefixes The prefix group attribute may be used to prefix each route in the group with a given url. For example, you may want to prefix all route urls within the group with admin : Course::group(['prefix' => '/admin'], function () { Course::get('/users', function () { // Matches The \"/admin/users\" URL }); }); Partial groups Partial router groups has the same benefits as a normal group, but supports parameters and are only rendered once the url has matched. This can be extremely useful in situations, where you only want special routes to be added, when a certain criteria or logic has been met. NOTE: Use partial groups with caution as routes added within are only rendered and available once the url of the partial-group has matched. This can cause url() not to find urls for the routes added within. Example: Course::partialGroup('/admin/{applicationId}', function ($applicationId) { Course::get('/', function($applicationId) { // Matches The \"/admin/applicationId\" URL }); }); Exception ExceptionHandler are classes that handles all exceptions. ExceptionsHandlers must implement the ExceptionHandlerInterface interface. Error route If a given route does not exist in your routers.php file, you can redirect to another route instead of displaying the route not found error using the error() method. If true , the redirection will be done. If false , you will not be redirected. Course::error(true, '/error'); Course::get('/error', function () { echo 'error 404'; }); URL Rewriting Changing current route Sometimes it can be useful to manipulate the route about to be loaded. Solital allows you to easily manipulate and change the routes which are about to be rendered. All information about the current route is stored in the \\Solital\\Core\\Course\\Router instance's loadedRoute property. For easy access you can use the shortcut helper function request() instead of calling the class directly \\Solital\\Core\\Course\\Course::router() . request()->setRewriteCallback('Example\\MyCustomClass@hello'); // -- or you can rewrite by url -- request()->setRewriteUrl('/my-rewrite-url'); Bootmanager: loading routes dynamically Sometimes it can be necessary to keep urls stored in the database, file or similar. In this example, we want the url /my-cat-is-beatiful to load the route /article/view/1 which the router knows, because it's defined in the routes.php file. To interfere with the router, we create a class that implements the RouterBootManagerInterface interface. This class will be loaded before any other rules in routes.php and allow us to \"change\" the current route, if any of our criteria are fulfilled (like coming from the url /my-cat-is-beatiful ). use Solital\\Core\\Http\\Request; use Solital\\Core\\Course\\RouterBootManagerInterface; use Solital\\Core\\Course\\Router; class CustomRouterRules implements RouterBootManagerInterface { /** * Called when router is booting and before the routes is loaded. * * @param \\Solital\\Core\\Course\\Router $router * @param \\Solital\\Core\\Http\\Request $request */ public function boot(\\Solital\\Core\\Course\\Router $router, \\Solital\\Core\\Http\\Request $request): void { $rewriteRules = [ '/my-cat-is-beatiful' => '/article/view/1', '/horses-are-great' => '/article/view/2', ]; foreach ($rewriteRules as $url => $rule) { // If the current url matches the rewrite url, we use our custom route if ($request->getUri()->getPath() === $url) { $request->setRewriteUrl($rule); } } } } The above should be pretty self-explanatory and can easily be changed to loop through urls store in the database, file or cache. What happens is that if the current route matches the route defined in the index of our $rewriteRules array, we set the route to the array value instead. By doing this the route will now load the url /article/view/1 instead of /my-cat-is-beatiful . The last thing we need to do, is to add our custom boot-manager to the routes.php file. You can create as many bootmanagers as you like and easily add them in your routes.php file. Course::addBootManager(new CustomRouterRules()); Adding routes manually The Course class referenced in the previous example, is just a simple helper class that knows how to communicate with the Router class. If you are up for a challenge, want the full control or simply just want to create your own Router helper class, this example is for you. use \\Solital\\Core\\Course\\Router; use \\Solital\\Core\\Course\\Route\\RouteUrl; /* Create new Router instance */ $router = new Router(); $route = new RouteUrl('/answer/1', function() { die('this callback will match /answer/1'); }); $route->addMiddleware(\\Demo\\Middlewares\\AuthMiddleware::class); $route->setNamespace('\\Demo\\Controllers'); $route->setPrefix('v1'); /* Add the route to the router */ $router->addRoute($route); Extending This is a simple example of an integration into a framework. The framework has it's own Router class which inherits from the Course class. This allows the framework to add custom functionality like loading a custom routes.php file or add debugging information etc. namespace Demo; use Solital\\Core\\Course\\Course; class Router extends Course { public static function start() { // change default namespace for all routes parent::setDefaultNamespace('\\Demo\\Controllers'); // change this to whatever makes sense in your project require_once 'routes.php'; // Do initial stuff parent::start(); } } Form Method Spoofing HTML forms do not support PUT , PATCH or DELETE actions. Therefore, when defining the PUT , PATCH or DELETE routes that are called from an HTML form, you will need to use the spoofing helper to add a hidden _method field to the form. The value sent with the _method field will be used as the HTTP request method: <form method=\"post\" action=\"{{ url() }}\"> {{ spoofing('put'); }} <!-- other input elements here --> </form> Accessing The Current Route You can access information about the current route loaded by using the following method: Course::request()->getLoadedRoute(); request()->getLoadedRoute(); Other examples You can find many other examples in the sample file below: <?php use Solital\\Core\\Course\\Course; /* Adding custom csrfVerifier here */ Course::csrfVerifier(new \\Demo\\Middlewares\\CsrfVerifier()); Course::group(['middleware' => \\Demo\\Middlewares\\Site::class, 'exceptionHandler' => \\Demo\\Handlers\\CustomExceptionHandler::class], function() { Course::get('/answers/{id}', 'ControllerAnswers@show', ['where' => ['id' => '[0-9]+']]); /** * Restful resource (see IRestController interface for available methods) */ Course::resource('/rest', ControllerRessource::class); /** * Load the entire controller (where url matches method names - getIndex(), postIndex(), putIndex()). * The url paths will determine which method to render. * * For example: * * GET /animals => getIndex() * GET /animals/view => getView() * POST /animals/save => postSave() * * etc. */ Course::controller('/animals', ControllerAnimals::class); }); Course::get('/page/404', 'ControllerPage@notFound', ['as' => 'page.notfound']);","title":"Routes"},{"location":"routes/#basic-routing","text":"Below is a very basic example of setting up a route. First parameter is the url which the route should match - next parameter is a Closure or callback function that will be triggered once the route matches. Course::get('/', function() { return 'Hello world'; });","title":"Basic routing"},{"location":"routes/#available-methods","text":"Here you can see a list over all available routes: Course::get($url, $callback, $settings); Course::post($url, $callback, $settings); Course::put($url, $callback, $settings); Course::patch($url, $callback, $settings); Course::delete($url, $callback, $settings); Course::options($url, $callback, $settings);","title":"Available methods"},{"location":"routes/#multiple-http-verbs","text":"Sometimes you might need to create a route that accepts multiple HTTP-verbs. If you need to match all HTTP-verbs you can use the any method. Course::match(['get', 'post'], '/', function() { // ... }); Course::any('foo', function() { // ... }); We've created a simple method which matches GET and POST which is most commonly used: Course::form('foo', function() { // ... });","title":"Multiple HTTP-verbs"},{"location":"routes/#default-base-path","text":"This will allows users to set a default basepath for all url requests, which will be prepended to all url parameters. Course::setDefaultBasepath('/forum')","title":"Default Base Path"},{"location":"routes/#route-parameters","text":"","title":"Route parameters"},{"location":"routes/#required-parameters","text":"You'll properly wondering by know how you parse parameters from your urls. For example, you might want to capture the users id from an url. You can do so by defining route-parameters. Course::get('/user/{id}', function ($userId) { return 'User with id: ' . $userId; }); You may define as many route parameters as required by your route: Course::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) { // ... }); Note: Route parameters are always encased within {} braces and should consist of alphabetic characters. Route parameters may not contain a - character. Use an underscore _ instead.","title":"Required parameters"},{"location":"routes/#optional-parameters","text":"Occasionally you may need to specify a route parameter, but make the presence of that route parameter optional. You may do so by placing a ? mark after the parameter name. Make sure to give the route's corresponding variable a default value: Course::get('/user/{name?}', function ($name = null) { return $name; }); Course::get('/user/{name?}', function ($name = 'Simon') { return $name; });","title":"Optional parameters"},{"location":"routes/#regular-expression-constraints","text":"You may constrain the format of your route parameters using the where method on a route instance. The where method accepts the name of the parameter and a regular expression defining how the parameter should be constrained: Course::get('/user/{name}', function ($name) { // ... do stuff })->where('name', '[A-Za-z]+'); Course::get('/user/{id}', function ($id) { // ... do stuff })->where('id', '[0-9]+'); Course::get('/user/{id}/{name}', function ($id, $name) { // ... do stuff })->where(['id' => '[0-9]+', 'name' => '[a-z]+']);","title":"Regular expression constraints"},{"location":"routes/#regular-expression-route-match","text":"You can define a regular-expression match for the entire route if you wish. This is useful if you for example are creating a model-box which loads urls from ajax. The example below is using the following regular expression: /ajax/([\\w]+)/?([0-9]+)?/? which basically just matches /ajax/ and exspects the next parameter to be a string - and the next to be a number (but optional). Matches: /ajax/abc/ , /ajax/abc/123/ Won't match: /ajax/ Match groups specified in the regex will be passed on as parameters: Course::all('/ajax/abc/123', function($param1, $param2) { // param1 = abc // param2 = 123 })->setMatch('/\\/ajax\\/([\\w]+)\\/?([0-9]+)?\\/?/is');","title":"Regular expression route-match"},{"location":"routes/#custom-regex-for-matching-parameters","text":"By default Solital uses the \\w regular expression when matching parameters. This decision was made with speed and reliability in mind, as this match will match both letters, number and most of the used symbols on the internet. However, sometimes it can be necessary to add a custom regular expression to match more advanced characters like - etc. Instead of adding a custom regular expression to all your parameters, you can simply add a global regular expression which will be used on all the parameters on the route. Note: If you the regular expression to be available across, we recommend using the global parameter on a group as demonstrated in the examples below.","title":"Custom regex for matching parameters"},{"location":"routes/#example","text":"This example will ensure that all parameters use the [\\w\\-]+ regular expression when parsing. Course::get('/path/{parameter}', 'VideoController@home', ['defaultParameterRegex' => '[\\w\\-]+']); You can also apply this setting to a group if you need multiple routes to use your custom regular expression when parsing parameters. Course::group(['defaultParameterRegex' => '[\\w\\-]+'], function() { Course::get('/path/{parameter}', 'VideoController@home'); });","title":"Example"},{"location":"routes/#named-routes","text":"Named routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route by chaining the name method onto the route definition: Course::get('/user/profile', function () { // Your code here })->name('profile'); You can also specify names for Controller-actions: Course::get('/user/profile', 'UserController@profile')->name('profile');","title":"Named routes"},{"location":"routes/#generating-urls-to-named-routes","text":"Once you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via the global url helper-function (see helpers section): // Generating URLs... $url = url('profile'); If the named route defines parameters, you may pass the parameters as the second argument to the url function. The given parameters will automatically be inserted into the URL in their correct positions: Course::get('/user/{id}/profile', function ($id) { // })->name('profile'); $url = url('profile', ['id' => 1]); For more information on urls, please see the Urls section.","title":"Generating URLs To Named Routes"},{"location":"routes/#router-groups","text":"Route groups allow you to share route attributes, such as middleware or namespaces, across a large number of routes without needing to define those attributes on each individual route. Shared attributes are specified in an array format as the first parameter to the Course::group method.","title":"Router groups"},{"location":"routes/#namespaces","text":"Solital already has the default namespace to search for controllers ( Solital\\Components\\Controller )","title":"Namespaces"},{"location":"routes/#note","text":"Group namespaces will only be added to routes with relative callbacks. For example if your route has an absolute callback like UserController@home , the namespace from the route will not be prepended. To fix this you can make the callback relative by removing the \\ in the beginning of the callback. Course::group(['namespace' => 'Admin'], function () { // Controllers Within The \"App\\Http\\Controllers\\Admin\" Namespace });","title":"Note"},{"location":"routes/#subdomain-routing","text":"Route groups may also be used to handle sub-domain routing. Sub-domains may be assigned route parameters just like route urls, allowing you to capture a portion of the sub-domain for usage in your route or controller. The sub-domain may be specified using the domain key on the group attribute array: Course::group(['domain' => '{account}.myapp.com'], function () { Course::get('/user/{id}', function ($account, $id) { // }); });","title":"Subdomain-routing"},{"location":"routes/#route-prefixes","text":"The prefix group attribute may be used to prefix each route in the group with a given url. For example, you may want to prefix all route urls within the group with admin : Course::group(['prefix' => '/admin'], function () { Course::get('/users', function () { // Matches The \"/admin/users\" URL }); });","title":"Route prefixes"},{"location":"routes/#partial-groups","text":"Partial router groups has the same benefits as a normal group, but supports parameters and are only rendered once the url has matched. This can be extremely useful in situations, where you only want special routes to be added, when a certain criteria or logic has been met. NOTE: Use partial groups with caution as routes added within are only rendered and available once the url of the partial-group has matched. This can cause url() not to find urls for the routes added within. Example: Course::partialGroup('/admin/{applicationId}', function ($applicationId) { Course::get('/', function($applicationId) { // Matches The \"/admin/applicationId\" URL }); });","title":"Partial groups"},{"location":"routes/#exception","text":"ExceptionHandler are classes that handles all exceptions. ExceptionsHandlers must implement the ExceptionHandlerInterface interface.","title":"Exception"},{"location":"routes/#error-route","text":"If a given route does not exist in your routers.php file, you can redirect to another route instead of displaying the route not found error using the error() method. If true , the redirection will be done. If false , you will not be redirected. Course::error(true, '/error'); Course::get('/error', function () { echo 'error 404'; });","title":"Error route"},{"location":"routes/#url-rewriting","text":"","title":"URL Rewriting"},{"location":"routes/#changing-current-route","text":"Sometimes it can be useful to manipulate the route about to be loaded. Solital allows you to easily manipulate and change the routes which are about to be rendered. All information about the current route is stored in the \\Solital\\Core\\Course\\Router instance's loadedRoute property. For easy access you can use the shortcut helper function request() instead of calling the class directly \\Solital\\Core\\Course\\Course::router() . request()->setRewriteCallback('Example\\MyCustomClass@hello'); // -- or you can rewrite by url -- request()->setRewriteUrl('/my-rewrite-url');","title":"Changing current route"},{"location":"routes/#bootmanager-loading-routes-dynamically","text":"Sometimes it can be necessary to keep urls stored in the database, file or similar. In this example, we want the url /my-cat-is-beatiful to load the route /article/view/1 which the router knows, because it's defined in the routes.php file. To interfere with the router, we create a class that implements the RouterBootManagerInterface interface. This class will be loaded before any other rules in routes.php and allow us to \"change\" the current route, if any of our criteria are fulfilled (like coming from the url /my-cat-is-beatiful ). use Solital\\Core\\Http\\Request; use Solital\\Core\\Course\\RouterBootManagerInterface; use Solital\\Core\\Course\\Router; class CustomRouterRules implements RouterBootManagerInterface { /** * Called when router is booting and before the routes is loaded. * * @param \\Solital\\Core\\Course\\Router $router * @param \\Solital\\Core\\Http\\Request $request */ public function boot(\\Solital\\Core\\Course\\Router $router, \\Solital\\Core\\Http\\Request $request): void { $rewriteRules = [ '/my-cat-is-beatiful' => '/article/view/1', '/horses-are-great' => '/article/view/2', ]; foreach ($rewriteRules as $url => $rule) { // If the current url matches the rewrite url, we use our custom route if ($request->getUri()->getPath() === $url) { $request->setRewriteUrl($rule); } } } } The above should be pretty self-explanatory and can easily be changed to loop through urls store in the database, file or cache. What happens is that if the current route matches the route defined in the index of our $rewriteRules array, we set the route to the array value instead. By doing this the route will now load the url /article/view/1 instead of /my-cat-is-beatiful . The last thing we need to do, is to add our custom boot-manager to the routes.php file. You can create as many bootmanagers as you like and easily add them in your routes.php file. Course::addBootManager(new CustomRouterRules());","title":"Bootmanager: loading routes dynamically"},{"location":"routes/#adding-routes-manually","text":"The Course class referenced in the previous example, is just a simple helper class that knows how to communicate with the Router class. If you are up for a challenge, want the full control or simply just want to create your own Router helper class, this example is for you. use \\Solital\\Core\\Course\\Router; use \\Solital\\Core\\Course\\Route\\RouteUrl; /* Create new Router instance */ $router = new Router(); $route = new RouteUrl('/answer/1', function() { die('this callback will match /answer/1'); }); $route->addMiddleware(\\Demo\\Middlewares\\AuthMiddleware::class); $route->setNamespace('\\Demo\\Controllers'); $route->setPrefix('v1'); /* Add the route to the router */ $router->addRoute($route);","title":"Adding routes manually"},{"location":"routes/#extending","text":"This is a simple example of an integration into a framework. The framework has it's own Router class which inherits from the Course class. This allows the framework to add custom functionality like loading a custom routes.php file or add debugging information etc. namespace Demo; use Solital\\Core\\Course\\Course; class Router extends Course { public static function start() { // change default namespace for all routes parent::setDefaultNamespace('\\Demo\\Controllers'); // change this to whatever makes sense in your project require_once 'routes.php'; // Do initial stuff parent::start(); } }","title":"Extending"},{"location":"routes/#form-method-spoofing","text":"HTML forms do not support PUT , PATCH or DELETE actions. Therefore, when defining the PUT , PATCH or DELETE routes that are called from an HTML form, you will need to use the spoofing helper to add a hidden _method field to the form. The value sent with the _method field will be used as the HTTP request method: <form method=\"post\" action=\"{{ url() }}\"> {{ spoofing('put'); }} <!-- other input elements here --> </form>","title":"Form Method Spoofing"},{"location":"routes/#accessing-the-current-route","text":"You can access information about the current route loaded by using the following method: Course::request()->getLoadedRoute(); request()->getLoadedRoute();","title":"Accessing The Current Route"},{"location":"routes/#other-examples","text":"You can find many other examples in the sample file below: <?php use Solital\\Core\\Course\\Course; /* Adding custom csrfVerifier here */ Course::csrfVerifier(new \\Demo\\Middlewares\\CsrfVerifier()); Course::group(['middleware' => \\Demo\\Middlewares\\Site::class, 'exceptionHandler' => \\Demo\\Handlers\\CustomExceptionHandler::class], function() { Course::get('/answers/{id}', 'ControllerAnswers@show', ['where' => ['id' => '[0-9]+']]); /** * Restful resource (see IRestController interface for available methods) */ Course::resource('/rest', ControllerRessource::class); /** * Load the entire controller (where url matches method names - getIndex(), postIndex(), putIndex()). * The url paths will determine which method to render. * * For example: * * GET /animals => getIndex() * GET /animals/view => getView() * POST /animals/save => postSave() * * etc. */ Course::controller('/animals', ControllerAnimals::class); }); Course::get('/page/404', 'ControllerPage@notFound', ['as' => 'page.notfound']);","title":"Other examples"},{"location":"secure-password/","text":"Introduction \u201cSince 2017, NIST recommends using a secret input when hashing memorized secrets such as passwords. By mixing in a secret input (commonly called a \"pepper\"), one prevents an attacker from brute-forcing the password hashes altogether, even if they have the hash and salt. For example, an SQL injection typically affects only the database, not files on disk, so a pepper stored in a config file would still be out of reach for the attacker. A pepper must be randomly generated once and can be the same for all users. Many password leaks could have been made completely useless if site owners had done this. Since there is no pepper parameter for password_hash (even though Argon2 has a \"secret\" parameter, PHP does not allow to set it), the correct way to mix in a pepper is to use hash_hmac().\u201d php.net Solital uses the SecurePassword package to validate passwords and prevent attacks. That is, even if someone manages to access the hash created with this package, using only the native password_verify function WILL NOT return true . Customizing the password To change the type of algorithm used in encryption, the cost, among other options, you can edit the auth.yaml file. password: algorithm: default # default - argon2 - argon2d pepper: b3f952d5d9adea6f63bee9d4c6fceeaa cost: 10 memory_cost: '' time_cost: '' threads: '' In the algorithm key, you can add the following values: default , argon2 and argon2d . For more information about other PHP constants, see this link . Changing the value of \u201cpepper\u201d As mentioned in the introduction, the SecurePassword package uses a \u201cpepper\u201d value. To change the value of this pepper, you can edit the value of the peeper key in the auth.yaml file. NOTE: Don't change the value of this key too often, as you will need to create a new password each time this value changes. Change only if necessary or if your project is just starting.","title":"Secure Password"},{"location":"secure-password/#introduction","text":"\u201cSince 2017, NIST recommends using a secret input when hashing memorized secrets such as passwords. By mixing in a secret input (commonly called a \"pepper\"), one prevents an attacker from brute-forcing the password hashes altogether, even if they have the hash and salt. For example, an SQL injection typically affects only the database, not files on disk, so a pepper stored in a config file would still be out of reach for the attacker. A pepper must be randomly generated once and can be the same for all users. Many password leaks could have been made completely useless if site owners had done this. Since there is no pepper parameter for password_hash (even though Argon2 has a \"secret\" parameter, PHP does not allow to set it), the correct way to mix in a pepper is to use hash_hmac().\u201d php.net Solital uses the SecurePassword package to validate passwords and prevent attacks. That is, even if someone manages to access the hash created with this package, using only the native password_verify function WILL NOT return true .","title":"Introduction"},{"location":"secure-password/#customizing-the-password","text":"To change the type of algorithm used in encryption, the cost, among other options, you can edit the auth.yaml file. password: algorithm: default # default - argon2 - argon2d pepper: b3f952d5d9adea6f63bee9d4c6fceeaa cost: 10 memory_cost: '' time_cost: '' threads: '' In the algorithm key, you can add the following values: default , argon2 and argon2d . For more information about other PHP constants, see this link .","title":"Customizing the password"},{"location":"secure-password/#changing-the-value-of-pepper","text":"As mentioned in the introduction, the SecurePassword package uses a \u201cpepper\u201d value. To change the value of this pepper, you can edit the value of the peeper key in the auth.yaml file. NOTE: Don't change the value of this key too often, as you will need to create a new password each time this value changes. Change only if necessary or if your project is just starting.","title":"Changing the value of \u201cpepper\u201d"},{"location":"seeders/","text":"Introduction A seeder is a special class used to generate and insert sample data (seeds) into a database. This is an important feature in development environments, as it allows you to recreate the application with a fresh database, using sample values that you would otherwise have to manually enter each time the database was recreated. Creating Seeders To create a seeder, you will need to use the Vinci Console: php vinci create:seeder UserSeeder The command will generate a class similar to this: <?php use Solital\\Core\\Database\\Seeds\\Seeder; class UserSeed extends Seeder { /** * Run a Seed */ public function run() { // ... } } All code you create must be inside the run() method. Calling other Seeders You can call other seeders within a seeder. For that use the call() method. <?php use Solital\\Core\\Database\\Seeds\\Seeder; class UserSeed extends Seeder { /** * Run a Seed */ public function run() { $this->call(UserSecondSeed::class); $this->call(UserThirdSeed::class); } } Or use an array: public function run() { $this->call([ UserSecondSeed::class, UserThirdSeed::class ]); } Running Seeders To run the created Seeders, run the command: php vinci seeder The previous command runs all seeders. To run a specific seeder, use the --class option. php vinci seeder --class=UserSeeder","title":"Seeders"},{"location":"seeders/#introduction","text":"A seeder is a special class used to generate and insert sample data (seeds) into a database. This is an important feature in development environments, as it allows you to recreate the application with a fresh database, using sample values that you would otherwise have to manually enter each time the database was recreated.","title":"Introduction"},{"location":"seeders/#creating-seeders","text":"To create a seeder, you will need to use the Vinci Console: php vinci create:seeder UserSeeder The command will generate a class similar to this: <?php use Solital\\Core\\Database\\Seeds\\Seeder; class UserSeed extends Seeder { /** * Run a Seed */ public function run() { // ... } } All code you create must be inside the run() method. Calling other Seeders You can call other seeders within a seeder. For that use the call() method. <?php use Solital\\Core\\Database\\Seeds\\Seeder; class UserSeed extends Seeder { /** * Run a Seed */ public function run() { $this->call(UserSecondSeed::class); $this->call(UserThirdSeed::class); } } Or use an array: public function run() { $this->call([ UserSecondSeed::class, UserThirdSeed::class ]); }","title":"Creating Seeders"},{"location":"seeders/#running-seeders","text":"To run the created Seeders, run the command: php vinci seeder The previous command runs all seeders. To run a specific seeder, use the --class option. php vinci seeder --class=UserSeeder","title":"Running Seeders"},{"location":"session-and-cookie/","text":"Managing Cookies Static method This library provides a static method that is compatible to PHP\u2019s built-in setcookie(...) function but includes support for more recent features such as the SameSite attribute: use Solital\\Core\\Resource\\Cookie; Cookie::setcookie('SID', '31d4d96e407aad42'); // or Cookie::setcookie('SID', '31d4d96e407aad42', time() + 3600, '/~rasmus/', 'example.com', true, true, 'Lax'); Builder pattern Instances of the Cookie class let you build a cookie conveniently by setting individual properties. This class uses reasonable defaults that may differ from defaults of the setcookie function. $cookie = new Cookie('SID'); $cookie->setValue('31d4d96e407aad42'); $cookie->setMaxAge(60 * 60 * 24); // $cookie->setExpiryTime(time() + 60 * 60 * 24); $cookie->setPath('/~rasmus/'); $cookie->setDomain('example.com'); $cookie->setHttpOnly(true); $cookie->setSecureOnly(true); $cookie->setSameSiteRestriction('Strict'); // echo $cookie; // or $cookie->save(); // or // $cookie->saveAndSet(); The method calls can also be chained: (new Cookie('SID'))->setValue('31d4d96e407aad42')->setMaxAge(60 * 60 * 24)->setSameSiteRestriction('None')->save(); A cookie can later be deleted simply like this: $cookie->delete(); // or $cookie->deleteAndUnset(); Note: For the deletion to work, the cookie must have the same settings as the cookie that was originally saved \u2013 except for its value, which doesn\u2019t need to be set. So you should remember to pass appropriate values to setPath(...) , setDomain(...) , setHttpOnly(...) and setSecureOnly(...) again. Reading cookies Checking whether a cookie exists: Cookie::exists('first_visit'); Reading a cookie\u2019s value (with optional default value): Cookie::get('first_visit'); // or Cookie::get('first_visit', \\time()); Parsing cookies $cookieHeader = 'Set-Cookie: test=php.net; expires=Thu, 09-Jun-2016 16:30:32 GMT; Max-Age=3600; path=/~rasmus/; secure'; $cookieInstance = Cookie::parse($cookieHeader); Managing Sessions Using the Session class, you can start and resume sessions in a way that is compatible to PHP\u2019s built-in session_start() function, while having access to the improved cookie handling from this library as well: use Solital\\Core\\Resource\\Session; // start session and have session cookie with 'lax' same-site restriction Session::start(); // or Session::start('Lax'); // start session and have session cookie with 'strict' same-site restriction Session::start('Strict'); // start session and have session cookie without any same-site restriction Session::start(null); // or Session::start('None'); // Chrome 80+ All three calls respect the settings from PHP\u2019s session_set_cookie_params(...) function and the configuration options session.name , session.cookie_lifetime , session.cookie_path , session.cookie_domain , session.cookie_secure , session.cookie_httponly and session.use_cookies . Likewise, replacements for session_regenerate_id(); // and session_regenerate_id(true); are available via Session::regenerate(); // and Session::regenerate(true); if you want protection against session fixation attacks that comes with improved cookie handling. Additionally, access to the current internal session ID is provided via Session::id(); as a replacement for session_id(); Reading and writing session data Read a value from the session (with optional default value): $value = Session::get($key); # With helper $value = session($key); // or $value = Session::get($key, $defaultValue); # With helper $value = session($key, defaultValue: 'default_value'); Write a value to the session: Session::set($key, $value); # With helper session($key, $value); Check whether a value exists in the session: if (Session::has($key)) { // ... } Remove a value from the session: Session::delete($key); # With helper session($key, delete: true); Read and then immediately remove a value from the session: $value = Session::take($key); $value = Session::take($key, $defaultValue); # With helper $value = session($key, take: true); This is often useful for flash messages, e.g. in combination with the has(...) method.","title":"Session and Cookie"},{"location":"session-and-cookie/#managing-cookies","text":"","title":"Managing Cookies"},{"location":"session-and-cookie/#static-method","text":"This library provides a static method that is compatible to PHP\u2019s built-in setcookie(...) function but includes support for more recent features such as the SameSite attribute: use Solital\\Core\\Resource\\Cookie; Cookie::setcookie('SID', '31d4d96e407aad42'); // or Cookie::setcookie('SID', '31d4d96e407aad42', time() + 3600, '/~rasmus/', 'example.com', true, true, 'Lax');","title":"Static method"},{"location":"session-and-cookie/#builder-pattern","text":"Instances of the Cookie class let you build a cookie conveniently by setting individual properties. This class uses reasonable defaults that may differ from defaults of the setcookie function. $cookie = new Cookie('SID'); $cookie->setValue('31d4d96e407aad42'); $cookie->setMaxAge(60 * 60 * 24); // $cookie->setExpiryTime(time() + 60 * 60 * 24); $cookie->setPath('/~rasmus/'); $cookie->setDomain('example.com'); $cookie->setHttpOnly(true); $cookie->setSecureOnly(true); $cookie->setSameSiteRestriction('Strict'); // echo $cookie; // or $cookie->save(); // or // $cookie->saveAndSet(); The method calls can also be chained: (new Cookie('SID'))->setValue('31d4d96e407aad42')->setMaxAge(60 * 60 * 24)->setSameSiteRestriction('None')->save(); A cookie can later be deleted simply like this: $cookie->delete(); // or $cookie->deleteAndUnset(); Note: For the deletion to work, the cookie must have the same settings as the cookie that was originally saved \u2013 except for its value, which doesn\u2019t need to be set. So you should remember to pass appropriate values to setPath(...) , setDomain(...) , setHttpOnly(...) and setSecureOnly(...) again.","title":"Builder pattern"},{"location":"session-and-cookie/#reading-cookies","text":"Checking whether a cookie exists: Cookie::exists('first_visit'); Reading a cookie\u2019s value (with optional default value): Cookie::get('first_visit'); // or Cookie::get('first_visit', \\time());","title":"Reading cookies"},{"location":"session-and-cookie/#parsing-cookies","text":"$cookieHeader = 'Set-Cookie: test=php.net; expires=Thu, 09-Jun-2016 16:30:32 GMT; Max-Age=3600; path=/~rasmus/; secure'; $cookieInstance = Cookie::parse($cookieHeader);","title":"Parsing cookies"},{"location":"session-and-cookie/#managing-sessions","text":"Using the Session class, you can start and resume sessions in a way that is compatible to PHP\u2019s built-in session_start() function, while having access to the improved cookie handling from this library as well: use Solital\\Core\\Resource\\Session; // start session and have session cookie with 'lax' same-site restriction Session::start(); // or Session::start('Lax'); // start session and have session cookie with 'strict' same-site restriction Session::start('Strict'); // start session and have session cookie without any same-site restriction Session::start(null); // or Session::start('None'); // Chrome 80+ All three calls respect the settings from PHP\u2019s session_set_cookie_params(...) function and the configuration options session.name , session.cookie_lifetime , session.cookie_path , session.cookie_domain , session.cookie_secure , session.cookie_httponly and session.use_cookies . Likewise, replacements for session_regenerate_id(); // and session_regenerate_id(true); are available via Session::regenerate(); // and Session::regenerate(true); if you want protection against session fixation attacks that comes with improved cookie handling. Additionally, access to the current internal session ID is provided via Session::id(); as a replacement for session_id();","title":"Managing Sessions"},{"location":"session-and-cookie/#reading-and-writing-session-data","text":"Read a value from the session (with optional default value): $value = Session::get($key); # With helper $value = session($key); // or $value = Session::get($key, $defaultValue); # With helper $value = session($key, defaultValue: 'default_value'); Write a value to the session: Session::set($key, $value); # With helper session($key, $value); Check whether a value exists in the session: if (Session::has($key)) { // ... } Remove a value from the session: Session::delete($key); # With helper session($key, delete: true); Read and then immediately remove a value from the session: $value = Session::take($key); $value = Session::take($key, $defaultValue); # With helper $value = session($key, take: true); This is often useful for flash messages, e.g. in combination with the has(...) method.","title":"Reading and writing session data"},{"location":"string-manipulate/","text":"This will make living with PHP strings easier by; - providing a simple chained API to string operations - not mixing up the needle haystack stuff - allowing you to extend and add your own methods in seconds $text = 'Something to translate'; $text = strtr($text, $translation); $text = htmlspecialchars($text); $text = nl2br($text); echo $text; Str objects allow you this; use Solital\\Core\\Resource\\Str\\Str; echo (new Str('Something to translate')) ->translate($translation) ->chars() ->nl2br(); // Or use a helper `str()` echo str('Something to translate') ->translate($translation) ->chars() ->nl2br(); value() Returns the current value of this string $str = new Str('foo'); echo $str->value(); addCslashes() Quote string with slashes in a C style $str = new Str('testescape'); $str->addCslashes('acep'); echo $str->value(); addSlashes() Quote string with slashes $str = new Str(\"aa'bb\"); $str->addSlashes(); echo $str->value(); chunkSplit() Splits the string into smaller chunks $str = new Str('foobar'); $str->chunkSplit(2, ':'); echo $str->value(); compare() Binary safe string comparison. < 0 if this string is less than target string > 0 if this string is greater than target string == 0 if both strings are equal $str = new Str('my_string'); echo $str->compare('mystring'); compareInsensitive() Binary safe case-insensitive string comparison. < 0 if this string is less than target string > 0 if this string is greater than target string == 0 if both strings are equal $str = new Str('my_string'); echo $str->compareInsensitive('mystring'); concat() Appends another string to this string. $str = new Str('foo'); $str->concat('bar'); echo $str->value(); contains() Does current string contain a subtring? $str = new Str('my_string'); echo $str->contains('string'); countChars() Return information about characters used in a string. $str = new Str('abababcabc'); $res = $str->countChars(true); pre($res); explode() Splits current string by string. $str = new Str('but_Bar_is_never_Foo'); $res = $str->explode('_'); pre($res); implode() Join array elements with this string. $str = new Str('!'); $res = $str->implode(['foo', 'is', 'bar', 'sometimes']); pre($res); ireplace() Case-insensitive version of Str::replace(). $str = new Str('foo=bar'); $str->ireplace(['FOO' => 'bar']); echo $str->value(); ltrim() Strip whitespace (or other characters) from the beginning of a string. $str = new Str('_-_foo'); $str->ltrim('_-'); echo $str->value(); nl2br() Converts new lines to <br /> elements. $str = new Str([\"foo\\nbar\" . PHP_EOL, \"foo<br />\\nbar<br />\" . PHP_EOL]); $str->nl2br(); echo $str->value(); pad() Pad the string to a certain length with another string. $pad_length : If the value of pad_length is negative, less than, or equal to the length of current string, no padding takes place $pad_string : String to pad the current string with $pad_type : Optional, can be STR_PAD_RIGHT , STR_PAD_LEFT , or STR_PAD_BOTH . If $pad_type is not specified it is assumed to be STR_PAD_RIGHT $str = new Str('foo'); $str->pad(16, '-.-;', STR_PAD_RIGHT); echo $str->value(); position() Find the position of the first occurrence of a substring in a string. $str = new Str('foo is bar sometimes'); $str->position(' is ', 0); echo $str->value(); repeat() Repeats the string. $str = new Str('foo'); $str->repeat(5); echo $str->value(); replace() Replaces the occurences of keys with their values. $str = new Str('foo can be bar but foo does not have to'); $str->replace(['foo' => 'fOo', 'DoEs Not' => 'fail', 'to' => '2']); echo $str->value(); reverse() Reverses current string. $str = new Str('knitS raW pupilS regaL'); $str->reverse(); echo $str->value(); rot13() Perform the ROT13 transform on current string. The ROT13 encoding simply shifts every letter by 13 places in the alphabet while leaving non-alpha characters untouched. Encoding and decoding are done by the same function, passing an encoded string as argument will return the original version. $str = new Str('foobar'); $str->rot13(); echo $str->value(); rtrim() Strip whitespace (or other characters) from the end. $str = new Str('ofoooooo'); $str->rtrim('o'); echo $str->value(); shuffle() Randomly shuffles the string. $str = new Str('foo bar foobar pebkac fubar'); $original = $str->value(); $str->shuffle(); echo $str->value(); echo $original; specialchars() Convert special characters to HTML entities. $decode : If true , convert special HTML entities back to characters. $str = new Str('<p>This should <br>not be wrapped</p>'); $str->specialchars(); echo $str->value(); stripTags() Strip HTML and PHP tags. $allowable_tags : List of allowed tags. $str = new Str('<html><div><p><br/><br></p></div></html>'); $str->stripTags(); echo $str->value(); translate() Translate characters or replace substrings. $str = new Str(':foo :bar'); $str->translate([':foo' => ':bar', ':bar' => ':newbar']); echo $str->value(); trim() Strips whitespace (or other characters) from the beginning and end of the string. $str = new Str('offsoooooo'); $str->trim('o'); echo $str->value(); undo() Undoes the last $steps operations. $str = new Str(' foo is bar '); $str->rtrim(); $str->ltrim(); $str->replace(array(' is ' => '_is_')); $str->undo(1); echo $str->value(); uniqueChars() Returns a string containing all unique characters (in current string). $str = new Str('abcabdabcd'); $str->uniqueChars(); echo $str->value(); wordCount() Counts the number of words inside string. $charlist : Optional list of additional characters which will be considered as 'word'. $str = new Str('foo is here 3 times foo foo'); $str->wordCount(); echo $str->value(); word() Returns the list of words inside string. $charlist : Optional list of additional characters which will be considered as 'word'. $str = new Str('foo foo bar foo'); $str->word(); echo $str->value();","title":"Strings"},{"location":"string-manipulate/#value","text":"Returns the current value of this string $str = new Str('foo'); echo $str->value();","title":"value()"},{"location":"string-manipulate/#addcslashes","text":"Quote string with slashes in a C style $str = new Str('testescape'); $str->addCslashes('acep'); echo $str->value();","title":"addCslashes()"},{"location":"string-manipulate/#addslashes","text":"Quote string with slashes $str = new Str(\"aa'bb\"); $str->addSlashes(); echo $str->value();","title":"addSlashes()"},{"location":"string-manipulate/#chunksplit","text":"Splits the string into smaller chunks $str = new Str('foobar'); $str->chunkSplit(2, ':'); echo $str->value();","title":"chunkSplit()"},{"location":"string-manipulate/#compare","text":"Binary safe string comparison. < 0 if this string is less than target string > 0 if this string is greater than target string == 0 if both strings are equal $str = new Str('my_string'); echo $str->compare('mystring');","title":"compare()"},{"location":"string-manipulate/#compareinsensitive","text":"Binary safe case-insensitive string comparison. < 0 if this string is less than target string > 0 if this string is greater than target string == 0 if both strings are equal $str = new Str('my_string'); echo $str->compareInsensitive('mystring');","title":"compareInsensitive()"},{"location":"string-manipulate/#concat","text":"Appends another string to this string. $str = new Str('foo'); $str->concat('bar'); echo $str->value();","title":"concat()"},{"location":"string-manipulate/#contains","text":"Does current string contain a subtring? $str = new Str('my_string'); echo $str->contains('string');","title":"contains()"},{"location":"string-manipulate/#countchars","text":"Return information about characters used in a string. $str = new Str('abababcabc'); $res = $str->countChars(true); pre($res);","title":"countChars()"},{"location":"string-manipulate/#explode","text":"Splits current string by string. $str = new Str('but_Bar_is_never_Foo'); $res = $str->explode('_'); pre($res);","title":"explode()"},{"location":"string-manipulate/#implode","text":"Join array elements with this string. $str = new Str('!'); $res = $str->implode(['foo', 'is', 'bar', 'sometimes']); pre($res);","title":"implode()"},{"location":"string-manipulate/#ireplace","text":"Case-insensitive version of Str::replace(). $str = new Str('foo=bar'); $str->ireplace(['FOO' => 'bar']); echo $str->value();","title":"ireplace()"},{"location":"string-manipulate/#ltrim","text":"Strip whitespace (or other characters) from the beginning of a string. $str = new Str('_-_foo'); $str->ltrim('_-'); echo $str->value();","title":"ltrim()"},{"location":"string-manipulate/#nl2br","text":"Converts new lines to <br /> elements. $str = new Str([\"foo\\nbar\" . PHP_EOL, \"foo<br />\\nbar<br />\" . PHP_EOL]); $str->nl2br(); echo $str->value();","title":"nl2br()"},{"location":"string-manipulate/#pad","text":"Pad the string to a certain length with another string. $pad_length : If the value of pad_length is negative, less than, or equal to the length of current string, no padding takes place $pad_string : String to pad the current string with $pad_type : Optional, can be STR_PAD_RIGHT , STR_PAD_LEFT , or STR_PAD_BOTH . If $pad_type is not specified it is assumed to be STR_PAD_RIGHT $str = new Str('foo'); $str->pad(16, '-.-;', STR_PAD_RIGHT); echo $str->value();","title":"pad()"},{"location":"string-manipulate/#position","text":"Find the position of the first occurrence of a substring in a string. $str = new Str('foo is bar sometimes'); $str->position(' is ', 0); echo $str->value();","title":"position()"},{"location":"string-manipulate/#repeat","text":"Repeats the string. $str = new Str('foo'); $str->repeat(5); echo $str->value();","title":"repeat()"},{"location":"string-manipulate/#replace","text":"Replaces the occurences of keys with their values. $str = new Str('foo can be bar but foo does not have to'); $str->replace(['foo' => 'fOo', 'DoEs Not' => 'fail', 'to' => '2']); echo $str->value();","title":"replace()"},{"location":"string-manipulate/#reverse","text":"Reverses current string. $str = new Str('knitS raW pupilS regaL'); $str->reverse(); echo $str->value();","title":"reverse()"},{"location":"string-manipulate/#rot13","text":"Perform the ROT13 transform on current string. The ROT13 encoding simply shifts every letter by 13 places in the alphabet while leaving non-alpha characters untouched. Encoding and decoding are done by the same function, passing an encoded string as argument will return the original version. $str = new Str('foobar'); $str->rot13(); echo $str->value();","title":"rot13()"},{"location":"string-manipulate/#rtrim","text":"Strip whitespace (or other characters) from the end. $str = new Str('ofoooooo'); $str->rtrim('o'); echo $str->value();","title":"rtrim()"},{"location":"string-manipulate/#shuffle","text":"Randomly shuffles the string. $str = new Str('foo bar foobar pebkac fubar'); $original = $str->value(); $str->shuffle(); echo $str->value(); echo $original;","title":"shuffle()"},{"location":"string-manipulate/#specialchars","text":"Convert special characters to HTML entities. $decode : If true , convert special HTML entities back to characters. $str = new Str('<p>This should <br>not be wrapped</p>'); $str->specialchars(); echo $str->value();","title":"specialchars()"},{"location":"string-manipulate/#striptags","text":"Strip HTML and PHP tags. $allowable_tags : List of allowed tags. $str = new Str('<html><div><p><br/><br></p></div></html>'); $str->stripTags(); echo $str->value();","title":"stripTags()"},{"location":"string-manipulate/#translate","text":"Translate characters or replace substrings. $str = new Str(':foo :bar'); $str->translate([':foo' => ':bar', ':bar' => ':newbar']); echo $str->value();","title":"translate()"},{"location":"string-manipulate/#trim","text":"Strips whitespace (or other characters) from the beginning and end of the string. $str = new Str('offsoooooo'); $str->trim('o'); echo $str->value();","title":"trim()"},{"location":"string-manipulate/#undo","text":"Undoes the last $steps operations. $str = new Str(' foo is bar '); $str->rtrim(); $str->ltrim(); $str->replace(array(' is ' => '_is_')); $str->undo(1); echo $str->value();","title":"undo()"},{"location":"string-manipulate/#uniquechars","text":"Returns a string containing all unique characters (in current string). $str = new Str('abcabdabcd'); $str->uniqueChars(); echo $str->value();","title":"uniqueChars()"},{"location":"string-manipulate/#wordcount","text":"Counts the number of words inside string. $charlist : Optional list of additional characters which will be considered as 'word'. $str = new Str('foo is here 3 times foo foo'); $str->wordCount(); echo $str->value();","title":"wordCount()"},{"location":"string-manipulate/#word","text":"Returns the list of words inside string. $charlist : Optional list of additional characters which will be considered as 'word'. $str = new Str('foo foo bar foo'); $str->word(); echo $str->value();","title":"word()"},{"location":"upgrade-guide/","text":"Upgrading from version 2.x to 3.x composer.json Update the Core package in your composer.json file: \"solital/core\": \"3.*\" You should also remove the slowprog/composer-copy-file package. To do this, manually delete it in composer.json or run the command: composer remove slowprog/composer-copy-file After that, you need to remove any references to the previous package. Replace this: \"scripts\": { \"post-create-project-cmd\": [ \"SlowProg\\\\CopyFile\\\\ScriptHandler::copy\", \"composer dump-autoload -o\" ], \"post-install-cmd\": [ \"SlowProg\\\\CopyFile\\\\ScriptHandler::copy\", \"composer dump-autoload -o\" ], \"post-update-cmd\": [ \"SlowProg\\\\CopyFile\\\\ScriptHandler::copy\", \"composer dump-autoload -o\" ] } By this code: \"scripts\": { \"post-create-project-cmd\": [ \"composer dump-autoload -o\" ], \"post-install-cmd\": [ \"composer dump-autoload -o\", \"php vinci generate:files\" ], \"post-update-cmd\": [ \"composer dump-autoload -o\", \"php vinci generate:files\" ] } Finally, remove the extra from your composer.json file: \"extra\": { \"copy-file\": { \"vendor/solital/core/src/Resource/Helpers/\": \"app/Helpers/System\", \"vendor/solital/core/src/Console/Components/Templates/Controller.php\": \"app/Components/Controller/\", \"vendor/solital/core/vinci\": \"vinci\" } } .env The variables below will no longer be used in version 3.x , so they should be removed. # NATIVEMAIL CONFIG MAIL_SENDER=\"\" MAIL_RECIPIENT=\"\" # WINDOWS ONLY MYSQL_DUMP=\"\" PG_DUMP=\"\" SQLITE3=\"\" The NativeMail class has been removed from version 3.x and PHPMailer will be Solital's default mailing package. The email variables have been replaced by these: # EMAIL CONFIG MAIL_DEBUG=\"0\" MAIL_HOST=\"\" MAIL_USER=\"\" MAIL_PASS=\"\" MAIL_SECURITY=\"\" MAIL_PORT=\"\" config.php In the config.php file that is at the root of Solital, you will replace the existing code with this one: <?php require_once __DIR__ .'/vendor/autoload.php'; use Solital\\Core\\Kernel\\Application; Application::sessionInit(); $dotenv = Dotenv\\Dotenv::createUnsafeImmutable(__DIR__); $dotenv->load(); if (!empty(getenv('ERRORS_DISPLAY'))) { if (getenv('ERRORS_DISPLAY') == 'true') { ini_set('display_errors', 1); error_reporting(E_ALL); } } index.php The index.php file has been completely changed. First, locate the file inside the public/ folder. Then erase all the code present in that file and replace it with this one: <?php /** * WARNING: DO NOT MAKE ANY KIND OF CHANGE IN THIS FILE. * ANY KIND OF MODIFICATION WILL BREAK YOUR PROJECT. */ require_once dirname(__DIR__). '/vendor/autoload.php'; use Solital\\Core\\Course\\Course; use Solital\\Core\\Kernel\\Application; use Solital\\Core\\Http\\Middleware\\BaseCsrfVerifier; define('SITE_ROOT', dirname(__DIR__)); Application::autoload(\"../vendor/solital/core/src/Resource/Helpers/\"); Course::setDefaultNamespace('\\Solital\\Components\\Controller'); Course::csrfVerifier(new BaseCsrfVerifier()); Application::autoload(\"../routers/\"); Application::init(); Classes and folders Some classes and folders will no longer be used by version 3.x . The following classes should be deleted: SQL.php ( app/Database/ ) and CustomConsole.php ( app/ ). The following folders must be deleted along with all content: Helpers ( app/Helpers ). Vinci File The Vinci Console has had a big change compared to the 2.x version. For that, you'll have to replace all the code in the vinci file with this one: #!/usr/bin/env php <?php require_once 'vendor/autoload.php'; use Solital\\Core\\Kernel\\Application; define('SITE_ROOT', __DIR__); Application::autoload(\"vendor/solital/core/src/Resource/Helpers/\"); $class_commands = [ \\Solital\\Core\\Kernel\\Console\\SolitalCommands::class, \\Solital\\Console\\Config::class ]; (new \\Solital\\Core\\Console\\Command($class_commands))->read($argv[1], $argv); If necessary, manually create the Config.php file inside the app/Console/ folder. <?php namespace Solital\\Console; use Solital\\Core\\Console\\Interface\\ExtendCommandsInterface; class Config implements ExtendCommandsInterface { /** * @var array */ protected array $command_class = []; /** * @return array */ public function getCommandClass(): array { return $this->command_class; } } Copying new files After all these changes, you will need to run the following command: php vinci generate:files This command will copy configuration files into the app/config folder. This command should be executed whenever there is an important update. Checking Solital Version To verify that the update was successful, run php vinci version to see the Core version. Also, run php -S localhost:8000 -t public/ to check on the splash screen that everything is working.","title":"Upgrade Guide"},{"location":"upgrade-guide/#upgrading-from-version-2x-to-3x","text":"","title":"Upgrading from version 2.x to 3.x"},{"location":"upgrade-guide/#composerjson","text":"Update the Core package in your composer.json file: \"solital/core\": \"3.*\" You should also remove the slowprog/composer-copy-file package. To do this, manually delete it in composer.json or run the command: composer remove slowprog/composer-copy-file After that, you need to remove any references to the previous package. Replace this: \"scripts\": { \"post-create-project-cmd\": [ \"SlowProg\\\\CopyFile\\\\ScriptHandler::copy\", \"composer dump-autoload -o\" ], \"post-install-cmd\": [ \"SlowProg\\\\CopyFile\\\\ScriptHandler::copy\", \"composer dump-autoload -o\" ], \"post-update-cmd\": [ \"SlowProg\\\\CopyFile\\\\ScriptHandler::copy\", \"composer dump-autoload -o\" ] } By this code: \"scripts\": { \"post-create-project-cmd\": [ \"composer dump-autoload -o\" ], \"post-install-cmd\": [ \"composer dump-autoload -o\", \"php vinci generate:files\" ], \"post-update-cmd\": [ \"composer dump-autoload -o\", \"php vinci generate:files\" ] } Finally, remove the extra from your composer.json file: \"extra\": { \"copy-file\": { \"vendor/solital/core/src/Resource/Helpers/\": \"app/Helpers/System\", \"vendor/solital/core/src/Console/Components/Templates/Controller.php\": \"app/Components/Controller/\", \"vendor/solital/core/vinci\": \"vinci\" } }","title":"composer.json"},{"location":"upgrade-guide/#env","text":"The variables below will no longer be used in version 3.x , so they should be removed. # NATIVEMAIL CONFIG MAIL_SENDER=\"\" MAIL_RECIPIENT=\"\" # WINDOWS ONLY MYSQL_DUMP=\"\" PG_DUMP=\"\" SQLITE3=\"\" The NativeMail class has been removed from version 3.x and PHPMailer will be Solital's default mailing package. The email variables have been replaced by these: # EMAIL CONFIG MAIL_DEBUG=\"0\" MAIL_HOST=\"\" MAIL_USER=\"\" MAIL_PASS=\"\" MAIL_SECURITY=\"\" MAIL_PORT=\"\"","title":".env"},{"location":"upgrade-guide/#configphp","text":"In the config.php file that is at the root of Solital, you will replace the existing code with this one: <?php require_once __DIR__ .'/vendor/autoload.php'; use Solital\\Core\\Kernel\\Application; Application::sessionInit(); $dotenv = Dotenv\\Dotenv::createUnsafeImmutable(__DIR__); $dotenv->load(); if (!empty(getenv('ERRORS_DISPLAY'))) { if (getenv('ERRORS_DISPLAY') == 'true') { ini_set('display_errors', 1); error_reporting(E_ALL); } }","title":"config.php"},{"location":"upgrade-guide/#indexphp","text":"The index.php file has been completely changed. First, locate the file inside the public/ folder. Then erase all the code present in that file and replace it with this one: <?php /** * WARNING: DO NOT MAKE ANY KIND OF CHANGE IN THIS FILE. * ANY KIND OF MODIFICATION WILL BREAK YOUR PROJECT. */ require_once dirname(__DIR__). '/vendor/autoload.php'; use Solital\\Core\\Course\\Course; use Solital\\Core\\Kernel\\Application; use Solital\\Core\\Http\\Middleware\\BaseCsrfVerifier; define('SITE_ROOT', dirname(__DIR__)); Application::autoload(\"../vendor/solital/core/src/Resource/Helpers/\"); Course::setDefaultNamespace('\\Solital\\Components\\Controller'); Course::csrfVerifier(new BaseCsrfVerifier()); Application::autoload(\"../routers/\"); Application::init();","title":"index.php"},{"location":"upgrade-guide/#classes-and-folders","text":"Some classes and folders will no longer be used by version 3.x . The following classes should be deleted: SQL.php ( app/Database/ ) and CustomConsole.php ( app/ ). The following folders must be deleted along with all content: Helpers ( app/Helpers ).","title":"Classes and folders"},{"location":"upgrade-guide/#vinci-file","text":"The Vinci Console has had a big change compared to the 2.x version. For that, you'll have to replace all the code in the vinci file with this one: #!/usr/bin/env php <?php require_once 'vendor/autoload.php'; use Solital\\Core\\Kernel\\Application; define('SITE_ROOT', __DIR__); Application::autoload(\"vendor/solital/core/src/Resource/Helpers/\"); $class_commands = [ \\Solital\\Core\\Kernel\\Console\\SolitalCommands::class, \\Solital\\Console\\Config::class ]; (new \\Solital\\Core\\Console\\Command($class_commands))->read($argv[1], $argv); If necessary, manually create the Config.php file inside the app/Console/ folder. <?php namespace Solital\\Console; use Solital\\Core\\Console\\Interface\\ExtendCommandsInterface; class Config implements ExtendCommandsInterface { /** * @var array */ protected array $command_class = []; /** * @return array */ public function getCommandClass(): array { return $this->command_class; } }","title":"Vinci File"},{"location":"upgrade-guide/#copying-new-files","text":"After all these changes, you will need to run the following command: php vinci generate:files This command will copy configuration files into the app/config folder. This command should be executed whenever there is an important update.","title":"Copying new files"},{"location":"upgrade-guide/#checking-solital-version","text":"To verify that the update was successful, run php vinci version to see the Core version. Also, run php -S localhost:8000 -t public/ to check on the splash screen that everything is working.","title":"Checking Solital Version"},{"location":"url/","text":"By default all controller and resource routes will use a simplified version of their url as name. You easily use the url() shortcut helper function to retrieve urls for your routes or manipulate the current url. url() will return a Uri object which will return a string when rendered, so it can be used safely in templates etc. but contains all the useful helpers methods in the Uri class like contains , indexOf etc. Check the Useful url tricks below. Get the current url It has never been easier to get and/or manipulate the current url. The example below shows you how to get the current url: # output: /current-url url(); Get by name (single route) Course::get('/product-view/{id}', 'ProductsController@show', ['as' => 'product']); # output: /product-view/22/?category=shoes url('product', ['id' => 22], ['category' => 'shoes']); # output: /product-view/?category=shoes url('product', null, ['category' => 'shoes']); Get by name (controller route) Course::controller('/images', ImagesController::class, ['as' => 'picture']); # output: /images/view/?category=shows url('picture@getView', null, ['category' => 'shoes']); # output: /images/view/?category=shows url('picture', 'getView', ['category' => 'shoes']); # output: /images/view/ url('picture', 'view'); Get by class Course::get('/product-view/{id}', 'ProductsController@show', ['as' => 'product']); Course::controller('/images', 'ImagesController'); # output: /product-view/22/?category=shoes url('ProductsController@show', ['id' => 22], ['category' => 'shoes']); # output: /images/image/?id=22 url('ImagesController@getImage', null, ['id' => 22]); Using custom names for methods on a controller/resource route Course::controller('gadgets', GadgetsController::class, ['names' => ['getIphoneInfo' => 'iphone']]); url('gadgets.iphone'); # output # /gadgets/iphoneinfo/ Getting REST/resource controller urls Course::resource('/phones', PhonesController::class); # output: /phones/ url('phones'); # output: /phones/ url('phones.index'); # output: /phones/create/ url('phones.create'); # output: /phones/edit/ url('phones.edit'); Manipulating url You can easily manipulate the query-strings, by adding your get param arguments. # output: /current-url?q=cars url(null, null, ['q' => 'cars']); You can remove a query-string parameter by setting the value to null . The example below will remove any query-string parameter named q from the url but keep all others query-string parameters: $url = url()->removeParam('q'); Useful url tricks Calling url will always return a Url object. Upon rendered it will return a string of the relative url , so it's safe to use in templates etc. However this allow us to use the useful methods on the Url object like indexOf and contains or retrieve specific parts of the url like the path, querystring parameters, host etc. You can also manipulate the url like removing- or adding parameters, changing host and more. In the example below, we check if the current url contains the /api part. if(url()->contains('/api')) { // ... do stuff } As mentioned earlier, you can also use the Uri object to show specific parts of the url or control what part of the url you want. # Grab the query-string parameter id from the current-url. $id = url()->getParam('id'); # Get the absolute url for the current url. $absoluteUrl = url()->getAbsoluteUrl(); For more available methods please check the Uri class.","title":"URL"},{"location":"url/#get-the-current-url","text":"It has never been easier to get and/or manipulate the current url. The example below shows you how to get the current url: # output: /current-url url();","title":"Get the current url"},{"location":"url/#get-by-name-single-route","text":"Course::get('/product-view/{id}', 'ProductsController@show', ['as' => 'product']); # output: /product-view/22/?category=shoes url('product', ['id' => 22], ['category' => 'shoes']); # output: /product-view/?category=shoes url('product', null, ['category' => 'shoes']);","title":"Get by name (single route)"},{"location":"url/#get-by-name-controller-route","text":"Course::controller('/images', ImagesController::class, ['as' => 'picture']); # output: /images/view/?category=shows url('picture@getView', null, ['category' => 'shoes']); # output: /images/view/?category=shows url('picture', 'getView', ['category' => 'shoes']); # output: /images/view/ url('picture', 'view');","title":"Get by name (controller route)"},{"location":"url/#get-by-class","text":"Course::get('/product-view/{id}', 'ProductsController@show', ['as' => 'product']); Course::controller('/images', 'ImagesController'); # output: /product-view/22/?category=shoes url('ProductsController@show', ['id' => 22], ['category' => 'shoes']); # output: /images/image/?id=22 url('ImagesController@getImage', null, ['id' => 22]);","title":"Get by class"},{"location":"url/#using-custom-names-for-methods-on-a-controllerresource-route","text":"Course::controller('gadgets', GadgetsController::class, ['names' => ['getIphoneInfo' => 'iphone']]); url('gadgets.iphone'); # output # /gadgets/iphoneinfo/","title":"Using custom names for methods on a controller/resource route"},{"location":"url/#getting-restresource-controller-urls","text":"Course::resource('/phones', PhonesController::class); # output: /phones/ url('phones'); # output: /phones/ url('phones.index'); # output: /phones/create/ url('phones.create'); # output: /phones/edit/ url('phones.edit');","title":"Getting REST/resource controller urls"},{"location":"url/#manipulating-url","text":"You can easily manipulate the query-strings, by adding your get param arguments. # output: /current-url?q=cars url(null, null, ['q' => 'cars']); You can remove a query-string parameter by setting the value to null . The example below will remove any query-string parameter named q from the url but keep all others query-string parameters: $url = url()->removeParam('q');","title":"Manipulating url"},{"location":"url/#useful-url-tricks","text":"Calling url will always return a Url object. Upon rendered it will return a string of the relative url , so it's safe to use in templates etc. However this allow us to use the useful methods on the Url object like indexOf and contains or retrieve specific parts of the url like the path, querystring parameters, host etc. You can also manipulate the url like removing- or adding parameters, changing host and more. In the example below, we check if the current url contains the /api part. if(url()->contains('/api')) { // ... do stuff } As mentioned earlier, you can also use the Uri object to show specific parts of the url or control what part of the url you want. # Grab the query-string parameter id from the current-url. $id = url()->getParam('id'); # Get the absolute url for the current url. $absoluteUrl = url()->getAbsoluteUrl(); For more available methods please check the Uri class.","title":"Useful url tricks"},{"location":"validation-component/","text":"Validation You can validate email, string, array and others. Email $res = Valid::email('solital@email.com'); /* Return `string` if true or `null` if false */ pre($res); Number You can validate whether a number is int or float . $res = Valid::number(12.5); /* Return `int` or `float` if true or `null` if false */ pre($res); Null $res = Valid::isNull(null); /* Return bool */ pre($res); Lowercase You can validate a string if it is lowercase. If not, the isLower method will convert the string to lowercase. $res = Valid::isLower('SOLITAL'); /* Return string */ pre($res); Uppercase You can validate a string if it is uppercase. If not, the isUpper method will convert the string to uppercase. $res = Valid::isUpper('solital'); /* Return string */ pre($res); Base64 Checks whether a variable is Base64-type encryption. $hash = base64_encode(\"test\"); $res = Valid::isBase64($hash); /* Return bool */ pre($res); Identical Checks if one variable is identical to another. $res = Valid::identical(\"foo\", \"foo\"); /* Return bool */ pre($res);","title":"Validation"},{"location":"validation-component/#validation","text":"You can validate email, string, array and others.","title":"Validation"},{"location":"validation-component/#email","text":"$res = Valid::email('solital@email.com'); /* Return `string` if true or `null` if false */ pre($res);","title":"Email"},{"location":"validation-component/#number","text":"You can validate whether a number is int or float . $res = Valid::number(12.5); /* Return `int` or `float` if true or `null` if false */ pre($res);","title":"Number"},{"location":"validation-component/#null","text":"$res = Valid::isNull(null); /* Return bool */ pre($res);","title":"Null"},{"location":"validation-component/#lowercase","text":"You can validate a string if it is lowercase. If not, the isLower method will convert the string to lowercase. $res = Valid::isLower('SOLITAL'); /* Return string */ pre($res);","title":"Lowercase"},{"location":"validation-component/#uppercase","text":"You can validate a string if it is uppercase. If not, the isUpper method will convert the string to uppercase. $res = Valid::isUpper('solital'); /* Return string */ pre($res);","title":"Uppercase"},{"location":"validation-component/#base64","text":"Checks whether a variable is Base64-type encryption. $hash = base64_encode(\"test\"); $res = Valid::isBase64($hash); /* Return bool */ pre($res);","title":"Base64"},{"location":"validation-component/#identical","text":"Checks if one variable is identical to another. $res = Valid::identical(\"foo\", \"foo\"); /* Return bool */ pre($res);","title":"Identical"},{"location":"verify-domain/","text":"Sometimes when we create a project for a client or for our work, we want to protect our code so that other people can't use it. Solital has a security method that verifies the domain of your project. If someone else copies your project to another domain, Solital sends you an email letting you know that your project is on a different domain. To do this configuration, you need to edit the bootstrap.yaml file. In the verify_domain -> enable_verification key, change the value to true . verify_domain: enable_verification: false send_to: recipient_name: In the send_to key, add the email that will be used for Solital to notify you about the copy of the project. In the recipient_name key, you will add your name or an alias. When you do this and reload any page in your project, a variable called APP_DOMAIN will be created in the .env file. This variable will contain the domain where your project was made. Obviously, if you are on locahost, you need to change this variable later. The line below is just an example. APP_DOMAIN=\"http://localhost:8000\" This is one more method for the security of your code. Obviously, for greater security, you need to use a private repository on GitHub.","title":"Verify Domain"},{"location":"vinci-console/","text":"Vinci Console is an auxiliary component to help create files faster, such as login structures, password recovery structures, database configuration and more. Access Vinci To access Vinci, open the terminal in your project folder and type php vinci [command] . To access information about Solital and its dependencies, open your terminal inside your project folder and type php vinci version For Windows To run the Vinci console on Windows, remember to add the PHP directory to the Windows PATH. Also check if your version of Windows or your editor supports ANSI characters. List of all commands The Vinci Console is a very simple to use helper. When you run the php vinci list command, you will get a description of all the commands present in the Solital Framework. Example php vinci [command] [argument] [--option1] [--option2] Command Description Arguments Options auth:skeleton Create Login and 'Forgot Password' structures - --login / --forgot / --remove cache:clear Clear the Solital cache - --cache / --session create:cmd Create a command name --remove create:controller Create a Controller class name --remove create:middleware Create a Middleware class name --remove create:migration Create a migration name (optional) - create:model Create a Model class name --remove create:queue Create a Queue class name --remove create:seeder Create a Seeder class name - create:router Create a new router name --comment db:dump Dump the connected database name - db:list List data from a database table - --limit=10 generate:files Imports Solital Framework's default configuration files - - migrate Run a migration - --rollback (=value) / --status queue Run a queue - --class (=name) router:list Show all routes - - seeder Run a user-created Seeder - --class (=name) version Describes a command cmd_name - help Displays details about some command - - about Displays the Vinci Console version - list Displays a list of all Solital commands - - Custom Command To create a custom command, you need to run the command php vinci create:cmd [command_name_class] . This command will create a class in the app/Console/Command folder. Below is an example of the command and the created class: Command php vinci create:cmd UserCommand Generated class <?php namespace Solital\\Console\\Command; use Solital\\Core\\Console\\{Command, MessageTrait}; use Solital\\Core\\Console\\Interface\\CommandInterface; class UserCommand extends Command implements CommandInterface { use MessageTrait; /** * @var string */ protected string $command = \"\"; /** * @var array */ protected array $arguments = []; /** * @var string */ protected string $description = \"\"; /** * @param object $arguments * @param object $options * * @return mixed */ public function handle(object $arguments, object $options): mixed { return $this; } } In the $command variable, you will define the custom command that will be executed. The $arguments variable will have an array of values containing all arguments (if your custom command has no arguments, leave this variable empty). Lastly, the $description variable will have a short description of what the custom command does. Handle method The handle method will contain all the code that will be executed when executing the custom command and should always return a $this or, if necessary, another value. Using Arguments Arguments can be retrieved using the $arguments variable: php vinci user:cmd myArgument protected array $arguments = ['name']; public function handle(object $arguments, object $options): mixed { var_dump($arguments->foo); return $this; } Using Options Options are not defined in the created class, but you can check inside the handle method if an option exists. For example: php vinci user:cmd name --myOption public function handle(object $arguments, object $options): mixed { if (isset($options->myOption)) { # ... } return $this; } Input and output commands It is very common to enter an input value on the command line when needed. Using the InputOutput class, you can perform this action. use Solital\\Core\\Console\\InputOutput; (new InputOutput())->dialog('Enter a string: ')->action(function ($message) { echo $message . PHP_EOL; }); The dialog() method will display a message to the user, while the action() method retrieves the value entered on the command line. The action() method takes an anonymous function as a parameter. Confirmation box You can also use a \"yes/no\" confirmation, or any other value. (new InputOutput())->confirmDialog('What you want?', 'Y', 'N', false)->confirm(function () { echo \"accepted\" . PHP_EOL; })->refuse(function () { echo \"denied\" . PHP_EOL; }); In the first parameter of the confirmDialog method, you will define the question. The second parameter will be the value of the answer if it is positive, if not, the third parameter will receive the value of the answer if it is negative. The fourth parameter will define if the answer is know sensitive, if not, set it to false . Customizing colors To customize the colors of the message that is displayed from the CLI, you can pass the color name in the constructor of the InputOutput class. The available colors are: green , yellow and blue . (new InputOutput('green')) // green - yellow - blue Displaying messages To display a message on the command line, use the MessageTrait trait. First, you will define a message using one of the methods below: use Solital\\Core\\Console\\MessageTrait; $this->success() // Display a success message $this->info() // Display an information message $this->warning() // Displays a warning message $this->error() // Displays an error message $this->line() // Display a standard message After that, to display the message on the command line, use the print() method: $this->success(\"My message\")->print(); There are still other methods to complement your message. The break() method skips a line, while the exit() method stops code execution. // Skip a line $this->success(\"My message\")->print()->break()->exit(); // Skip two lines $this->success(\"My message\")->print()->break(true)->exit(); Progress Bar Progressbar has customizable names, colors, datatypes, error handling, and more. Usage Initializing the ADVProgressbar object use Solital\\Core\\Console\\ProgressBar\\ProgressBar; use Solital\\Core\\Console\\ProgressBar\\ProgressBarStyle; //Lets create a style object first. //Style object has 4 parameters {$name, $color, $datatype, $length}. $progressbar_style = new ProgressBarStyle(\"Downloading\", \"white\", \"Kb\", 16); //Now lets create the progressbar object. //Progressbar object has 2 parameters {$styleobject, $initialmax} $progressbar = new ProgressBar($progressbar_style, 1000); Using the ADVProgressbar //Loop until the progressbar is complete for ($i = 0; $i < $progressbar->GetInitialMax(); $i++) { $progressbar->step(); usleep(1000); } Methods: //Increases the progressbar value by 1. $progressbar->step(); //Increases the progressbar value by x. $progressbar->stepBy(x); //Changes the progressbar value to x. $progressbar->stepTo(x); //Gets the progressbar value. $progressbar->getValue(); //Gets the max initial value. $progressbar->getInitialMax(); //Forces a redraw on the progressbar. $progressbar->update(); //Enables the pause mode, it can be removed by using any of the step methods or forcing a redraw. $progressbar->pauseProgressbar(); //Resets the progressbar object. $progressbar->resetProgressbar(); //Terminates the progressbar and resets the object. $progressbar->terminateProgressbar(); Registering a custom command When creating your custom command, it will not yet be ready to run. First, you need to configure the Config.php file. You can find this file in app/Console . In the $command_class variable, you will define the name of the classes that have the commands, and in the $type_commands variable, you will define the purpose of these commands: use Solital\\Console\\Command\\UserCommand; /** * @var array */ protected array $command_class = [ UserCommand::class ]; /** * @var string */ protected string $type_commands = \"My Commands\"; You can register more than one command, and then add your new commands to the $command_class variable. After that, you can run the created command using php vinci user:cmd or any other command you have defined.","title":"Vinci Console"},{"location":"vinci-console/#access-vinci","text":"To access Vinci, open the terminal in your project folder and type php vinci [command] . To access information about Solital and its dependencies, open your terminal inside your project folder and type php vinci version","title":"Access Vinci"},{"location":"vinci-console/#for-windows","text":"To run the Vinci console on Windows, remember to add the PHP directory to the Windows PATH. Also check if your version of Windows or your editor supports ANSI characters.","title":"For Windows"},{"location":"vinci-console/#list-of-all-commands","text":"The Vinci Console is a very simple to use helper. When you run the php vinci list command, you will get a description of all the commands present in the Solital Framework. Example php vinci [command] [argument] [--option1] [--option2] Command Description Arguments Options auth:skeleton Create Login and 'Forgot Password' structures - --login / --forgot / --remove cache:clear Clear the Solital cache - --cache / --session create:cmd Create a command name --remove create:controller Create a Controller class name --remove create:middleware Create a Middleware class name --remove create:migration Create a migration name (optional) - create:model Create a Model class name --remove create:queue Create a Queue class name --remove create:seeder Create a Seeder class name - create:router Create a new router name --comment db:dump Dump the connected database name - db:list List data from a database table - --limit=10 generate:files Imports Solital Framework's default configuration files - - migrate Run a migration - --rollback (=value) / --status queue Run a queue - --class (=name) router:list Show all routes - - seeder Run a user-created Seeder - --class (=name) version Describes a command cmd_name - help Displays details about some command - - about Displays the Vinci Console version - list Displays a list of all Solital commands - -","title":"List of all commands"},{"location":"vinci-console/#custom-command","text":"To create a custom command, you need to run the command php vinci create:cmd [command_name_class] . This command will create a class in the app/Console/Command folder. Below is an example of the command and the created class: Command php vinci create:cmd UserCommand Generated class <?php namespace Solital\\Console\\Command; use Solital\\Core\\Console\\{Command, MessageTrait}; use Solital\\Core\\Console\\Interface\\CommandInterface; class UserCommand extends Command implements CommandInterface { use MessageTrait; /** * @var string */ protected string $command = \"\"; /** * @var array */ protected array $arguments = []; /** * @var string */ protected string $description = \"\"; /** * @param object $arguments * @param object $options * * @return mixed */ public function handle(object $arguments, object $options): mixed { return $this; } } In the $command variable, you will define the custom command that will be executed. The $arguments variable will have an array of values containing all arguments (if your custom command has no arguments, leave this variable empty). Lastly, the $description variable will have a short description of what the custom command does. Handle method The handle method will contain all the code that will be executed when executing the custom command and should always return a $this or, if necessary, another value. Using Arguments Arguments can be retrieved using the $arguments variable: php vinci user:cmd myArgument protected array $arguments = ['name']; public function handle(object $arguments, object $options): mixed { var_dump($arguments->foo); return $this; } Using Options Options are not defined in the created class, but you can check inside the handle method if an option exists. For example: php vinci user:cmd name --myOption public function handle(object $arguments, object $options): mixed { if (isset($options->myOption)) { # ... } return $this; }","title":"Custom Command"},{"location":"vinci-console/#input-and-output-commands","text":"It is very common to enter an input value on the command line when needed. Using the InputOutput class, you can perform this action. use Solital\\Core\\Console\\InputOutput; (new InputOutput())->dialog('Enter a string: ')->action(function ($message) { echo $message . PHP_EOL; }); The dialog() method will display a message to the user, while the action() method retrieves the value entered on the command line. The action() method takes an anonymous function as a parameter. Confirmation box You can also use a \"yes/no\" confirmation, or any other value. (new InputOutput())->confirmDialog('What you want?', 'Y', 'N', false)->confirm(function () { echo \"accepted\" . PHP_EOL; })->refuse(function () { echo \"denied\" . PHP_EOL; }); In the first parameter of the confirmDialog method, you will define the question. The second parameter will be the value of the answer if it is positive, if not, the third parameter will receive the value of the answer if it is negative. The fourth parameter will define if the answer is know sensitive, if not, set it to false . Customizing colors To customize the colors of the message that is displayed from the CLI, you can pass the color name in the constructor of the InputOutput class. The available colors are: green , yellow and blue . (new InputOutput('green')) // green - yellow - blue","title":"Input and output commands"},{"location":"vinci-console/#displaying-messages","text":"To display a message on the command line, use the MessageTrait trait. First, you will define a message using one of the methods below: use Solital\\Core\\Console\\MessageTrait; $this->success() // Display a success message $this->info() // Display an information message $this->warning() // Displays a warning message $this->error() // Displays an error message $this->line() // Display a standard message After that, to display the message on the command line, use the print() method: $this->success(\"My message\")->print(); There are still other methods to complement your message. The break() method skips a line, while the exit() method stops code execution. // Skip a line $this->success(\"My message\")->print()->break()->exit(); // Skip two lines $this->success(\"My message\")->print()->break(true)->exit();","title":"Displaying messages"},{"location":"vinci-console/#progress-bar","text":"Progressbar has customizable names, colors, datatypes, error handling, and more.","title":"Progress Bar"},{"location":"vinci-console/#usage","text":"Initializing the ADVProgressbar object use Solital\\Core\\Console\\ProgressBar\\ProgressBar; use Solital\\Core\\Console\\ProgressBar\\ProgressBarStyle; //Lets create a style object first. //Style object has 4 parameters {$name, $color, $datatype, $length}. $progressbar_style = new ProgressBarStyle(\"Downloading\", \"white\", \"Kb\", 16); //Now lets create the progressbar object. //Progressbar object has 2 parameters {$styleobject, $initialmax} $progressbar = new ProgressBar($progressbar_style, 1000); Using the ADVProgressbar //Loop until the progressbar is complete for ($i = 0; $i < $progressbar->GetInitialMax(); $i++) { $progressbar->step(); usleep(1000); }","title":"Usage"},{"location":"vinci-console/#methods","text":"//Increases the progressbar value by 1. $progressbar->step(); //Increases the progressbar value by x. $progressbar->stepBy(x); //Changes the progressbar value to x. $progressbar->stepTo(x); //Gets the progressbar value. $progressbar->getValue(); //Gets the max initial value. $progressbar->getInitialMax(); //Forces a redraw on the progressbar. $progressbar->update(); //Enables the pause mode, it can be removed by using any of the step methods or forcing a redraw. $progressbar->pauseProgressbar(); //Resets the progressbar object. $progressbar->resetProgressbar(); //Terminates the progressbar and resets the object. $progressbar->terminateProgressbar();","title":"Methods:"},{"location":"vinci-console/#registering-a-custom-command","text":"When creating your custom command, it will not yet be ready to run. First, you need to configure the Config.php file. You can find this file in app/Console . In the $command_class variable, you will define the name of the classes that have the commands, and in the $type_commands variable, you will define the purpose of these commands: use Solital\\Console\\Command\\UserCommand; /** * @var array */ protected array $command_class = [ UserCommand::class ]; /** * @var string */ protected string $type_commands = \"My Commands\"; You can register more than one command, and then add your new commands to the $command_class variable. After that, you can run the created command using php vinci user:cmd or any other command you have defined.","title":"Registering a custom command"},{"location":"wolf-template/","text":"Wolf is Solital's default template engine. With Wolf, you can display any HTML, CSS and JavaScript code. Wolf has the following features: generate views cache; extend other views; minify CSS and JS files; use native HTML files. You can load any template into the resource/views folder Basic To use the Wolf Template, you can use the view() helper, or create an instance of the Wolf class. use Solital\\Core\\Wolf\\Wolf; // With helper Course::get('/', function () { return view('welcome'); }); // With instance Course::get('/', function () { echo (new Wolf)->loadView('welcome'); }); Markers in Wolf Wolf uses markers to interpret PHP code within views. That is, when using {{ }} , Wolf will interpret these characters as <?= ?> . Likewise, when using {% %} , Wolf will interpret it as <?php ?> . That way, you can use native PHP code inside your views using the bookmarks. Parameters To display data for your view, use the second parameter of the view helper or loadView method. // With helper Course::get('/', function () { return view('welcome', [ 'title' => 'My Title' ]); }); // With instance Course::get('/', function () { echo (new Wolf)->loadView('welcome', [ 'title' => 'My Title' ]); }); And in your home.php , retrieve the value informed in this way: <title>{{ title }}</title> Loading CSS, JS and images Make sure the files exist in the folder public/assets/_css , public/assets/_js and public/assets/_img To load a CSS file, use the static load_css method in your template. <link rel=\"stylesheet\" href=\"{{ load_css('style.css'); }}\"> To load a JS file, use the static load_js method in your template. <link rel=\"stylesheet\" href=\"{{ load_js('file.js'); }}\"> To load a image file, use the static load_img method in your template. <img src=\"{{ load_img('image.png'); }}\"> To load a file outside the _css , _js and _img folder, use the load_file method. <img src=\"{{ load_file('path/for/your/file'); }}\"> Cache templates Cache on all pages If you have a template that takes a long time to load, or is rarely accessed, consider creating a cache of that template. Wolf's cache works as follows: a page is loaded, then a page identical to the one that was loaded with all the data already saved in cache is created. When reloading, if this page is still valid, the page's cache will be displayed. To cache your views, edit the bootstrap.yaml file: wolf_cache: enabled: true # false time: minute # minute, hour, day, week In time , you can define if you want to cache your views for 1 minute, 1 hour, 1 day or 1 week. Cache on a single page If you don't want to create a cache file for all templates, consider using the WolfCache class to generate a cache file for each template. This class will create a cache file just for a single view (or for several if you add this class in the Controller's constructor). The syntax below shows how long the template can be cached. use Solital\\Core\\Wolf\\WolfCache; # The template is cached for one minute WolfCache::cache()->forOneMinute(); # The template is cached for an hour WolfCache::cache()->forOneHour(); # The template is cached for a day WolfCache::cache()->forOneDay(); # The template is cached for a week WolfCache::cache()->forOneWeek(); The code above shows how long the view will be cached. To actually generate the view cache, use the makeCache() method passing the template name as a parameter. Course::get('/', function () { WolfCache::cache()->forOneMinute()->makeCache('welcome'); return view('welcome'); }); Minify Assets Having to load multiple CSS and Javascript files can be a lot of work and can be a burden on the site. However, you can minify all of these files into a single CSS and JS file. By default, assets are loaded into the public/assets/ folder. However, there is a second assets folder inside specific resource/ to minify the CSS/JS files. If you want to generate a minified file for your assets, first add your CSS and JavaScript files to the resource/assets folder. Then edit the bootstrap.yaml file. wolf_minify: false style : minify only CSS files script : minify only JS files all : minify CSS and JS files false : don't minify files Load minified files into the template The load_min_css() and load_min_js() functions will load all files that are minified, without having to use the load_css() and load_js() functions. # Load minify CSS <link rel=\"stylesheet\" href=\"{{ load_min_css() }}\"> # Load minify JS <script src=\"{{ load_min_js() }}\"><script> Extending templates It is very common for developers to create a header.php file and include it in other files. With Wolf this is also possible using the extend method. The extend method includes any template that is inside the resource/view folder. {% extend('header') %} It is not necessary to inform the file extension, just use the file home without the extension. View inside a folder If you want to extend a view inside a folder, use a (.) separator. {% extend('auth.header') %}","title":"Wolf Template"},{"location":"wolf-template/#basic","text":"To use the Wolf Template, you can use the view() helper, or create an instance of the Wolf class. use Solital\\Core\\Wolf\\Wolf; // With helper Course::get('/', function () { return view('welcome'); }); // With instance Course::get('/', function () { echo (new Wolf)->loadView('welcome'); });","title":"Basic"},{"location":"wolf-template/#markers-in-wolf","text":"Wolf uses markers to interpret PHP code within views. That is, when using {{ }} , Wolf will interpret these characters as <?= ?> . Likewise, when using {% %} , Wolf will interpret it as <?php ?> . That way, you can use native PHP code inside your views using the bookmarks.","title":"Markers in Wolf"},{"location":"wolf-template/#parameters","text":"To display data for your view, use the second parameter of the view helper or loadView method. // With helper Course::get('/', function () { return view('welcome', [ 'title' => 'My Title' ]); }); // With instance Course::get('/', function () { echo (new Wolf)->loadView('welcome', [ 'title' => 'My Title' ]); }); And in your home.php , retrieve the value informed in this way: <title>{{ title }}</title>","title":"Parameters"},{"location":"wolf-template/#loading-css-js-and-images","text":"Make sure the files exist in the folder public/assets/_css , public/assets/_js and public/assets/_img To load a CSS file, use the static load_css method in your template. <link rel=\"stylesheet\" href=\"{{ load_css('style.css'); }}\"> To load a JS file, use the static load_js method in your template. <link rel=\"stylesheet\" href=\"{{ load_js('file.js'); }}\"> To load a image file, use the static load_img method in your template. <img src=\"{{ load_img('image.png'); }}\"> To load a file outside the _css , _js and _img folder, use the load_file method. <img src=\"{{ load_file('path/for/your/file'); }}\">","title":"Loading CSS, JS and images"},{"location":"wolf-template/#cache-templates","text":"Cache on all pages If you have a template that takes a long time to load, or is rarely accessed, consider creating a cache of that template. Wolf's cache works as follows: a page is loaded, then a page identical to the one that was loaded with all the data already saved in cache is created. When reloading, if this page is still valid, the page's cache will be displayed. To cache your views, edit the bootstrap.yaml file: wolf_cache: enabled: true # false time: minute # minute, hour, day, week In time , you can define if you want to cache your views for 1 minute, 1 hour, 1 day or 1 week. Cache on a single page If you don't want to create a cache file for all templates, consider using the WolfCache class to generate a cache file for each template. This class will create a cache file just for a single view (or for several if you add this class in the Controller's constructor). The syntax below shows how long the template can be cached. use Solital\\Core\\Wolf\\WolfCache; # The template is cached for one minute WolfCache::cache()->forOneMinute(); # The template is cached for an hour WolfCache::cache()->forOneHour(); # The template is cached for a day WolfCache::cache()->forOneDay(); # The template is cached for a week WolfCache::cache()->forOneWeek(); The code above shows how long the view will be cached. To actually generate the view cache, use the makeCache() method passing the template name as a parameter. Course::get('/', function () { WolfCache::cache()->forOneMinute()->makeCache('welcome'); return view('welcome'); });","title":"Cache templates"},{"location":"wolf-template/#minify-assets","text":"Having to load multiple CSS and Javascript files can be a lot of work and can be a burden on the site. However, you can minify all of these files into a single CSS and JS file. By default, assets are loaded into the public/assets/ folder. However, there is a second assets folder inside specific resource/ to minify the CSS/JS files. If you want to generate a minified file for your assets, first add your CSS and JavaScript files to the resource/assets folder. Then edit the bootstrap.yaml file. wolf_minify: false style : minify only CSS files script : minify only JS files all : minify CSS and JS files false : don't minify files","title":"Minify Assets"},{"location":"wolf-template/#load-minified-files-into-the-template","text":"The load_min_css() and load_min_js() functions will load all files that are minified, without having to use the load_css() and load_js() functions. # Load minify CSS <link rel=\"stylesheet\" href=\"{{ load_min_css() }}\"> # Load minify JS <script src=\"{{ load_min_js() }}\"><script>","title":"Load minified files into the template"},{"location":"wolf-template/#extending-templates","text":"It is very common for developers to create a header.php file and include it in other files. With Wolf this is also possible using the extend method. The extend method includes any template that is inside the resource/view folder. {% extend('header') %} It is not necessary to inform the file extension, just use the file home without the extension.","title":"Extending templates"},{"location":"wolf-template/#view-inside-a-folder","text":"If you want to extend a view inside a folder, use a (.) separator. {% extend('auth.header') %}","title":"View inside a folder"},{"location":"yaml-files/","text":"The YAML files that are inside the app/config folder are used to change Solital Framework configurations, such as middlewares, authentication, passwords, among others. These files are updated whenever there is a Solital Core update. Updating YAML files To update the YAML files, run the following command: php vinci generate:files When you install a new Solital update using composer update , run the above command, so new files are copied to the app/config folder. Other files may be copied to other folders in this process.","title":"YAML Files"},{"location":"yaml-files/#updating-yaml-files","text":"To update the YAML files, run the following command: php vinci generate:files When you install a new Solital update using composer update , run the above command, so new files are copied to the app/config folder. Other files may be copied to other folders in this process.","title":"Updating YAML files"}]}