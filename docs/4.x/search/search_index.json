{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Solital is a fast, easy-to-use PHP framework and also has an easy-to-learn syntax. Created in 2020, Solital emerged as a lighter and simpler alternative to other frameworks available on the market such as Laravel, Symfony and CodeIgniter. Solital Framework has several features to help you create PHP projects with fast performance. Vinci Console is a component to help create, remove, update components. Wolf is Solital's default template engine, as well as being quick to render views. Database manipulation is also possible using Katrina ORM, migations and seeders. You can still use several other components present in Solital Framework. Current version You are reading the version documentation: 4.x For older versions of the solital, see the links below: 3.x 2.x 1.x Requirements PHP >=8.3 PHP JSON extension enabled PHP PDO extension enabled Why Solital? PHP has several well-known frameworks such as Laravel, Symfony, CakePHP, among others. All of these projects contribute to the PHP community. The Solital Framework contributed to this huge community, offering an easier way to create PHP projects, while also offering several important features. You can read the documentation to get an understanding of Solital Framework. Installing via Composer To download Solital, use the command below: composer create-project solital/solital project It only takes a few lines of code to get started: Course::get('/', function() { return 'Hello world'; }); Running To execute the project, run the command: php vinci server You can change your project IP if you want: php vinci server --host=localhost:8001 Or, if you want use HTTPS: php vinci server --https","title":"Starting"},{"location":"#current-version","text":"You are reading the version documentation: 4.x For older versions of the solital, see the links below: 3.x 2.x 1.x","title":"Current version"},{"location":"#requirements","text":"PHP >=8.3 PHP JSON extension enabled PHP PDO extension enabled","title":"Requirements"},{"location":"#why-solital","text":"PHP has several well-known frameworks such as Laravel, Symfony, CakePHP, among others. All of these projects contribute to the PHP community. The Solital Framework contributed to this huge community, offering an easier way to create PHP projects, while also offering several important features. You can read the documentation to get an understanding of Solital Framework.","title":"Why Solital?"},{"location":"#installing-via-composer","text":"To download Solital, use the command below: composer create-project solital/solital project It only takes a few lines of code to get started: Course::get('/', function() { return 'Hello world'; });","title":"Installing via Composer"},{"location":"#running","text":"To execute the project, run the command: php vinci server You can change your project IP if you want: php vinci server --host=localhost:8001 Or, if you want use HTTPS: php vinci server --https","title":"Running"},{"location":"application-api/","text":"Solital has a class called Application . This class, which is in the Kernel folder, manages the entire framework, from the instances to start the framework to communication with the database. Most of the methods in this class are for internal use by the framework. However, you can make use of some methods in this class. You can use the Application class or the helpers of that class. YAML files Returns variables by YAML file. // With class Application::yamlParse('file.yaml'); // With helper app_get_yaml('file.yaml'); Add a value to a YAML file // With class Application::addYamlValue('file.yaml', 'key', 'value'); // With helper app_add_yaml('file.yaml', 'key', 'value'); Dependency Container Get container ID defined in ServiceContainer class. // With class Application::provider('container_name'); // With helper container('container_name'); Access root folder Return directory on root folder // With class Application::getRoot('/folder_name'); // With helper app_get_root('/folder_name'); Access \"app\" folder Return directory in app/ folder // With class Application::getRootApp('/folder_name_in_app'); // With helper app_get_app('/folder_name_in_app'); The getRootApp method will create a folder inside the app/ folder if the folder you want to access doesn't exist. To disable the creation of this folder, use false in the second parameter. // With class Application::getRootApp('/folder_name_in_app', false); // With helper app_get_app('/folder_name_in_app', false); Autoload PHP files Recursively loads all php files in all subdirectories of the given path. // With class Application::autoload('folder/'); Application::classLoaderInDirectory('folder/'); // With helper app_autoload('folder/'); app_classloader('folder/'); Is CLI Checks whether PHP is running in CLI mode or not. // With class Application::isCli(); // With helper app_is_cli(); Database Get Solital's database connection. This method makes use of the variables defined in the .env file or, if you use a test database, in the database.yaml . This method also makes use of Solital's cache, if you are using it. // With class Application::connectionDatabase(); // With helper app_get_database_connection();","title":"API Application"},{"location":"application-api/#yaml-files","text":"Returns variables by YAML file. // With class Application::yamlParse('file.yaml'); // With helper app_get_yaml('file.yaml'); Add a value to a YAML file // With class Application::addYamlValue('file.yaml', 'key', 'value'); // With helper app_add_yaml('file.yaml', 'key', 'value');","title":"YAML files"},{"location":"application-api/#dependency-container","text":"Get container ID defined in ServiceContainer class. // With class Application::provider('container_name'); // With helper container('container_name');","title":"Dependency Container"},{"location":"application-api/#access-root-folder","text":"Return directory on root folder // With class Application::getRoot('/folder_name'); // With helper app_get_root('/folder_name');","title":"Access root folder"},{"location":"application-api/#access-app-folder","text":"Return directory in app/ folder // With class Application::getRootApp('/folder_name_in_app'); // With helper app_get_app('/folder_name_in_app'); The getRootApp method will create a folder inside the app/ folder if the folder you want to access doesn't exist. To disable the creation of this folder, use false in the second parameter. // With class Application::getRootApp('/folder_name_in_app', false); // With helper app_get_app('/folder_name_in_app', false);","title":"Access \"app\" folder"},{"location":"application-api/#autoload-php-files","text":"Recursively loads all php files in all subdirectories of the given path. // With class Application::autoload('folder/'); Application::classLoaderInDirectory('folder/'); // With helper app_autoload('folder/'); app_classloader('folder/');","title":"Autoload PHP files"},{"location":"application-api/#is-cli","text":"Checks whether PHP is running in CLI mode or not. // With class Application::isCli(); // With helper app_is_cli();","title":"Is CLI"},{"location":"application-api/#database","text":"Get Solital's database connection. This method makes use of the variables defined in the .env file or, if you use a test database, in the database.yaml . This method also makes use of Solital's cache, if you are using it. // With class Application::connectionDatabase(); // With helper app_get_database_connection();","title":"Database"},{"location":"authenticate/","text":"Defining the routes You can define dashboard and login routes. The dashboard route will be for when the user authenticates, and the login route will be for when the user logs off and will be redirected to it. To do this, open the auth.yaml file and edit the auth_dashboard_url and auth_login_url variables. auth: auth_dashboard_url: /dashboard auth_login_url: /auth Setting For this, it is necessary to first define the name of the table in the login method. In the columns method, the database username and password. Then, in the values method, the input values of the form. Finally, the register method will perform the login as shown below. $res = Auth::login('auth_users') ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register(); You can also use the Model name in the login() method. This way, the Auth component will get the name of the table that is in the $table property. Solital uses the default Model AuthModel . However, you can create a model and use it in the login() method. use Solital\\Core\\Kernel\\Model\\AuthModel; $res = Auth::login(AuthModel::class) ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register(); The $res variable will return true if authentication is true and will redirect the user to the route defined in the auth_dashboard_url variable. But if it is false , you can add a reply message after the above code if authentication fails. if ($res == false) { message('login', 'Invalid username and/or password!'); response()->redirect('your_login_url'); } Remembering authentication In some cases the user wants to remain logged into the system after closing the browser. When registering a user, you can first use the remember method, passing the name of the form input as a parameter. In the value of the form input, use true . <input type=\"checkbox\" name=\"inputRemember\" value=\"true\"> $res = Auth::login(AuthModel::class) ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->remember('inputRemember') ->register(); Below is an example method of authentication. <input type=\"email\" name=\"inputEmail\"> <input type=\"password\" name=\"inputPassword\"> <input type=\"checkbox\" name=\"inputRemember\" value=\"true\"> <?php namespace Solital\\Components\\Controller; use Solital\\Core\\Http\\Controller\\Controller; use Solital\\Core\\Auth\\Auth; class UserController extends Controller { /** * @return void */ public function authPost(): void { $res = Auth::login(AuthModel::class) ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->remember('inputRemember') ->register(); if ($res == false) { message('login', 'Invalid username and/or password!'); response()->redirect(url('auth')); } } } Changing default routes If you need more routes for dashboards and logins, you can change the parameter in the register() function: # In routers.php Course::get('/my-second-dashboard', 'SiteController@SecondDashboard')->name('second.dashboard'); # In Controller with `url()` helper $res = Auth::login(AuthModel::class) ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register(url('second.dashboard')); # Or without `url()` helper $res = Auth::login(AuthModel::class) ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register('/my-second-dashboard'); Check login To check if the user exists, you can create a middleware and add the Auth::check() method. class AuthMiddleware implements BaseMiddlewareInterface { public function handle(): void { Auth::check(); } } The Auth::check method checks whether there is a user authenticating, but if you want to specify a user, you can pass the username in the first parameter. If the user is not authenticated, he will be redirected to the route defined in the auth_login_url variable. If you want to redirect to another route, you can define it using the second parameter. Auth::check('solital@egmail.com'); // Redirect to another router Auth::check('solital@egmail.com', '/redirect-to-another-router'); Logoff To logoff, use the Auth::logoff() method. Auth::logoff(); // Logoff an user Auth::logoff('solital@egmail.com'); // Redirect to another router Auth::logoff('solital@egmail.com', '/redirect-to-another-router'); Standard login structure To create a predefined login structure, use php vinci auth:skeleton --login This command will create a LoginController class, AuthMiddleware middleware, templates for authentication, dashboard and predefined routes. Plus a standard user in the database. If you want to remove this structure, use php vinci auth:skeleton --login --remove . Authentication using Sodium encryption The methods below are deprecated and will be removed in a future version 5.0 You can create an authentication using Sodium encryption. Generating a sodium key First, you need to generate a sodium key. This key is automatically renewed with each new request, so it can be stored in a database, in the session or in another type of storage. use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); Encrypting the password Use Auth::sodium() to encrypt your password. Remember to use it in conjunction with the generated key. use Solital\\Core\\Auth\\Auth; use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); $encoded = Auth::sodium('password', $key); pre($encoded); Verifying the password with Sodium To verify the password generated using the Auth::sodium() method, use Auth::sodiumVerify() together with the generated key, password and hash. use Solital\\Core\\Auth\\Auth; use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); $encoded = Auth::sodium('password', $key); $decoded = Auth::sodiumVerify($encoded, 'password', $key); pre($decoded);","title":"Authenticate"},{"location":"authenticate/#defining-the-routes","text":"You can define dashboard and login routes. The dashboard route will be for when the user authenticates, and the login route will be for when the user logs off and will be redirected to it. To do this, open the auth.yaml file and edit the auth_dashboard_url and auth_login_url variables. auth: auth_dashboard_url: /dashboard auth_login_url: /auth","title":"Defining the routes"},{"location":"authenticate/#setting","text":"For this, it is necessary to first define the name of the table in the login method. In the columns method, the database username and password. Then, in the values method, the input values of the form. Finally, the register method will perform the login as shown below. $res = Auth::login('auth_users') ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register(); You can also use the Model name in the login() method. This way, the Auth component will get the name of the table that is in the $table property. Solital uses the default Model AuthModel . However, you can create a model and use it in the login() method. use Solital\\Core\\Kernel\\Model\\AuthModel; $res = Auth::login(AuthModel::class) ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register(); The $res variable will return true if authentication is true and will redirect the user to the route defined in the auth_dashboard_url variable. But if it is false , you can add a reply message after the above code if authentication fails. if ($res == false) { message('login', 'Invalid username and/or password!'); response()->redirect('your_login_url'); }","title":"Setting"},{"location":"authenticate/#remembering-authentication","text":"In some cases the user wants to remain logged into the system after closing the browser. When registering a user, you can first use the remember method, passing the name of the form input as a parameter. In the value of the form input, use true . <input type=\"checkbox\" name=\"inputRemember\" value=\"true\"> $res = Auth::login(AuthModel::class) ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->remember('inputRemember') ->register(); Below is an example method of authentication. <input type=\"email\" name=\"inputEmail\"> <input type=\"password\" name=\"inputPassword\"> <input type=\"checkbox\" name=\"inputRemember\" value=\"true\"> <?php namespace Solital\\Components\\Controller; use Solital\\Core\\Http\\Controller\\Controller; use Solital\\Core\\Auth\\Auth; class UserController extends Controller { /** * @return void */ public function authPost(): void { $res = Auth::login(AuthModel::class) ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->remember('inputRemember') ->register(); if ($res == false) { message('login', 'Invalid username and/or password!'); response()->redirect(url('auth')); } } }","title":"Remembering authentication"},{"location":"authenticate/#changing-default-routes","text":"If you need more routes for dashboards and logins, you can change the parameter in the register() function: # In routers.php Course::get('/my-second-dashboard', 'SiteController@SecondDashboard')->name('second.dashboard'); # In Controller with `url()` helper $res = Auth::login(AuthModel::class) ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register(url('second.dashboard')); # Or without `url()` helper $res = Auth::login(AuthModel::class) ->columns('username', 'password') ->values('inputEmail', 'inputPassword') ->register('/my-second-dashboard');","title":"Changing default routes"},{"location":"authenticate/#check-login","text":"To check if the user exists, you can create a middleware and add the Auth::check() method. class AuthMiddleware implements BaseMiddlewareInterface { public function handle(): void { Auth::check(); } } The Auth::check method checks whether there is a user authenticating, but if you want to specify a user, you can pass the username in the first parameter. If the user is not authenticated, he will be redirected to the route defined in the auth_login_url variable. If you want to redirect to another route, you can define it using the second parameter. Auth::check('solital@egmail.com'); // Redirect to another router Auth::check('solital@egmail.com', '/redirect-to-another-router');","title":"Check login"},{"location":"authenticate/#logoff","text":"To logoff, use the Auth::logoff() method. Auth::logoff(); // Logoff an user Auth::logoff('solital@egmail.com'); // Redirect to another router Auth::logoff('solital@egmail.com', '/redirect-to-another-router');","title":"Logoff"},{"location":"authenticate/#standard-login-structure","text":"To create a predefined login structure, use php vinci auth:skeleton --login This command will create a LoginController class, AuthMiddleware middleware, templates for authentication, dashboard and predefined routes. Plus a standard user in the database. If you want to remove this structure, use php vinci auth:skeleton --login --remove .","title":"Standard login structure"},{"location":"authenticate/#authentication-using-sodium-encryption","text":"","title":"Authentication using Sodium encryption"},{"location":"authenticate/#generating-a-sodium-key","text":"First, you need to generate a sodium key. This key is automatically renewed with each new request, so it can be stored in a database, in the session or in another type of storage. use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey();","title":"Generating a sodium key"},{"location":"authenticate/#encrypting-the-password","text":"Use Auth::sodium() to encrypt your password. Remember to use it in conjunction with the generated key. use Solital\\Core\\Auth\\Auth; use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); $encoded = Auth::sodium('password', $key); pre($encoded);","title":"Encrypting the password"},{"location":"authenticate/#verifying-the-password-with-sodium","text":"To verify the password generated using the Auth::sodium() method, use Auth::sodiumVerify() together with the generated key, password and hash. use Solital\\Core\\Auth\\Auth; use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); $encoded = Auth::sodium('password', $key); $decoded = Auth::sodiumVerify($encoded, 'password', $key); pre($decoded);","title":"Verifying the password with Sodium"},{"location":"authorization/","text":"Introduction When we log in to a more complex system, this system generally has authorization levels for each user, that is, we have to ensure that only authenticated users can access specific pages. Solital has an authentication system to protect your user pages from other database tables. How to use You must use the Guardian class to authorize the pages. You can authorize using a specific database table or using a specific email. Authorize users of a database table For example, if you have a table in the database called tb_admin and you want only users who have been saved in that table to be allowed to access a specific page, you would use the allowFromTable method. Guardian::allowFromTable('tb_admin'); If you have users saved in another table (for example: tb_users ), these users will be redirected to the login page. When redirected, a message will be displayed to the unauthorized user. You can customize this message. Guardian::allowFromTable('tb_admin', 'No permission'); Deny users of a database table Alternatively, if you want users of a database table to not access a specific page, you can use the denyFromTable() method. Guardian::denyFromTable('tb_users'); // With a custom message Guardian::denyFromTable('tb_users', 'No permission'); Authorize or deny a specific user In some cases, you may want only a single specific user to be allowed to access a page rather than allowing multiple users of a database table. For these cases, you can use the allowUser() method. Guardian::allowUser('solital@email.com'); // With a custom message Guardian::allowUser('solital@email.com', 'No permission'); Alternatively, you can deny a single specific user instead of denying the entire database table. Guardian::denyUser('solital@email.com'); // With a custom message Guardian::denyUser('solital@email.com', 'No permission');","title":"Authorization"},{"location":"authorization/#introduction","text":"When we log in to a more complex system, this system generally has authorization levels for each user, that is, we have to ensure that only authenticated users can access specific pages. Solital has an authentication system to protect your user pages from other database tables.","title":"Introduction"},{"location":"authorization/#how-to-use","text":"You must use the Guardian class to authorize the pages. You can authorize using a specific database table or using a specific email.","title":"How to use"},{"location":"authorization/#authorize-users-of-a-database-table","text":"For example, if you have a table in the database called tb_admin and you want only users who have been saved in that table to be allowed to access a specific page, you would use the allowFromTable method. Guardian::allowFromTable('tb_admin'); If you have users saved in another table (for example: tb_users ), these users will be redirected to the login page. When redirected, a message will be displayed to the unauthorized user. You can customize this message. Guardian::allowFromTable('tb_admin', 'No permission');","title":"Authorize users of a database table"},{"location":"authorization/#deny-users-of-a-database-table","text":"Alternatively, if you want users of a database table to not access a specific page, you can use the denyFromTable() method. Guardian::denyFromTable('tb_users'); // With a custom message Guardian::denyFromTable('tb_users', 'No permission');","title":"Deny users of a database table"},{"location":"authorization/#authorize-or-deny-a-specific-user","text":"In some cases, you may want only a single specific user to be allowed to access a page rather than allowing multiple users of a database table. For these cases, you can use the allowUser() method. Guardian::allowUser('solital@email.com'); // With a custom message Guardian::allowUser('solital@email.com', 'No permission'); Alternatively, you can deny a single specific user instead of denying the entire database table. Guardian::denyUser('solital@email.com'); // With a custom message Guardian::denyUser('solital@email.com', 'No permission');","title":"Authorize or deny a specific user"},{"location":"browser-storage/","text":"Introduction In some cases, it may be necessary to manipulate javascript's localstorage and sessionstorage using PHP. You can do this using the BrowserStorage class. Usage Set item To store information locally or using a session, you can use one of the methods below: // localStorage.setItem('$key', $value); BrowserStorage::local()->setItem($key, $value); //sessionStorage.setItem('$key', $value); BrowserStorage::session()->setItem($key, $value); Get item To retrieve the information, use the getItem() method. BrowserStorage::local()->getItem($key); BrowserStorage::session()->getItem($key); Remove item To remove an item, use the removeItem() method. BrowserStorage::local()->removeItem($key); BrowserStorage::session()->removeItem($key); Clear storage To clear all storage, use the clear() or clearAll() method. BrowserStorage::local()->clear(); BrowserStorage::session()->clear(); // Clears local and session storage BrowserStorage::clearAll();","title":"Browser Storage"},{"location":"browser-storage/#introduction","text":"In some cases, it may be necessary to manipulate javascript's localstorage and sessionstorage using PHP. You can do this using the BrowserStorage class.","title":"Introduction"},{"location":"browser-storage/#usage","text":"Set item To store information locally or using a session, you can use one of the methods below: // localStorage.setItem('$key', $value); BrowserStorage::local()->setItem($key, $value); //sessionStorage.setItem('$key', $value); BrowserStorage::session()->setItem($key, $value); Get item To retrieve the information, use the getItem() method. BrowserStorage::local()->getItem($key); BrowserStorage::session()->getItem($key); Remove item To remove an item, use the removeItem() method. BrowserStorage::local()->removeItem($key); BrowserStorage::session()->removeItem($key); Clear storage To clear all storage, use the clear() or clearAll() method. BrowserStorage::local()->clear(); BrowserStorage::session()->clear(); // Clears local and session storage BrowserStorage::clearAll();","title":"Usage"},{"location":"cache/","text":"Cache is a layer of high-speed physical data storage that holds a subset of data, usually temporary in nature, so that future requests for that data are answered more quickly than is possible when accessing the primary storage location of data. Caching allows you to efficiently reuse previously recovered or computed data. How to use - PSR6/PSR-16 PSR-6 To use the PSR-6, you can follow the step by step guide here use Solital\\Core\\Cache\\Psr6\\CachePool; $pool = new CachePool(); $item = $pool->getItem('aaa'); $item->set(123); $pool->commit(); PSR-16 You can cache through PSR-16. To do this, perform the instance of the Cache class as follows: use Solital\\Cache\\SimpleCache; $cache = new SimpleCache(); // Or use `cache()` helper $list = User::select()->get(); // The 'has' method checks whether the index exists if ($cache->has('list') == true) { echo '<h1>from cache</h1>'; // The 'get' method returns the cached value if it exists $cache->get('list'); } else { echo '<h1>created cache</h1>'; // The 'set' method creates the cached file $cache->set('list', $list, 20); } // Displays the original content of the $list variable echo '<h1>from original</h1>'; var_dump($list); To delete the cache that was created, use the delete method passing the cache key as a parameter. $cache->delete('list'); The has method checks whether the item key exists. If it exists, use the get method to retrieve the generated cache by passing the key value as a parameter. If it does not exist, the set method creates the cached file, passing in the first parameter the name of the key, the value that will be stored and the time (in int ) that this cached file will be valid. The syntax is similar to the single cache. But the getMultiple method needs an array containing the key values as a parameter. The setMultiple method generates the cache if it does not exist, but pass as an parameter an array in which the keys will be the indexes of the array, and in the last parameter spend the time that the cache will be valid. use Solital\\Cache\\SimpleCache; $cache = new SimpleCache(); $list = [ 'nome' => 'Harvey Specter', 'email' => 'specter@pearsonhardman.com' ]; $list2 = [ 'nome' => 'Louis Litt', 'email' => 'liitup@pearsonhardman.com' ]; $cache->getMultiple(['list1', 'list2']); echo '<h1>created cache</h1>'; $cache->setMultiple([ 'list1' => $list, 'list2' => $list2 ], 20); echo '<h1>from original</h1>'; print_r($list); print_r($list2); In the multiple cache, use deleteMultiple by passing an array containing the cache keys to delete the cached files generated with the setMultiple method. $cache->deleteMultiple([\"list1\", \"list2\"]); Clear cache To clear the entire cache created with the Cache class, use the clear function. $cache->clear(); Cache drive To use the cache in Solital you will need to install a caching extension using PECL. To make life easier for developers, you can use the brenno-duarte/php-pecl-extensions package to install PECL extensions. composer require brenno-duarte/php-pecl-extensions To change the Solital cache drive, change the cache.yaml file in the app/config/ folder. Memcached/Memcache # Set cache type cache_drive: memcached # or `memcache` # Set host and port cache_host: 127.0.0.1 cache_port: 11211 APCu # Set cache type cache_drive: apcu # Set ttl cache_ttl: 600 Yac # Set cache type cache_drive: yac # Set ttl cache_ttl: 600 Or, you can choose the drive using the constructor of the CachePool , SimpleCache classes and the cache helper. $pool = new CachePool('memcached'); $cache = new SimpleCache('memcached'); cache('memcached'); // Return a `SimpleCache` instance HTTP Cache Font by heroku The modern day developer has a wide variety of techniques and technologies available to improve application performance and end-user experience. One of the most frequently overlooked technologies is that of the HTTP cache. HTTP caching is a universally adopted specification across all modern web browsers, making its implementation in web applications simple. Appropriate use of these standards can benefit your application greatly, improving response times and reducing server load. However, incorrect caching can cause users to see out-of-date content and hard to debug issues. This article discusses the specifics of HTTP caching and in what scenarios to employ an HTTP cache header based strategy. use Solital\\Core\\Http\\HttpCache; $cache = new HttpCache(); Cache-Control The Cache-Control header is the most important header to set as it effectively \u2018switches on\u2019 caching in the browser. With this header in place, and set with a value that enables caching, the browser will cache the file for as long as specified. Without this header the browser will re-request the file on each subsequent request. public resources can be cached not only by the end-user\u2019s browser but also by any intermediate proxies that may be serving many other users as well. private resources are bypassed by intermediate proxies and can only be cached by the end-client. The value of the Cache-Control header is a composite one, indicating whether the resource is public or private while also indicating the maximum amount of time it can be cached before considered stale. The max-age value sets a timespan for how long to cache the resource (in seconds). In the first parameter it is necessary to inform public or private , and in the second parameter the timestamp value of max_age . $cache->cacheControl(\"public\", 31536000); While the Cache-Control header turns on client-side caching and sets the max-age of a resource the Expires header is used to specify a specific point in time the resource is no longer valid. Expires When accompanying the Cache-Control header, Expires simply sets a date from which the cached resource should no longer be considered valid. From this date forward the browser will request a fresh copy of the resource. Until then, the browsers local cached copy will be used: $cache->cacheControl(\"public\", 31536000); $cache->expires(); Time-based A time-based conditional request ensures that only if the requested resource has changed since the browser\u2019s copy was cached will the contents be transferred. If the cached copy is the most up-to-date then the server returns the 304 response code. To enable conditional requests the application specifies the last modified time of a resource via the Last-Modified response header. To use this condition, use the lastModified method after the cacheControl method. $cache->cacheControl(\"public\", 31536000); $cache->lastModified(); The next time the browser requests this resource it will only ask for the contents of the resource if they\u2019re unchanged since this date using the If-Modified-Since request header $cache->ifModifiedSince(); If the resource hasn\u2019t changed, the server will return with an empty body with the 304 response code. Etag The ETag (or Entity Tag) works in a similar way to the Last-Modified header except its value is a digest of the resources contents (for instance, an MD5 hash). This allows the server to identify if the cached contents of the resource are different to the most recent version. Use the eTag class parameter the value that will be cached. $cache->cacheControl(\"public\", 31536000); $cache->eTag('value'); Cache prevention Highly secure or variable resources often require no caching. For instance, anything involving a shopping cart checkout process. Unfortunately, merely omitting cache headers will not work as many modern web browsers cache items based on their own internal algorithms. In such cases it is necessary to tell the browser to explicitly to not cache items. In addition to public and private the Cache-Control header can specify no-cache and no-store which informs the browser to not cache the resources under any circumstances. $cache->noCacheControl(); Clear Solital Cache When using your project several times, it is common for several stored session files to appear. These files are located inside the app/Storage/session folder. If you are using the Wolf cache, then these files can double in size. If you need to, you can use the Vinci Console to clear the general cache, just the session cache, or just the Wolf cache. To clear the session cache, use: php vinci storage:clear --session And to clear the cache of the app/Storage/cache folder, use the --cache option: php vinci storage:clear --cache","title":"Cache"},{"location":"cache/#how-to-use-psr6psr-16","text":"PSR-6 To use the PSR-6, you can follow the step by step guide here use Solital\\Core\\Cache\\Psr6\\CachePool; $pool = new CachePool(); $item = $pool->getItem('aaa'); $item->set(123); $pool->commit(); PSR-16 You can cache through PSR-16. To do this, perform the instance of the Cache class as follows: use Solital\\Cache\\SimpleCache; $cache = new SimpleCache(); // Or use `cache()` helper $list = User::select()->get(); // The 'has' method checks whether the index exists if ($cache->has('list') == true) { echo '<h1>from cache</h1>'; // The 'get' method returns the cached value if it exists $cache->get('list'); } else { echo '<h1>created cache</h1>'; // The 'set' method creates the cached file $cache->set('list', $list, 20); } // Displays the original content of the $list variable echo '<h1>from original</h1>'; var_dump($list); To delete the cache that was created, use the delete method passing the cache key as a parameter. $cache->delete('list'); The has method checks whether the item key exists. If it exists, use the get method to retrieve the generated cache by passing the key value as a parameter. If it does not exist, the set method creates the cached file, passing in the first parameter the name of the key, the value that will be stored and the time (in int ) that this cached file will be valid. The syntax is similar to the single cache. But the getMultiple method needs an array containing the key values as a parameter. The setMultiple method generates the cache if it does not exist, but pass as an parameter an array in which the keys will be the indexes of the array, and in the last parameter spend the time that the cache will be valid. use Solital\\Cache\\SimpleCache; $cache = new SimpleCache(); $list = [ 'nome' => 'Harvey Specter', 'email' => 'specter@pearsonhardman.com' ]; $list2 = [ 'nome' => 'Louis Litt', 'email' => 'liitup@pearsonhardman.com' ]; $cache->getMultiple(['list1', 'list2']); echo '<h1>created cache</h1>'; $cache->setMultiple([ 'list1' => $list, 'list2' => $list2 ], 20); echo '<h1>from original</h1>'; print_r($list); print_r($list2); In the multiple cache, use deleteMultiple by passing an array containing the cache keys to delete the cached files generated with the setMultiple method. $cache->deleteMultiple([\"list1\", \"list2\"]);","title":"How to use - PSR6/PSR-16"},{"location":"cache/#clear-cache","text":"To clear the entire cache created with the Cache class, use the clear function. $cache->clear();","title":"Clear cache"},{"location":"cache/#cache-drive","text":"To use the cache in Solital you will need to install a caching extension using PECL. To make life easier for developers, you can use the brenno-duarte/php-pecl-extensions package to install PECL extensions. composer require brenno-duarte/php-pecl-extensions To change the Solital cache drive, change the cache.yaml file in the app/config/ folder. Memcached/Memcache # Set cache type cache_drive: memcached # or `memcache` # Set host and port cache_host: 127.0.0.1 cache_port: 11211 APCu # Set cache type cache_drive: apcu # Set ttl cache_ttl: 600 Yac # Set cache type cache_drive: yac # Set ttl cache_ttl: 600 Or, you can choose the drive using the constructor of the CachePool , SimpleCache classes and the cache helper. $pool = new CachePool('memcached'); $cache = new SimpleCache('memcached'); cache('memcached'); // Return a `SimpleCache` instance","title":"Cache drive"},{"location":"cache/#http-cache","text":"Font by heroku The modern day developer has a wide variety of techniques and technologies available to improve application performance and end-user experience. One of the most frequently overlooked technologies is that of the HTTP cache. HTTP caching is a universally adopted specification across all modern web browsers, making its implementation in web applications simple. Appropriate use of these standards can benefit your application greatly, improving response times and reducing server load. However, incorrect caching can cause users to see out-of-date content and hard to debug issues. This article discusses the specifics of HTTP caching and in what scenarios to employ an HTTP cache header based strategy. use Solital\\Core\\Http\\HttpCache; $cache = new HttpCache();","title":"HTTP Cache"},{"location":"cache/#cache-control","text":"The Cache-Control header is the most important header to set as it effectively \u2018switches on\u2019 caching in the browser. With this header in place, and set with a value that enables caching, the browser will cache the file for as long as specified. Without this header the browser will re-request the file on each subsequent request. public resources can be cached not only by the end-user\u2019s browser but also by any intermediate proxies that may be serving many other users as well. private resources are bypassed by intermediate proxies and can only be cached by the end-client. The value of the Cache-Control header is a composite one, indicating whether the resource is public or private while also indicating the maximum amount of time it can be cached before considered stale. The max-age value sets a timespan for how long to cache the resource (in seconds). In the first parameter it is necessary to inform public or private , and in the second parameter the timestamp value of max_age . $cache->cacheControl(\"public\", 31536000); While the Cache-Control header turns on client-side caching and sets the max-age of a resource the Expires header is used to specify a specific point in time the resource is no longer valid.","title":"Cache-Control"},{"location":"cache/#expires","text":"When accompanying the Cache-Control header, Expires simply sets a date from which the cached resource should no longer be considered valid. From this date forward the browser will request a fresh copy of the resource. Until then, the browsers local cached copy will be used: $cache->cacheControl(\"public\", 31536000); $cache->expires();","title":"Expires"},{"location":"cache/#time-based","text":"A time-based conditional request ensures that only if the requested resource has changed since the browser\u2019s copy was cached will the contents be transferred. If the cached copy is the most up-to-date then the server returns the 304 response code. To enable conditional requests the application specifies the last modified time of a resource via the Last-Modified response header. To use this condition, use the lastModified method after the cacheControl method. $cache->cacheControl(\"public\", 31536000); $cache->lastModified(); The next time the browser requests this resource it will only ask for the contents of the resource if they\u2019re unchanged since this date using the If-Modified-Since request header $cache->ifModifiedSince(); If the resource hasn\u2019t changed, the server will return with an empty body with the 304 response code.","title":"Time-based"},{"location":"cache/#etag","text":"The ETag (or Entity Tag) works in a similar way to the Last-Modified header except its value is a digest of the resources contents (for instance, an MD5 hash). This allows the server to identify if the cached contents of the resource are different to the most recent version. Use the eTag class parameter the value that will be cached. $cache->cacheControl(\"public\", 31536000); $cache->eTag('value');","title":"Etag"},{"location":"cache/#cache-prevention","text":"Highly secure or variable resources often require no caching. For instance, anything involving a shopping cart checkout process. Unfortunately, merely omitting cache headers will not work as many modern web browsers cache items based on their own internal algorithms. In such cases it is necessary to tell the browser to explicitly to not cache items. In addition to public and private the Cache-Control header can specify no-cache and no-store which informs the browser to not cache the resources under any circumstances. $cache->noCacheControl();","title":"Cache prevention"},{"location":"cache/#clear-solital-cache","text":"When using your project several times, it is common for several stored session files to appear. These files are located inside the app/Storage/session folder. If you are using the Wolf cache, then these files can double in size. If you need to, you can use the Vinci Console to clear the general cache, just the session cache, or just the Wolf cache. To clear the session cache, use: php vinci storage:clear --session And to clear the cache of the app/Storage/cache folder, use the --cache option: php vinci storage:clear --cache","title":"Clear Solital Cache"},{"location":"collection/","text":"Collection is a feature of Solital for creating custom data. It will make your life easier by providing personalized data without complexity in your data. Let's see a quick example: use Solital\\Core\\Resource\\Collection\\ArrayCollection; $values = [ ['account_id' => 'account-x10', 'product' => 'Chair'], ['account_id' => 'account-x10', 'product' => 'Bookcase'], ['account_id' => 'account-x11', 'product' => 'Desk'], ]; $collection = new ArrayCollection($values); // Or use helper $collection = collection($values); $grouped = $collection->groupBy('account_id')->toArray(); pre($grouped); OUTPUT Array ( [account-x10] => Array ( [0] => Array ( [account_id] => account-x10 [product] => Chair ) [1] => Array ( [account_id] => account-x10 [product] => Bookcase ) ) [account-x11] => Array ( [0] => Array ( [account_id] => account-x11 [product] => Desk ) ) ) all() The all method returns the underlying array represented by the data array: collection([1, 2, 3])->all(); avg() The avg method returns the average value of a given key: collection([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->avg('foo'); Output 20 collection([1, 1, 2, 4])->avg(); Output 2 chunk() The chunk method breaks into multiple collection([1, 2, 3, 4, 5, 6, 7]); $chunks = $make_data->chunk(4); $chunks->toArray(); Output [[1, 2, 3, 4], [5, 6, 7]] collapse() The collapse method collapses a data array of arrays into a single, flat data array: collection([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); $collapsed = $make_data->collapse(); $collapsed->all(); Output [1, 2, 3, 4, 5, 6, 7, 8, 9] combine() The combine method combines the values of the data array, as keys, with the values of another array or data array: collection(['name', 'age']); $combined = $make_data->combine(['George', 29]); $combined->all(); Output ['name' => 'George', 'age' => 29] concat() The concat method appends the given array or data array values onto the end of the data array: collection(['John Doe']); $concatenated = $make_data->concat(['Jane Doe'])->concat(['name' => 'Johnny Doe']); $concatenated->all(); Output ['John Doe', 'Jane Doe', 'Johnny Doe'] contains() The contains method determines whether the make_data contains a given item: collection(['name' => 'Desk', 'price' => 100]); $make_data->contains('Desk'); $make_data->contains('New York'); Output true false count() The count method returns the total number of items in the data array: collection([1, 2, 3, 4]); $make_data->count(); Output 4 countBy() The countBy method counts the occurences of values in the make_data. By default, the method counts the occurrences of every element: collection([1, 2, 2, 2, 3]); $counted = $make_data->countBy(); $counted->all(); Output [1 => 1, 2 => 3, 3 => 1] diff() The diff method compares the data array against another data array or a plain PHP array based on its values. This method will return the values in the original data that are not present in the given data array: collection([1, 2, 3, 4, 5]); $diff = $make_data->diff([2, 4, 6, 8]); $diff->all(); Output [1, 3, 5] diffAssoc() The diffAssoc method compares the data array against another data array or a plain PHP array based on its keys and values. This method will return the key / value pairs in the original data array that are not present in the given data array: collection([ 'color' => 'orange', 'type' => 'fruit', 'remain' => 6 ]); $diff = $make_data->diffAssoc([ 'color' => 'yellow', 'type' => 'fruit', 'remain' => 3, 'used' => 6 ]); $diff->all(); Output ['color' => 'orange', 'remain' => 6] diffKeys() The diffKeys method compares the data array against another data array or a plain PHP array based on its keys. This method will return the key / value pairs in the original data array that are not present in the given data array collection([ 'one' => 10, 'two' => 20, 'three' => 30, 'four' => 40, 'five' => 50, ]); $diff = $diff->diffKeys([ 'two' => 2, 'four' => 4, 'six' => 6, 'eight' => 8, ]); $diff->all(); Output ['one' => 10, 'three' => 30, 'five' => 50] except() The except method returns all items in the data array except for those with the specified keys: collection(['product_id' => 1, 'price' => 100, 'discount' => false]); $filtered = $make_data->except(['price', 'discount']); $filtered->all(); Output ['product_id' => 1] except_multiple() The except_multiple method returns all items in the data array except for those with the specified keys: collection([ ['product_id' => 1, 'price' => 100, 'discount' => false], ['product_id' => 2, 'price' => 500, 'discount' => true] ]); $filtered = $make_data->except_multiple(['price', 'discount']); $filtered->all(); Output Array ( [0] => Array ( [product_id] => 1 ) [1] => Array ( [product_id] => 2 ) ) filter() The filter method filters the data array using the given callback, keeping only those items that pass a given truth test: collection([1, 2, 3, 4]); $filtered = $make_data->filter(function ($value, $key) { return $value > 2; }); $filtered->all(); Output [3, 4] first() The first method returns the first element in the data array that passes a given truth test: collection([1, 2, 3, 4])->first(function ($value, $key) { return $value > 2; }); Output 3 firstWhere() The firstWhere method returns the first element in the data array with the given key / value pair: collection([ ['name' => 'Regena', 'age' => null], ['name' => 'Linda', 'age' => 14], ['name' => 'Diego', 'age' => 23], ['name' => 'Linda', 'age' => 84], ]); $make_data->firstWhere('name', 'Linda'); Output ['name' => 'Linda', 'age' => 14] flatMap() The flatMap method iterates through the data array and passes each value to the given callback. The callback is free to modify the item and return it, thus forming a new data array of modified items. Then, the array is flattened by a level: collection([ ['name' => 'Sally'], ['school' => 'Arkansas'], ['age' => 28] ]); $flattened = $make_data->flatMap(function ($values) { return array_map('strtoupper', $values); }); $flattened->all(); Output ['name' => 'SALLY', 'school' => 'ARKANSAS', 'age' => '28']; flatten() The flatten method flattens a multi-dimensional data array into a single dimension: collection(['name' => 'jony', 'languages' => ['php', 'javascript']]); $flattened = $make_data->flatten(); $flattened->all(); Output ['jony', 'php', 'javascript']; flip() The flip method swaps the data arrays's keys with their corresponding values: collection(['name' => 'Jony', 'library' => 'array_master']); $flipped = $make_data->flip(); $flipped->all(); Output ['jony' => 'name', 'array_master' => 'library'] forget() The forget method removes an item from the data array by its key: collection(['name' => 'Jony', 'library' => 'array_master']); $make_data->forget('name'); $make_data->all(); Output ['library' => 'array_master'] get() The get method returns the item at a given key. If the key does not exist, null is returned: collection(['name' => 'Jony', 'library' => 'array_master']); $value = $make_data->get('name'); Output Jony groupBy() The groupBy method groups the data arrays's items by a given key: collection([ ['account_id' => 'account-x10', 'product' => 'Chair'], ['account_id' => 'account-x10', 'product' => 'Bookcase'], ['account_id' => 'account-x11', 'product' => 'Desk'], ]); $grouped = $make_data->groupBy('account_id'); $grouped->toArray(); Output [ 'account-x10' => [ ['account_id' => 'account-x10', 'product' => 'Chair'], ['account_id' => 'account-x10', 'product' => 'Bookcase'], ], 'account-x11' => [ ['account_id' => 'account-x11', 'product' => 'Desk'], ], ] has() The has method determines if a given key exists in the data array: collection(['account_id' => 1, 'product' => 'Desk', 'amount' => 5]); $make_data->has('product'); Output true implode() The implode method joins the items in a dara array. Its arguments depend on the type of items in the dara array. If the data array contains arrays or objects, you should pass the key of the attributes you wish to join, and the \"glue\" string you wish to place between the values: collection([ ['account_id' => 1, 'product' => 'Desk'], ['account_id' => 2, 'product' => 'Chair'], ]); $make_data->implode('product', ', '); Output Desk, Chair intersect() The intersect method removes any values from the original data array that are not present in the given array or dara array. The resulting data array will preserve the original dara array's keys: collection(['Desk', 'Sofa', 'Chair']); $intersect = $make_data->intersect(['Desk', 'Chair', 'Bookcase']); $intersect->all(); Output [0 => 'Desk', 2 => 'Chair'] intersectByKeys() The intersectByKeys method removes any keys from the original data array that are not present in the given array or dara array: collection([ 'serial' => 'UX301', 'type' => 'screen', 'year' => 2009 ]); $intersect = $make_data->intersectByKeys([ 'reference' => 'UX404', 'type' => 'tab', 'year' => 2011 ]); $intersect->all(); Output ['type' => 'screen', 'year' => 2009] isEmpty() The isEmpty method returns true if the data array is empty; otherwise, false is returned: collection([])->isEmpty(); Output true isNotEmpty() The isNotEmpty method returns true if the data array is not empty; otherwise, false is returned: collection([])->isNotEmpty(); Output false keyBy() The keyBy method keys the data array by the given key. If multiple items have the same key, only the last one will appear in the new dara array: collection([ ['product_id' => 'prod-100', 'name' => 'Desk'], ['product_id' => 'prod-200', 'name' => 'Chair'], ]); $keyed = $make_data->keyBy('product_id'); $keyed->all(); Output [ 'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'], 'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'], ] keys() The keys method returns all of the data array's keys: collection([ 'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'], 'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'], ]); $keys = $make_data->keys(); Output ['prod-100', 'prod-200'] last() The last method returns the last element in the data array that passes a given truth test: collection([1, 2, 3, 4])->last(); Output 4 map() The map method iterates through the data array and passes each value to the given callback. The callback is free to modify the item and return it, thus forming a new data array of modified items: collection([1, 2, 3, 4, 5]); $multiplied = $make_data->map(function ($item, $key) { return $item * 2; }); $multiplied->all(); Output [2, 4, 6, 8, 10] mapWithKeys() collection([ [ 'name' => 'John', 'department' => 'Sales', 'email' => 'john@example.com' ], [ 'name' => 'Jane', 'department' => 'Marketing', 'email' => 'jane@example.com' ] ]); $keyed = $make_data->mapWithKeys(function ($item) { return [$item['email'] => $item['name']]; }); $keyed->all(); Output [ 'john@example.com' => 'John', 'jane@example.com' => 'Jane', ] max() The max method returns the maximum value of a given key: collection([['foo' => 10], ['foo' => 20]])->max('foo'); collection([['foo' => 10], ['foo' => 30]])->max('foo'); Output 20 30 median() The median method returns the median value of a given key: collection([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->median('foo'); Output 15 merge() collection(['product_id' => 1, 'price' => 100]); $merged = $make_data->merge(['price' => 200, 'discount' => false]); $merged->all(); Output ['product_id' => 1, 'price' => 200, 'discount' => false] min() The min method returns the minimum value of a given key: collection([['foo' => 10], ['foo' => 20]])->min('foo'); collection([1, 2, 3, 4, 5])->min(); Output 10 1 mode() The mode method returns the mode value of a given key: collection([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->mode('foo'); collection([1, 1, 2, 4])->mode(); Output [10] [1] only() The only method returns the items in the data array with the specified keys: collection(['product_id' => 1, 'name' => 'Desk', 'price' => 100, 'discount' => false]); $filtered = $make_data->only(['product_id', 'name']); $filtered->all(); Output ['product_id' => 1, 'name' => 'Desk'] pad() collection(['A', 'B', 'C']); $filtered = $make_data->pad(5, 0); $filtered->all(); Output ['A', 'B', 'C', 0, 0] partition() The partition method may be combined with the list PHP function to separate elements that pass a given truth test from those that do not: collection([1, 2, 3, 4, 5, 6]); list($underThree, $equalOrAboveThree) = $make_data->partition(function ($i) { return $i < 3; }); $underThree->all(); $equalOrAboveThree->all(); Output [1, 2] [3, 4, 5, 6] pipe() The pipe method passes the data array to the given callback and returns the result: collection([1, 2, 3]); $piped = $make_data->pipe(function ($make_data) { return $make_data->sum(); }); Output 6 pluck() The pluck method retrieves all of the values for a given key: collection([ ['product_id' => 'prod-100', 'name' => 'Desk'], ['product_id' => 'prod-200', 'name' => 'Chair'], ]); $plucked = $make_data->pluck('name'); $plucked->all(); Output ['Desk', 'Chair'] pop() The pop method removes and returns the last item from the data array: collection([1, 2, 3, 4, 5]); $make_data->pop(); $make_data->all(); Output 5 [1, 2, 3, 4] prepend() The prepend method adds an item to the beginning of the data array: collection([1, 2, 3, 4, 5]); $make_data->prepend(0); $make_data->all(); Output [0, 1, 2, 3, 4, 5] pull() The pull method removes and returns an item from the data array by its key: collection(['product_id' => 'prod-100', 'name' => 'Desk']); $make_data->pull('name'); $make_data->all(); Output 'Desk' ['product_id' => 'prod-100'] push() The push method appends an item to the end of the data array: collection([1, 2, 3, 4]); $make_data->push(5); $make_data->all(); Output [1, 2, 3, 4, 5] put() The put method sets the given key and value in the data array: collection(['product_id' => 1, 'name' => 'Desk']); $make_data->put('price', 100); $make_data->all(); Output ['product_id' => 1, 'name' => 'Desk', 'price' => 100] random() The random method returns a random item from the data array: collection([1, 2, 3, 4, 5]); $make_data->random(); Output 4 - (retrieved randomly) reduce() The reduce method reduces the data array to a single value, passing the result of each iteration into the subsequent iteration: collection([1, 2, 3]); $total = $make_data->reduce(function ($carry, $item) { return $carry + $item; }); Output 6 reject() The reject method filters the data array using the given callback. The callback should return true if the item should be removed from the resulting data array: collection([1, 2, 3, 4]); $filtered = $make_data->reject(function ($value, $key) { return $value > 2; }); $filtered->all(); Output [1, 2] reverse() The reverse method reverses the order of the data array's items, preserving the original keys: collection(['a', 'b', 'c', 'd', 'e']); $reversed = $make_data->reverse(); $reversed->all(); Output [ 4 => 'e', 3 => 'd', 2 => 'c', 1 => 'b', 0 => 'a', ] search() The search method searches the data array for the given value and returns its key if found. If the item is not found, false is returned. collection([2, 4, 6, 8]); $make_data->search(4); Output 1 shift() The shift method removes and returns the first item from the data array: collection([1, 2, 3, 4, 5]); $make_data->shift(); $make_data->all(); Output 1 [2, 3, 4, 5] shuffle() The shuffle method randomly shuffles the items in the data array: collection([1, 2, 3, 4, 5]); $shuffled = $make_data->shuffle(); $shuffled->all(); Output [3, 2, 5, 1, 4] - (generated randomly) slice() The slice method returns a slice of the data array starting at the given index: collection([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); $slice = $make_data->slice(4); $slice->all(); Output [5, 6, 7, 8, 9, 10] sort() The sort method sorts the data array. The sorted data array keeps the original array keys, so in this example we'll use the values method to reset the keys to consecutively numbered indexes: collection([5, 3, 1, 2, 4]); $sorted = $make_data->sort(); $sorted->values()->all(); Output [1, 2, 3, 4, 5] sortBy() collection([ ['name' => 'Desk', 'price' => 200], ['name' => 'Chair', 'price' => 100], ['name' => 'Bookcase', 'price' => 150], ]); $sorted = $make_data->sortBy('price'); $sorted->values()->all(); Output [ ['name' => 'Chair', 'price' => 100], ['name' => 'Bookcase', 'price' => 150], ['name' => 'Desk', 'price' => 200], ] sortByDesc() This method has the same signature as the sortBy method, but will sort the collection in the opposite order. sortKeys() The sortKeys method sorts the data array by the keys of the underlying associative array: collection([ 'id' => 22345, 'first' => 'John', 'last' => 'Doe', ]); $sorted = $make_data->sortKeys(); $sorted->all(); Output [ 'first' => 'John', 'id' => 22345, 'last' => 'Doe', ] splice() The splice method removes and returns a slice of items starting at the specified index: collection([1, 2, 3, 4, 5]); $chunk = $make_data->splice(2); $chunk->all(); Output [3, 4, 5] split() The split method breaks a data array into the given number of groups: collection([1, 2, 3, 4, 5]); $groups = $make_data->split(3); $groups->toArray(); Output [[1, 2], [3, 4], [5]] sum() The sum method returns the sum of all items in the data array: ............................. collection([1, 2, 3, 4, 5])->sum(); ............................. collection([ ['name' => 'JavaScript: The Good Parts', 'pages' => 176], ['name' => 'JavaScript: The Definitive Guide', 'pages' => 1096], ]); $make_data->sum('pages'); ............................. collection([ ['name' => 'Chair', 'colors' => ['Black']], ['name' => 'Desk', 'colors' => ['Black', 'Mahogany']], ['name' => 'Bookcase', 'colors' => ['Red', 'Beige', 'Brown']], ]); $make_data->sum(function ($product) { return count($product['colors']); }); Output 15 1272 6 take() The take method returns a new data array with the specified number of items: collection([0, 1, 2, 3, 4, 5]); $chunk = $make_data->take(3); $chunk->all(); Output [0, 1, 2] tap() The tap method passes the data array to the given callback, allowing you to \"tap\" into the data array at a specific point and do something with the items while not affecting the data array itself: collection([2, 4, 3, 1, 5]) ->sort() ->tap(function ($make_data) { Log::debug('Values after sorting', $make_data->values()->toArray()); }) ->shift(); Output 1 times() The static times method creates a new data array by invoking the callback a given amount of times: $make_data = Collection::times(10, function ($number) { return $number * 9; }); $make_data->all(); Output [9, 18, 27, 36, 45, 54, 63, 72, 81, 90] toJson() The toJson method converts the data array into a JSON serialized string: collection(['name' => 'Desk', 'price' => 200]); $make_data->toJson(); Output '{\"name\":\"Desk\", \"price\":200}' transform() The transform method iterates over the data array and calls the given callback with each item in the data array. The items in the data array will be replaced by the values returned by the callback: collection([1, 2, 3, 4, 5]); $make_data->transform(function ($item, $key) { return $item * 2; }); $make_data->all(); Output [2, 4, 6, 8, 10] union() union() The union method adds the given array to the data array. If the given array contains keys that are already in the original data array, the original data array's values will be preferred: collection([1 => ['a'], 2 => ['b']]); $union = $make_data->union([3 => ['c'], 1 => ['b']]); $union->all(); Output [1 => ['a'], 2 => ['b'], 3 => ['c']] unique() The only method returns the items in the data array with the specified keys: collection([1, 1, 2, 2, 3, 4, 2]); $unique = $make_data->unique(); $unique->values()->all(); collection([ ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'], ['name' => 'iPhone 5', 'brand' => 'Apple', 'type' => 'phone'], ['name' => 'Apple Watch', 'brand' => 'Apple', 'type' => 'watch'], ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'], ['name' => 'Galaxy Gear', 'brand' => 'Samsung', 'type' => 'watch'], ]); $unique = $make_data->unique('brand'); $unique->values()->all(); Output [1, 2, 3, 4] [ ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'], ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'], ] unless() The unless method will execute the given callback unless the first argument given to the method evaluates to true: collection([1, 2, 3]); $make_data->unless(true, function ($make_data) { return $make_data->push(4); }); $make_data->unless(false, function ($make_data) { return $make_data->push(5); }); $make_data->all(); Output [1, 2, 3, 5] values() The values method returns a new data array with the keys reset to consecutive integers: collection([ 10 => ['product' => 'Desk', 'price' => 200], 11 => ['product' => 'Desk', 'price' => 200] ]); $values = $make_data->values(); $values->all(); Output [ 0 => ['product' => 'Desk', 'price' => 200], 1 => ['product' => 'Desk', 'price' => 200], ] when() The when method will execute the given callback when the first argument given to the method evaluates to true: collection([1, 2, 3]); $make_data->when(true, function ($make_data) { return $make_data->push(4); }); $make_data->when(false, function ($make_data) { return $make_data->push(5); }); $make_data->all(); Output [1, 2, 3, 4] whenEmpty() The whenEmpty method will execute the given callback when the data array is empty: collection(['michael', 'tom']); $make_data->whenEmpty(function ($make_data) { return $make_data->push('adam'); }); $make_data->all(); // ['michael', 'tom'] $make_data = make_data); $make_data->whenEmpty(function ($make_data) { return $make_data->push('adam'); }); $make_data->all(); Output ['adam'] whenNotEmpty() The whenNotEmpty method will execute the given callback when the data array is not empty: collection(['michael', 'tom']); $make_data->whenNotEmpty(function ($make_data) { return $make_data->push('adam'); }); $make_data->all(); Output ['michael', 'tom', 'adam'] where() The where method filters the data array by a given key / value pair: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 100], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->where('price', 100); $filtered->all(); Output [ ['product' => 'Chair', 'price' => 100], ['product' => 'Door', 'price' => 100], ] whereBetween() The whereBetween method filters the data array within a given range: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 80], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Pencil', 'price' => 30], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereBetween('price', [100, 200]); $filtered->all(); Output [ ['product' => 'Desk', 'price' => 200], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ] whereIn() The whereIn method filters the data array by a given key / value contained within the given array: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 100], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereIn('price', [150, 200]); $filtered->all(); Output [ ['product' => 'Bookcase', 'price' => 150], ['product' => 'Desk', 'price' => 200], ] whereNotBetween() The whereNotBetween method filters the data array within a given range: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 80], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Pencil', 'price' => 30], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereNotBetween('price', [100, 200]); $filtered->all(); Output [ ['product' => 'Chair', 'price' => 80], ['product' => 'Pencil', 'price' => 30], ] whereNotIn() The whereNotIn method filters the data array by a given key / value not contained within the given array: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 100], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereNotIn('price', [150, 200]); $filtered->all(); Output ['product_id' => 1, 'name' => 'Desk'] wrap() The static wrap method wraps the given value in a data array when applicable: $make_data = Collection::wrap('John Doe'); $make_data->all(); Output ['John Doe'] zip() The zip method merges together the values of the given array with the values of the original data array at the corresponding index: collection(['Chair', 'Desk']); $zipped = $make_data->zip([100, 200]); $zipped->all(); Output [['Chair', 100], ['Desk', 200]]","title":"Collection"},{"location":"collection/#all","text":"The all method returns the underlying array represented by the data array: collection([1, 2, 3])->all();","title":"all()"},{"location":"collection/#avg","text":"The avg method returns the average value of a given key: collection([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->avg('foo'); Output 20 collection([1, 1, 2, 4])->avg(); Output 2","title":"avg()"},{"location":"collection/#chunk","text":"The chunk method breaks into multiple collection([1, 2, 3, 4, 5, 6, 7]); $chunks = $make_data->chunk(4); $chunks->toArray(); Output [[1, 2, 3, 4], [5, 6, 7]]","title":"chunk()"},{"location":"collection/#collapse","text":"The collapse method collapses a data array of arrays into a single, flat data array: collection([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); $collapsed = $make_data->collapse(); $collapsed->all(); Output [1, 2, 3, 4, 5, 6, 7, 8, 9]","title":"collapse()"},{"location":"collection/#combine","text":"The combine method combines the values of the data array, as keys, with the values of another array or data array: collection(['name', 'age']); $combined = $make_data->combine(['George', 29]); $combined->all(); Output ['name' => 'George', 'age' => 29]","title":"combine()"},{"location":"collection/#concat","text":"The concat method appends the given array or data array values onto the end of the data array: collection(['John Doe']); $concatenated = $make_data->concat(['Jane Doe'])->concat(['name' => 'Johnny Doe']); $concatenated->all(); Output ['John Doe', 'Jane Doe', 'Johnny Doe']","title":"concat()"},{"location":"collection/#contains","text":"The contains method determines whether the make_data contains a given item: collection(['name' => 'Desk', 'price' => 100]); $make_data->contains('Desk'); $make_data->contains('New York'); Output true false","title":"contains()"},{"location":"collection/#count","text":"The count method returns the total number of items in the data array: collection([1, 2, 3, 4]); $make_data->count(); Output 4","title":"count()"},{"location":"collection/#countby","text":"The countBy method counts the occurences of values in the make_data. By default, the method counts the occurrences of every element: collection([1, 2, 2, 2, 3]); $counted = $make_data->countBy(); $counted->all(); Output [1 => 1, 2 => 3, 3 => 1]","title":"countBy()"},{"location":"collection/#diff","text":"The diff method compares the data array against another data array or a plain PHP array based on its values. This method will return the values in the original data that are not present in the given data array: collection([1, 2, 3, 4, 5]); $diff = $make_data->diff([2, 4, 6, 8]); $diff->all(); Output [1, 3, 5]","title":"diff()"},{"location":"collection/#diffassoc","text":"The diffAssoc method compares the data array against another data array or a plain PHP array based on its keys and values. This method will return the key / value pairs in the original data array that are not present in the given data array: collection([ 'color' => 'orange', 'type' => 'fruit', 'remain' => 6 ]); $diff = $make_data->diffAssoc([ 'color' => 'yellow', 'type' => 'fruit', 'remain' => 3, 'used' => 6 ]); $diff->all(); Output ['color' => 'orange', 'remain' => 6]","title":"diffAssoc()"},{"location":"collection/#diffkeys","text":"The diffKeys method compares the data array against another data array or a plain PHP array based on its keys. This method will return the key / value pairs in the original data array that are not present in the given data array collection([ 'one' => 10, 'two' => 20, 'three' => 30, 'four' => 40, 'five' => 50, ]); $diff = $diff->diffKeys([ 'two' => 2, 'four' => 4, 'six' => 6, 'eight' => 8, ]); $diff->all(); Output ['one' => 10, 'three' => 30, 'five' => 50]","title":"diffKeys()"},{"location":"collection/#except","text":"The except method returns all items in the data array except for those with the specified keys: collection(['product_id' => 1, 'price' => 100, 'discount' => false]); $filtered = $make_data->except(['price', 'discount']); $filtered->all(); Output ['product_id' => 1]","title":"except()"},{"location":"collection/#except_multiple","text":"The except_multiple method returns all items in the data array except for those with the specified keys: collection([ ['product_id' => 1, 'price' => 100, 'discount' => false], ['product_id' => 2, 'price' => 500, 'discount' => true] ]); $filtered = $make_data->except_multiple(['price', 'discount']); $filtered->all(); Output Array ( [0] => Array ( [product_id] => 1 ) [1] => Array ( [product_id] => 2 ) )","title":"except_multiple()"},{"location":"collection/#filter","text":"The filter method filters the data array using the given callback, keeping only those items that pass a given truth test: collection([1, 2, 3, 4]); $filtered = $make_data->filter(function ($value, $key) { return $value > 2; }); $filtered->all(); Output [3, 4]","title":"filter()"},{"location":"collection/#first","text":"The first method returns the first element in the data array that passes a given truth test: collection([1, 2, 3, 4])->first(function ($value, $key) { return $value > 2; }); Output 3","title":"first()"},{"location":"collection/#firstwhere","text":"The firstWhere method returns the first element in the data array with the given key / value pair: collection([ ['name' => 'Regena', 'age' => null], ['name' => 'Linda', 'age' => 14], ['name' => 'Diego', 'age' => 23], ['name' => 'Linda', 'age' => 84], ]); $make_data->firstWhere('name', 'Linda'); Output ['name' => 'Linda', 'age' => 14]","title":"firstWhere()"},{"location":"collection/#flatmap","text":"The flatMap method iterates through the data array and passes each value to the given callback. The callback is free to modify the item and return it, thus forming a new data array of modified items. Then, the array is flattened by a level: collection([ ['name' => 'Sally'], ['school' => 'Arkansas'], ['age' => 28] ]); $flattened = $make_data->flatMap(function ($values) { return array_map('strtoupper', $values); }); $flattened->all(); Output ['name' => 'SALLY', 'school' => 'ARKANSAS', 'age' => '28'];","title":"flatMap()"},{"location":"collection/#flatten","text":"The flatten method flattens a multi-dimensional data array into a single dimension: collection(['name' => 'jony', 'languages' => ['php', 'javascript']]); $flattened = $make_data->flatten(); $flattened->all(); Output ['jony', 'php', 'javascript'];","title":"flatten()"},{"location":"collection/#flip","text":"The flip method swaps the data arrays's keys with their corresponding values: collection(['name' => 'Jony', 'library' => 'array_master']); $flipped = $make_data->flip(); $flipped->all(); Output ['jony' => 'name', 'array_master' => 'library']","title":"flip()"},{"location":"collection/#forget","text":"The forget method removes an item from the data array by its key: collection(['name' => 'Jony', 'library' => 'array_master']); $make_data->forget('name'); $make_data->all(); Output ['library' => 'array_master']","title":"forget()"},{"location":"collection/#get","text":"The get method returns the item at a given key. If the key does not exist, null is returned: collection(['name' => 'Jony', 'library' => 'array_master']); $value = $make_data->get('name'); Output Jony","title":"get()"},{"location":"collection/#groupby","text":"The groupBy method groups the data arrays's items by a given key: collection([ ['account_id' => 'account-x10', 'product' => 'Chair'], ['account_id' => 'account-x10', 'product' => 'Bookcase'], ['account_id' => 'account-x11', 'product' => 'Desk'], ]); $grouped = $make_data->groupBy('account_id'); $grouped->toArray(); Output [ 'account-x10' => [ ['account_id' => 'account-x10', 'product' => 'Chair'], ['account_id' => 'account-x10', 'product' => 'Bookcase'], ], 'account-x11' => [ ['account_id' => 'account-x11', 'product' => 'Desk'], ], ]","title":"groupBy()"},{"location":"collection/#has","text":"The has method determines if a given key exists in the data array: collection(['account_id' => 1, 'product' => 'Desk', 'amount' => 5]); $make_data->has('product'); Output true","title":"has()"},{"location":"collection/#implode","text":"The implode method joins the items in a dara array. Its arguments depend on the type of items in the dara array. If the data array contains arrays or objects, you should pass the key of the attributes you wish to join, and the \"glue\" string you wish to place between the values: collection([ ['account_id' => 1, 'product' => 'Desk'], ['account_id' => 2, 'product' => 'Chair'], ]); $make_data->implode('product', ', '); Output Desk, Chair","title":"implode()"},{"location":"collection/#intersect","text":"The intersect method removes any values from the original data array that are not present in the given array or dara array. The resulting data array will preserve the original dara array's keys: collection(['Desk', 'Sofa', 'Chair']); $intersect = $make_data->intersect(['Desk', 'Chair', 'Bookcase']); $intersect->all(); Output [0 => 'Desk', 2 => 'Chair']","title":"intersect()"},{"location":"collection/#intersectbykeys","text":"The intersectByKeys method removes any keys from the original data array that are not present in the given array or dara array: collection([ 'serial' => 'UX301', 'type' => 'screen', 'year' => 2009 ]); $intersect = $make_data->intersectByKeys([ 'reference' => 'UX404', 'type' => 'tab', 'year' => 2011 ]); $intersect->all(); Output ['type' => 'screen', 'year' => 2009]","title":"intersectByKeys()"},{"location":"collection/#isempty","text":"The isEmpty method returns true if the data array is empty; otherwise, false is returned: collection([])->isEmpty(); Output true","title":"isEmpty()"},{"location":"collection/#isnotempty","text":"The isNotEmpty method returns true if the data array is not empty; otherwise, false is returned: collection([])->isNotEmpty(); Output false","title":"isNotEmpty()"},{"location":"collection/#keyby","text":"The keyBy method keys the data array by the given key. If multiple items have the same key, only the last one will appear in the new dara array: collection([ ['product_id' => 'prod-100', 'name' => 'Desk'], ['product_id' => 'prod-200', 'name' => 'Chair'], ]); $keyed = $make_data->keyBy('product_id'); $keyed->all(); Output [ 'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'], 'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'], ]","title":"keyBy()"},{"location":"collection/#keys","text":"The keys method returns all of the data array's keys: collection([ 'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'], 'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'], ]); $keys = $make_data->keys(); Output ['prod-100', 'prod-200']","title":"keys()"},{"location":"collection/#last","text":"The last method returns the last element in the data array that passes a given truth test: collection([1, 2, 3, 4])->last(); Output 4","title":"last()"},{"location":"collection/#map","text":"The map method iterates through the data array and passes each value to the given callback. The callback is free to modify the item and return it, thus forming a new data array of modified items: collection([1, 2, 3, 4, 5]); $multiplied = $make_data->map(function ($item, $key) { return $item * 2; }); $multiplied->all(); Output [2, 4, 6, 8, 10]","title":"map()"},{"location":"collection/#mapwithkeys","text":"collection([ [ 'name' => 'John', 'department' => 'Sales', 'email' => 'john@example.com' ], [ 'name' => 'Jane', 'department' => 'Marketing', 'email' => 'jane@example.com' ] ]); $keyed = $make_data->mapWithKeys(function ($item) { return [$item['email'] => $item['name']]; }); $keyed->all(); Output [ 'john@example.com' => 'John', 'jane@example.com' => 'Jane', ]","title":"mapWithKeys()"},{"location":"collection/#max","text":"The max method returns the maximum value of a given key: collection([['foo' => 10], ['foo' => 20]])->max('foo'); collection([['foo' => 10], ['foo' => 30]])->max('foo'); Output 20 30","title":"max()"},{"location":"collection/#median","text":"The median method returns the median value of a given key: collection([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->median('foo'); Output 15","title":"median()"},{"location":"collection/#merge","text":"collection(['product_id' => 1, 'price' => 100]); $merged = $make_data->merge(['price' => 200, 'discount' => false]); $merged->all(); Output ['product_id' => 1, 'price' => 200, 'discount' => false]","title":"merge()"},{"location":"collection/#min","text":"The min method returns the minimum value of a given key: collection([['foo' => 10], ['foo' => 20]])->min('foo'); collection([1, 2, 3, 4, 5])->min(); Output 10 1","title":"min()"},{"location":"collection/#mode","text":"The mode method returns the mode value of a given key: collection([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->mode('foo'); collection([1, 1, 2, 4])->mode(); Output [10] [1]","title":"mode()"},{"location":"collection/#only","text":"The only method returns the items in the data array with the specified keys: collection(['product_id' => 1, 'name' => 'Desk', 'price' => 100, 'discount' => false]); $filtered = $make_data->only(['product_id', 'name']); $filtered->all(); Output ['product_id' => 1, 'name' => 'Desk']","title":"only()"},{"location":"collection/#pad","text":"collection(['A', 'B', 'C']); $filtered = $make_data->pad(5, 0); $filtered->all(); Output ['A', 'B', 'C', 0, 0]","title":"pad()"},{"location":"collection/#partition","text":"The partition method may be combined with the list PHP function to separate elements that pass a given truth test from those that do not: collection([1, 2, 3, 4, 5, 6]); list($underThree, $equalOrAboveThree) = $make_data->partition(function ($i) { return $i < 3; }); $underThree->all(); $equalOrAboveThree->all(); Output [1, 2] [3, 4, 5, 6]","title":"partition()"},{"location":"collection/#pipe","text":"The pipe method passes the data array to the given callback and returns the result: collection([1, 2, 3]); $piped = $make_data->pipe(function ($make_data) { return $make_data->sum(); }); Output 6","title":"pipe()"},{"location":"collection/#pluck","text":"The pluck method retrieves all of the values for a given key: collection([ ['product_id' => 'prod-100', 'name' => 'Desk'], ['product_id' => 'prod-200', 'name' => 'Chair'], ]); $plucked = $make_data->pluck('name'); $plucked->all(); Output ['Desk', 'Chair']","title":"pluck()"},{"location":"collection/#pop","text":"The pop method removes and returns the last item from the data array: collection([1, 2, 3, 4, 5]); $make_data->pop(); $make_data->all(); Output 5 [1, 2, 3, 4]","title":"pop()"},{"location":"collection/#prepend","text":"The prepend method adds an item to the beginning of the data array: collection([1, 2, 3, 4, 5]); $make_data->prepend(0); $make_data->all(); Output [0, 1, 2, 3, 4, 5]","title":"prepend()"},{"location":"collection/#pull","text":"The pull method removes and returns an item from the data array by its key: collection(['product_id' => 'prod-100', 'name' => 'Desk']); $make_data->pull('name'); $make_data->all(); Output 'Desk' ['product_id' => 'prod-100']","title":"pull()"},{"location":"collection/#push","text":"The push method appends an item to the end of the data array: collection([1, 2, 3, 4]); $make_data->push(5); $make_data->all(); Output [1, 2, 3, 4, 5]","title":"push()"},{"location":"collection/#put","text":"The put method sets the given key and value in the data array: collection(['product_id' => 1, 'name' => 'Desk']); $make_data->put('price', 100); $make_data->all(); Output ['product_id' => 1, 'name' => 'Desk', 'price' => 100]","title":"put()"},{"location":"collection/#random","text":"The random method returns a random item from the data array: collection([1, 2, 3, 4, 5]); $make_data->random(); Output 4 - (retrieved randomly)","title":"random()"},{"location":"collection/#reduce","text":"The reduce method reduces the data array to a single value, passing the result of each iteration into the subsequent iteration: collection([1, 2, 3]); $total = $make_data->reduce(function ($carry, $item) { return $carry + $item; }); Output 6","title":"reduce()"},{"location":"collection/#reject","text":"The reject method filters the data array using the given callback. The callback should return true if the item should be removed from the resulting data array: collection([1, 2, 3, 4]); $filtered = $make_data->reject(function ($value, $key) { return $value > 2; }); $filtered->all(); Output [1, 2]","title":"reject()"},{"location":"collection/#reverse","text":"The reverse method reverses the order of the data array's items, preserving the original keys: collection(['a', 'b', 'c', 'd', 'e']); $reversed = $make_data->reverse(); $reversed->all(); Output [ 4 => 'e', 3 => 'd', 2 => 'c', 1 => 'b', 0 => 'a', ]","title":"reverse()"},{"location":"collection/#search","text":"The search method searches the data array for the given value and returns its key if found. If the item is not found, false is returned. collection([2, 4, 6, 8]); $make_data->search(4); Output 1","title":"search()"},{"location":"collection/#shift","text":"The shift method removes and returns the first item from the data array: collection([1, 2, 3, 4, 5]); $make_data->shift(); $make_data->all(); Output 1 [2, 3, 4, 5]","title":"shift()"},{"location":"collection/#shuffle","text":"The shuffle method randomly shuffles the items in the data array: collection([1, 2, 3, 4, 5]); $shuffled = $make_data->shuffle(); $shuffled->all(); Output [3, 2, 5, 1, 4] - (generated randomly)","title":"shuffle()"},{"location":"collection/#slice","text":"The slice method returns a slice of the data array starting at the given index: collection([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); $slice = $make_data->slice(4); $slice->all(); Output [5, 6, 7, 8, 9, 10]","title":"slice()"},{"location":"collection/#sort","text":"The sort method sorts the data array. The sorted data array keeps the original array keys, so in this example we'll use the values method to reset the keys to consecutively numbered indexes: collection([5, 3, 1, 2, 4]); $sorted = $make_data->sort(); $sorted->values()->all(); Output [1, 2, 3, 4, 5]","title":"sort()"},{"location":"collection/#sortby","text":"collection([ ['name' => 'Desk', 'price' => 200], ['name' => 'Chair', 'price' => 100], ['name' => 'Bookcase', 'price' => 150], ]); $sorted = $make_data->sortBy('price'); $sorted->values()->all(); Output [ ['name' => 'Chair', 'price' => 100], ['name' => 'Bookcase', 'price' => 150], ['name' => 'Desk', 'price' => 200], ]","title":"sortBy()"},{"location":"collection/#sortbydesc","text":"This method has the same signature as the sortBy method, but will sort the collection in the opposite order.","title":"sortByDesc()"},{"location":"collection/#sortkeys","text":"The sortKeys method sorts the data array by the keys of the underlying associative array: collection([ 'id' => 22345, 'first' => 'John', 'last' => 'Doe', ]); $sorted = $make_data->sortKeys(); $sorted->all(); Output [ 'first' => 'John', 'id' => 22345, 'last' => 'Doe', ]","title":"sortKeys()"},{"location":"collection/#splice","text":"The splice method removes and returns a slice of items starting at the specified index: collection([1, 2, 3, 4, 5]); $chunk = $make_data->splice(2); $chunk->all(); Output [3, 4, 5]","title":"splice()"},{"location":"collection/#split","text":"The split method breaks a data array into the given number of groups: collection([1, 2, 3, 4, 5]); $groups = $make_data->split(3); $groups->toArray(); Output [[1, 2], [3, 4], [5]]","title":"split()"},{"location":"collection/#sum","text":"The sum method returns the sum of all items in the data array: ............................. collection([1, 2, 3, 4, 5])->sum(); ............................. collection([ ['name' => 'JavaScript: The Good Parts', 'pages' => 176], ['name' => 'JavaScript: The Definitive Guide', 'pages' => 1096], ]); $make_data->sum('pages'); ............................. collection([ ['name' => 'Chair', 'colors' => ['Black']], ['name' => 'Desk', 'colors' => ['Black', 'Mahogany']], ['name' => 'Bookcase', 'colors' => ['Red', 'Beige', 'Brown']], ]); $make_data->sum(function ($product) { return count($product['colors']); }); Output 15 1272 6","title":"sum()"},{"location":"collection/#take","text":"The take method returns a new data array with the specified number of items: collection([0, 1, 2, 3, 4, 5]); $chunk = $make_data->take(3); $chunk->all(); Output [0, 1, 2]","title":"take()"},{"location":"collection/#tap","text":"The tap method passes the data array to the given callback, allowing you to \"tap\" into the data array at a specific point and do something with the items while not affecting the data array itself: collection([2, 4, 3, 1, 5]) ->sort() ->tap(function ($make_data) { Log::debug('Values after sorting', $make_data->values()->toArray()); }) ->shift(); Output 1","title":"tap()"},{"location":"collection/#times","text":"The static times method creates a new data array by invoking the callback a given amount of times: $make_data = Collection::times(10, function ($number) { return $number * 9; }); $make_data->all(); Output [9, 18, 27, 36, 45, 54, 63, 72, 81, 90]","title":"times()"},{"location":"collection/#tojson","text":"The toJson method converts the data array into a JSON serialized string: collection(['name' => 'Desk', 'price' => 200]); $make_data->toJson(); Output '{\"name\":\"Desk\", \"price\":200}'","title":"toJson()"},{"location":"collection/#transform","text":"The transform method iterates over the data array and calls the given callback with each item in the data array. The items in the data array will be replaced by the values returned by the callback: collection([1, 2, 3, 4, 5]); $make_data->transform(function ($item, $key) { return $item * 2; }); $make_data->all(); Output [2, 4, 6, 8, 10]","title":"transform()"},{"location":"collection/#union","text":"union() The union method adds the given array to the data array. If the given array contains keys that are already in the original data array, the original data array's values will be preferred: collection([1 => ['a'], 2 => ['b']]); $union = $make_data->union([3 => ['c'], 1 => ['b']]); $union->all(); Output [1 => ['a'], 2 => ['b'], 3 => ['c']]","title":"union()"},{"location":"collection/#unique","text":"The only method returns the items in the data array with the specified keys: collection([1, 1, 2, 2, 3, 4, 2]); $unique = $make_data->unique(); $unique->values()->all(); collection([ ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'], ['name' => 'iPhone 5', 'brand' => 'Apple', 'type' => 'phone'], ['name' => 'Apple Watch', 'brand' => 'Apple', 'type' => 'watch'], ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'], ['name' => 'Galaxy Gear', 'brand' => 'Samsung', 'type' => 'watch'], ]); $unique = $make_data->unique('brand'); $unique->values()->all(); Output [1, 2, 3, 4] [ ['name' => 'iPhone 6', 'brand' => 'Apple', 'type' => 'phone'], ['name' => 'Galaxy S6', 'brand' => 'Samsung', 'type' => 'phone'], ]","title":"unique()"},{"location":"collection/#unless","text":"The unless method will execute the given callback unless the first argument given to the method evaluates to true: collection([1, 2, 3]); $make_data->unless(true, function ($make_data) { return $make_data->push(4); }); $make_data->unless(false, function ($make_data) { return $make_data->push(5); }); $make_data->all(); Output [1, 2, 3, 5]","title":"unless()"},{"location":"collection/#values","text":"The values method returns a new data array with the keys reset to consecutive integers: collection([ 10 => ['product' => 'Desk', 'price' => 200], 11 => ['product' => 'Desk', 'price' => 200] ]); $values = $make_data->values(); $values->all(); Output [ 0 => ['product' => 'Desk', 'price' => 200], 1 => ['product' => 'Desk', 'price' => 200], ]","title":"values()"},{"location":"collection/#when","text":"The when method will execute the given callback when the first argument given to the method evaluates to true: collection([1, 2, 3]); $make_data->when(true, function ($make_data) { return $make_data->push(4); }); $make_data->when(false, function ($make_data) { return $make_data->push(5); }); $make_data->all(); Output [1, 2, 3, 4]","title":"when()"},{"location":"collection/#whenempty","text":"The whenEmpty method will execute the given callback when the data array is empty: collection(['michael', 'tom']); $make_data->whenEmpty(function ($make_data) { return $make_data->push('adam'); }); $make_data->all(); // ['michael', 'tom'] $make_data = make_data); $make_data->whenEmpty(function ($make_data) { return $make_data->push('adam'); }); $make_data->all(); Output ['adam']","title":"whenEmpty()"},{"location":"collection/#whennotempty","text":"The whenNotEmpty method will execute the given callback when the data array is not empty: collection(['michael', 'tom']); $make_data->whenNotEmpty(function ($make_data) { return $make_data->push('adam'); }); $make_data->all(); Output ['michael', 'tom', 'adam']","title":"whenNotEmpty()"},{"location":"collection/#where","text":"The where method filters the data array by a given key / value pair: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 100], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->where('price', 100); $filtered->all(); Output [ ['product' => 'Chair', 'price' => 100], ['product' => 'Door', 'price' => 100], ]","title":"where()"},{"location":"collection/#wherebetween","text":"The whereBetween method filters the data array within a given range: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 80], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Pencil', 'price' => 30], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereBetween('price', [100, 200]); $filtered->all(); Output [ ['product' => 'Desk', 'price' => 200], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]","title":"whereBetween()"},{"location":"collection/#wherein","text":"The whereIn method filters the data array by a given key / value contained within the given array: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 100], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereIn('price', [150, 200]); $filtered->all(); Output [ ['product' => 'Bookcase', 'price' => 150], ['product' => 'Desk', 'price' => 200], ]","title":"whereIn()"},{"location":"collection/#wherenotbetween","text":"The whereNotBetween method filters the data array within a given range: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 80], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Pencil', 'price' => 30], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereNotBetween('price', [100, 200]); $filtered->all(); Output [ ['product' => 'Chair', 'price' => 80], ['product' => 'Pencil', 'price' => 30], ]","title":"whereNotBetween()"},{"location":"collection/#wherenotin","text":"The whereNotIn method filters the data array by a given key / value not contained within the given array: collection([ ['product' => 'Desk', 'price' => 200], ['product' => 'Chair', 'price' => 100], ['product' => 'Bookcase', 'price' => 150], ['product' => 'Door', 'price' => 100], ]); $filtered = $make_data->whereNotIn('price', [150, 200]); $filtered->all(); Output ['product_id' => 1, 'name' => 'Desk']","title":"whereNotIn()"},{"location":"collection/#wrap","text":"The static wrap method wraps the given value in a data array when applicable: $make_data = Collection::wrap('John Doe'); $make_data->all(); Output ['John Doe']","title":"wrap()"},{"location":"collection/#zip","text":"The zip method merges together the values of the given array with the values of the original data array at the corresponding index: collection(['Chair', 'Desk']); $zipped = $make_data->zip([100, 200]); $zipped->all(); Output [['Chair', 100], ['Desk', 200]]","title":"zip()"},{"location":"controller-model/","text":"Introduction The model is responsible for the abstraction of the database. Therefore, all methods that will access the database for modifications or returns must be developed in the model. In the controller we just call our model, which is the class responsible for the abstraction. When we retrieve the data, we send it to our vision. To create a model and a controller, you must use the following commands: # Create a Model php vinci create:model User # Create a controller php vinci create:controller UserController You can use the --remove option to remove a model or controller Using controller in the route To use a controller on any route you create within the routers/ folder, you must use the following syntax: Course::get('/', 'UserController@home')->name('forgot'); The name after the @ will be the name of the method to be called. For example, you must have the home method inside your UserController controller. You can load the entire controller (where url matches method names - getIndex(), postIndex(), putIndex()). The url paths will determine which method to render. For example: Router Method GET /animals getIndex() GET /animals/view getView() POST /animals/save postSave() To do this, use the controller method. Course::controller('/animals', ControllerAnimals::class); Creating model and controller with one command Solital has a command to generate model and controller with just one command: php vinci generate:files --component=User Remember to use the --component option. This command will create a Model class, a Controller class, a migration and a Seeder class. Creating a resource We often use a controller to do CRUD() operations. To create a controller in resource format, use the --resource option. php vinci create:controller ResourceController --resource When creating a resource type controller, the class will have the following structure: <?php class ResourceController { public function index() : ?string { echo 'index'; return null; } public function show($id) : ?string { echo 'show ' . $id; return null; } public function store() : ?string { echo 'store'; return null; } public function create() : ?string { echo 'create'; return null; } public function edit($id) : ?string { echo 'edit ' . $id; return null; } public function update($id) : ?string { echo 'update ' . $id; return null; } public function destroy($id) : ?string { echo 'destroy ' . $id; return null; } } You can use this resource on a specific route with the resource() method. Course::resource('/resource', ResourceController::class); Helpers for controllers Solital has some helpers for you to use in your controllers. The helpers below have methods that should only be used in controllers. Password You can use password helpers, or use the passHash and passVerify methods. Password hash pass_hash($password, int $cost = 10) # With method on Controller $this->passHash($password, $info = false) Password verify pass_verify($password, string $hash) # With method on Controller $this->passVerify($password, $hash) Request You have the option to limit the number of requests in a controller, and also check if a value has already been sent previously. Request limit request_limit(string $key, int $limit = 5, int $seconds = 60) # With method on Controller $this->requestLimit(string $key, int $limit = 5, int $seconds = 60) Request repeat request_repeat(string $key, string $value) # With method on Controller $this->requestRepeat(string $key, string $value) Redirect to another router to_route(string $url, ?int $code = null) # Or, use a method on Controller $this->redirect(string $url, ?int $code = null) Remove params from URL remove_param() # With method on Controller $this->removeParamsUrl() Get input-parameters input(string $index = null, string $defaultValue = null, ...$methods) # With method on Controller $this->getRequestParams(string $index = null, string $defaultValue = null, ...$methods)","title":"Controllers and Models"},{"location":"controller-model/#introduction","text":"The model is responsible for the abstraction of the database. Therefore, all methods that will access the database for modifications or returns must be developed in the model. In the controller we just call our model, which is the class responsible for the abstraction. When we retrieve the data, we send it to our vision. To create a model and a controller, you must use the following commands: # Create a Model php vinci create:model User # Create a controller php vinci create:controller UserController You can use the --remove option to remove a model or controller","title":"Introduction"},{"location":"controller-model/#using-controller-in-the-route","text":"To use a controller on any route you create within the routers/ folder, you must use the following syntax: Course::get('/', 'UserController@home')->name('forgot'); The name after the @ will be the name of the method to be called. For example, you must have the home method inside your UserController controller. You can load the entire controller (where url matches method names - getIndex(), postIndex(), putIndex()). The url paths will determine which method to render. For example: Router Method GET /animals getIndex() GET /animals/view getView() POST /animals/save postSave() To do this, use the controller method. Course::controller('/animals', ControllerAnimals::class);","title":"Using controller in the route"},{"location":"controller-model/#creating-model-and-controller-with-one-command","text":"Solital has a command to generate model and controller with just one command: php vinci generate:files --component=User Remember to use the --component option. This command will create a Model class, a Controller class, a migration and a Seeder class.","title":"Creating model and controller with one command"},{"location":"controller-model/#creating-a-resource","text":"We often use a controller to do CRUD() operations. To create a controller in resource format, use the --resource option. php vinci create:controller ResourceController --resource When creating a resource type controller, the class will have the following structure: <?php class ResourceController { public function index() : ?string { echo 'index'; return null; } public function show($id) : ?string { echo 'show ' . $id; return null; } public function store() : ?string { echo 'store'; return null; } public function create() : ?string { echo 'create'; return null; } public function edit($id) : ?string { echo 'edit ' . $id; return null; } public function update($id) : ?string { echo 'update ' . $id; return null; } public function destroy($id) : ?string { echo 'destroy ' . $id; return null; } } You can use this resource on a specific route with the resource() method. Course::resource('/resource', ResourceController::class);","title":"Creating a resource"},{"location":"controller-model/#helpers-for-controllers","text":"Solital has some helpers for you to use in your controllers. The helpers below have methods that should only be used in controllers.","title":"Helpers for controllers"},{"location":"controller-model/#password","text":"You can use password helpers, or use the passHash and passVerify methods. Password hash pass_hash($password, int $cost = 10) # With method on Controller $this->passHash($password, $info = false) Password verify pass_verify($password, string $hash) # With method on Controller $this->passVerify($password, $hash)","title":"Password"},{"location":"controller-model/#request","text":"You have the option to limit the number of requests in a controller, and also check if a value has already been sent previously. Request limit request_limit(string $key, int $limit = 5, int $seconds = 60) # With method on Controller $this->requestLimit(string $key, int $limit = 5, int $seconds = 60) Request repeat request_repeat(string $key, string $value) # With method on Controller $this->requestRepeat(string $key, string $value) Redirect to another router to_route(string $url, ?int $code = null) # Or, use a method on Controller $this->redirect(string $url, ?int $code = null) Remove params from URL remove_param() # With method on Controller $this->removeParamsUrl() Get input-parameters input(string $index = null, string $defaultValue = null, ...$methods) # With method on Controller $this->getRequestParams(string $index = null, string $defaultValue = null, ...$methods)","title":"Request"},{"location":"convertime/","text":"This class is deprecated and will be removed soon. Please use the Temporal component It is possible to manipulate dates and times using the Convertime class. To begin, run the instance: use Solital\\Core\\Validation\\Convertime; $convertime = new Convertime(); Changing the timezone In the class constructor, you can define the timezone. By default, the default timezone is set to America/Sao_Paulo . $convertime = new Convertime(\"America/Fortaleza\"); You can change the timezone also in the bootstrap.yaml file: default_timezone: America/Fortaleza Format date To format a date, enter the date you want to convert and the format to be converted. $convertime = new Convertime(); $res = $convertime->formatDate('04/01/1999', 'Y-m-d'); /* Return 1999-01-04 */ pre($res); Add months to a date In some cases, you may need to add months to a specific date. To do this, use the addMonth class. This class is similar to the formatDate class, with the difference that you must enter in the last parameter the number of months that will be added to the date. This class already has conversion for days with 28, 29, 30 or 31 days. $convertime = new Convertime(); $res = $convertime->addMonth('1999-01-04', 'd/m/Y', 1); /* Return 1999-02-04 */ pre($res); Add days to a date To add days to a date, the addDays method works in a similar way to the addMonth method. $convertime = new Convertime(); $res = $convertime->addDays('1999-01-04', 'd/m/Y', 3); /* Return 1999-01-07 */ pre($res); Add time to another time It is possible to add a specific time to another time. For example: add 3 more hours at 13:00. $convertime = new Convertime(); $res = $convertime->addHour('13:00', '03:00'); /* Return 16:00 */ pre($res); Check if the date is weekend To check whether a certain date will be on a weekend, use the isWeekend() method. $convertime = new Convertime(); $res = $convertime->isWeekend('2021-07-18'); /* Return bool */ pre($res);","title":"Convertime"},{"location":"convertime/#changing-the-timezone","text":"In the class constructor, you can define the timezone. By default, the default timezone is set to America/Sao_Paulo . $convertime = new Convertime(\"America/Fortaleza\"); You can change the timezone also in the bootstrap.yaml file: default_timezone: America/Fortaleza","title":"Changing the timezone"},{"location":"convertime/#format-date","text":"To format a date, enter the date you want to convert and the format to be converted. $convertime = new Convertime(); $res = $convertime->formatDate('04/01/1999', 'Y-m-d'); /* Return 1999-01-04 */ pre($res);","title":"Format date"},{"location":"convertime/#add-months-to-a-date","text":"In some cases, you may need to add months to a specific date. To do this, use the addMonth class. This class is similar to the formatDate class, with the difference that you must enter in the last parameter the number of months that will be added to the date. This class already has conversion for days with 28, 29, 30 or 31 days. $convertime = new Convertime(); $res = $convertime->addMonth('1999-01-04', 'd/m/Y', 1); /* Return 1999-02-04 */ pre($res);","title":"Add months to a date"},{"location":"convertime/#add-days-to-a-date","text":"To add days to a date, the addDays method works in a similar way to the addMonth method. $convertime = new Convertime(); $res = $convertime->addDays('1999-01-04', 'd/m/Y', 3); /* Return 1999-01-07 */ pre($res);","title":"Add days to a date"},{"location":"convertime/#add-time-to-another-time","text":"It is possible to add a specific time to another time. For example: add 3 more hours at 13:00. $convertime = new Convertime(); $res = $convertime->addHour('13:00', '03:00'); /* Return 16:00 */ pre($res);","title":"Add time to another time"},{"location":"convertime/#check-if-the-date-is-weekend","text":"To check whether a certain date will be on a weekend, use the isWeekend() method. $convertime = new Convertime(); $res = $convertime->isWeekend('2021-07-18'); /* Return bool */ pre($res);","title":"Check if the date is weekend"},{"location":"cryptography/","text":"Introduction Solital makes use of OpenSSL and Sodium encryption. If you are using Core >= 4.2, you should find the following variables in your .env file: APP_HASH , FIRST_SECRET and SECOND_SECRET . The APP_HASH variable is the main variable used by Solital, but if this variable is not available, the other two can be used instead. For the variables `FIRST_SECRET` and `SECOND_SECRET`, use encrypted characters. If the variable `APP_HASH` is empty, run the command `php vinci generate:hash` Encrypt To create an encrypted key, use the Hash class together with the static encrypt function as shown below: use Solital\\Core\\Security\\Hash; $res = Hash::encrypt('word_to_encrypt'); pre($res); You can define how long this key will be valid. It can be 1 second, 1 hour or 1 year. by default the value is +1 hour . use Solital\\Core\\Security\\Hash; $res = Hash::encrypt('word_to_encrypt', '+1 month'); pre($res); Decrypt If you want to decrypt, use the decrypt function chained with the value method. use Solital\\Core\\Security\\Hash; $res = Hash::decrypt('word_to_decrypt')->value(); pre($res); Check value If you want to check if the encrypted key is still valid, use isValid . If you want to verify that the encrypted key is still valid, use isValid . the isValid method will return true if it is still valid, and false if it is already expired use Solital\\Core\\Security\\Hash; $res = Hash::decrypt('word_to_decrypt')->isValid(); pre($res); Changing the encryption type Solital uses OpenSSL and Sodium to perform value encryption. To change the encryption, change the crypt value in the bootstrap.yaml file. crypt: sodium Sodium encryption (Core <= 4.4) The documentation below is deprecated and is only for users using Solital Core in version 4.4 or lower. Starting with version 4.5, Solital uses the `crypt` configuration in the `bootstrap.yaml` file and the functions below will be removed in a future version 5.0 Solital supports Sodium encryption. To enable, make sure that libsodium is installed in your development environment. You can use the Hash::checkSodium() method to check if libsodium is installed. Generating a sodium key First, you need to generate a sodium key. This key is automatically renewed with each new request, so it can be stored in a database, in the session or in another type of storage. use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); Encrypting and decrypting with Sodium Use the Hash::sodiumCrypt() (to encrypt), and Hash::sodiumDecrypt() (to decrypt) methods. Remember to use the key generated using the Hash::getSodiumKey() method. use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); # Crypt $encoded = Hash::sodiumCrypt(\"HashTest!\", $key); pre($encoded); # Decrypt $decoded = Hash::sodiumDecrypt($encoded, $key); pre($decoded);","title":"Cryptography"},{"location":"cryptography/#introduction","text":"Solital makes use of OpenSSL and Sodium encryption. If you are using Core >= 4.2, you should find the following variables in your .env file: APP_HASH , FIRST_SECRET and SECOND_SECRET . The APP_HASH variable is the main variable used by Solital, but if this variable is not available, the other two can be used instead.","title":"Introduction"},{"location":"cryptography/#encrypt","text":"To create an encrypted key, use the Hash class together with the static encrypt function as shown below: use Solital\\Core\\Security\\Hash; $res = Hash::encrypt('word_to_encrypt'); pre($res); You can define how long this key will be valid. It can be 1 second, 1 hour or 1 year. by default the value is +1 hour . use Solital\\Core\\Security\\Hash; $res = Hash::encrypt('word_to_encrypt', '+1 month'); pre($res);","title":"Encrypt"},{"location":"cryptography/#decrypt","text":"If you want to decrypt, use the decrypt function chained with the value method. use Solital\\Core\\Security\\Hash; $res = Hash::decrypt('word_to_decrypt')->value(); pre($res);","title":"Decrypt"},{"location":"cryptography/#check-value","text":"If you want to check if the encrypted key is still valid, use isValid . If you want to verify that the encrypted key is still valid, use isValid . the isValid method will return true if it is still valid, and false if it is already expired use Solital\\Core\\Security\\Hash; $res = Hash::decrypt('word_to_decrypt')->isValid(); pre($res);","title":"Check value"},{"location":"cryptography/#changing-the-encryption-type","text":"Solital uses OpenSSL and Sodium to perform value encryption. To change the encryption, change the crypt value in the bootstrap.yaml file. crypt: sodium","title":"Changing the encryption type"},{"location":"cryptography/#sodium-encryption-core-44","text":"","title":"Sodium encryption (Core &lt;= 4.4)"},{"location":"cryptography/#generating-a-sodium-key","text":"First, you need to generate a sodium key. This key is automatically renewed with each new request, so it can be stored in a database, in the session or in another type of storage. use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey();","title":"Generating a sodium key"},{"location":"cryptography/#encrypting-and-decrypting-with-sodium","text":"Use the Hash::sodiumCrypt() (to encrypt), and Hash::sodiumDecrypt() (to decrypt) methods. Remember to use the key generated using the Hash::getSodiumKey() method. use Solital\\Core\\Security\\Hash; $key = Hash::getSodiumKey(); # Crypt $encoded = Hash::sodiumCrypt(\"HashTest!\", $key); pre($encoded); # Decrypt $decoded = Hash::sodiumDecrypt($encoded, $key); pre($decoded);","title":"Encrypting and decrypting with Sodium"},{"location":"csrf-protection/","text":"Introducion CSRF is one of the most well-known attacks, it has existed since the \u201cfoundation\u201d of the Web. It occurs when an HTTP request is made between sites in an attempt to impersonate a legitimate user. Whoever uses this type of attack usually focuses on doing so hoping that the target user will be authenticated on the site where the fraudulent request will be made, in order to have more privileges and access to operations. And the reason for the whole problem is how browsers handle Cookies. Any forms posting to POST , PUT or DELETE routes should include the CSRF-token. We strongly recommend that you enable CSRF-verification on your site to maximize security. The CSRF check is generated by default in Solital, but it is possible to extend this check. If you want to store the token elsewhere, please refer to the \"Creating custom Token Provider\" section below. Adding CSRF-verifier By default, Solital will use the BaseCsrfVerifier class. When you've created your CSRF-verifier you need to tell Solital that it should use it. You can do this by editing the following line in your bootstrap.yaml file: # Custom CSRF verifier class custom_csrf: BaseCsrfVerifier Getting CSRF-token When posting to any of the urls that has CSRF-verification enabled, you need post your CSRF-token or else the request will get rejected. You can get the CSRF-token by calling the helper method: csrf_token(); The default name/key for the input-field is csrf_token and is defined in the POST_KEY constant in the BaseCsrfVerifier class. You can change the key by overwriting the constant in your own CSRF-verifier class. Example: The example below will post to the current url with a hidden field \" csrf_token \". <form method=\"post\" action=\"{{ url(); }}\"> {{ csrf_token(); }} <!-- other input elements here --> </form> Custom CSRF-verifier Create a new class and extend the `BaseCsrfVerifier middleware class provided by default with the Solital library. Add the property except with an array of the urls to the routes you want to exclude/whitelist from the CSRF validation. Using * at the end for the url will match the entire url. Here's a basic example on a CSRF-verifier class: namespace Solital\\Middleware; use Solital\\Core\\Http\\Middleware\\BaseCsrfVerifier; class CustomCsrfVerifier extends BaseCsrfVerifier { /** * CSRF validation will be ignored on the following urls. */ protected array $except = ['/api/*']; } And change in bootstrap.yaml # Custom CSRF verifier class custom_csrf: CustomCsrfVerifier","title":"CSRF Protection"},{"location":"csrf-protection/#introducion","text":"CSRF is one of the most well-known attacks, it has existed since the \u201cfoundation\u201d of the Web. It occurs when an HTTP request is made between sites in an attempt to impersonate a legitimate user. Whoever uses this type of attack usually focuses on doing so hoping that the target user will be authenticated on the site where the fraudulent request will be made, in order to have more privileges and access to operations. And the reason for the whole problem is how browsers handle Cookies. Any forms posting to POST , PUT or DELETE routes should include the CSRF-token. We strongly recommend that you enable CSRF-verification on your site to maximize security. The CSRF check is generated by default in Solital, but it is possible to extend this check. If you want to store the token elsewhere, please refer to the \"Creating custom Token Provider\" section below.","title":"Introducion"},{"location":"csrf-protection/#adding-csrf-verifier","text":"By default, Solital will use the BaseCsrfVerifier class. When you've created your CSRF-verifier you need to tell Solital that it should use it. You can do this by editing the following line in your bootstrap.yaml file: # Custom CSRF verifier class custom_csrf: BaseCsrfVerifier","title":"Adding CSRF-verifier"},{"location":"csrf-protection/#getting-csrf-token","text":"When posting to any of the urls that has CSRF-verification enabled, you need post your CSRF-token or else the request will get rejected. You can get the CSRF-token by calling the helper method: csrf_token(); The default name/key for the input-field is csrf_token and is defined in the POST_KEY constant in the BaseCsrfVerifier class. You can change the key by overwriting the constant in your own CSRF-verifier class. Example: The example below will post to the current url with a hidden field \" csrf_token \". <form method=\"post\" action=\"{{ url(); }}\"> {{ csrf_token(); }} <!-- other input elements here --> </form>","title":"Getting CSRF-token"},{"location":"csrf-protection/#custom-csrf-verifier","text":"Create a new class and extend the `BaseCsrfVerifier middleware class provided by default with the Solital library. Add the property except with an array of the urls to the routes you want to exclude/whitelist from the CSRF validation. Using * at the end for the url will match the entire url. Here's a basic example on a CSRF-verifier class: namespace Solital\\Middleware; use Solital\\Core\\Http\\Middleware\\BaseCsrfVerifier; class CustomCsrfVerifier extends BaseCsrfVerifier { /** * CSRF validation will be ignored on the following urls. */ protected array $except = ['/api/*']; } And change in bootstrap.yaml # Custom CSRF verifier class custom_csrf: CustomCsrfVerifier","title":"Custom CSRF-verifier"},{"location":"date-and-time/","text":"If you are looking for the old Convertime class, use this link Dates are an important part of any system. To manipulate dates in Solital, you can use the Temporal component. The Temporal component uses the DateTimeImmutable class. use Solital\\Core\\Resource\\Temporal\\Temporal; $date_time = Temporal::now(); The now() method takes the current date and time. Returning in different formats You can return a date using one of the following methods: $date_time->toAtom(); $date_time->toCookie(); $date_time->toISO8601Expanded(); $date_time->toRFC1036(); $date_time->toRFC1123(); $date_time->toRFC2822(); $date_time->toRFC3339(); $date_time->toRFC3339Extended(); $date_time->toRFC7231(); $date_time->toRFC822(); $date_time->toRFC850(); $date_time->toRSS(); $date_time->toW3C(); $date_time->toUnixTimestamp(); $date_time->toFormat('Y-m-d'); Adding and removing date and time Temporal has methods for adding and removing days, months and years to a date, and also adding and removing hours and minutes to a time. Days Add days to a date $result = Temporal::now()->addDays(3)->toFormat('Y-m-d'); var_dump($result); Remove days from a date $result = Temporal::now()->subDays(3)->toFormat('Y-m-d'); var_dump($result); Months Add months to a date $result = Temporal::now()->addMonths(3)->toFormat('Y-m-d'); var_dump($result); Remove months from a date $result = Temporal::now()->subMonths(3)->toFormat('Y-m-d'); var_dump($result); Years Add years to a date $result = Temporal::now()->addYears(3)->toFormat('Y-m-d'); var_dump($result); Remove years from a date $result = Temporal::now()->subYears(3)->toFormat('Y-m-d'); var_dump($result); Hours Add hours to a time $result = Temporal::now()->addHours(3)->toFormat('H:i:s'); var_dump($result); Remove hours from a time $result = Temporal::now()->subHours(3)->toFormat('H:i:s'); var_dump($result); Minutes Add minutes to a time $result = Temporal::now()->addMinutes(3)->toFormat('H:i:s'); var_dump($result); Remove minutes from a time $result = Temporal::now()->subMinutes(3)->toFormat('H:i:s'); var_dump($result); Returning specific times The Temporal component has methods to return specific times from a date/time, such as years, days, name of the month, and others. Date Temporal::now()->getDay(); Temporal::now()->getYear(); Temporal::now()->getMonthInt(); Temporal::now()->getMonthName(); Temporal::now()->getMonthShortName(); Time Temporal::now()->getHour(); Temporal::now()->getMinute(); Temporal::now()->getSecond(); Date on different days If you want to manipulate a date other than the current date, you can use the createDatetime() method. This method, you can create a custom date and time. echo Temporal::createDatetime('2024-04-04 08:20:10')->toRFC1123(); If you need to get the date of the previous day, the current day or the next day, there are three methods to do this job. Temporal::today()->toRFC1036(); Temporal::yesterday()->toRFC1036(); Temporal::tomorrow()->toRFC1036(); Check days of the week Temporal also has methods to check whether the current date is a specific day of the week. All methods below return true or false . Temporal::now()->isMonday(); Temporal::now()->isTuesday(); Temporal::now()->isWednesday(); Temporal::now()->isThursday(); Temporal::now()->isFriday(); Temporal::now()->isSaturday(); Temporal::now()->isSunday(); Temporal::now()->isWeekend(); Returning DateTimeImmutable instance To return an instance of type DateTimeImmutable , use the getDateTimeImmutableInstance method. $temporal = Temporal::createDatetime('2024-04-04'); $immutable_datetime = $temporal->addMonths(3); $modify_datetime = $temporal->toFormat('Y-m-d'); var_dump($immutable_datetime->getImmutableDateTime()->format('Y-m-d')); // 2024-04-04 var_dump($modify_datetime); // 2024-07-04","title":"Date and time"},{"location":"date-and-time/#returning-in-different-formats","text":"You can return a date using one of the following methods: $date_time->toAtom(); $date_time->toCookie(); $date_time->toISO8601Expanded(); $date_time->toRFC1036(); $date_time->toRFC1123(); $date_time->toRFC2822(); $date_time->toRFC3339(); $date_time->toRFC3339Extended(); $date_time->toRFC7231(); $date_time->toRFC822(); $date_time->toRFC850(); $date_time->toRSS(); $date_time->toW3C(); $date_time->toUnixTimestamp(); $date_time->toFormat('Y-m-d');","title":"Returning in different formats"},{"location":"date-and-time/#adding-and-removing-date-and-time","text":"Temporal has methods for adding and removing days, months and years to a date, and also adding and removing hours and minutes to a time.","title":"Adding and removing date and time"},{"location":"date-and-time/#days","text":"Add days to a date $result = Temporal::now()->addDays(3)->toFormat('Y-m-d'); var_dump($result); Remove days from a date $result = Temporal::now()->subDays(3)->toFormat('Y-m-d'); var_dump($result);","title":"Days"},{"location":"date-and-time/#months","text":"Add months to a date $result = Temporal::now()->addMonths(3)->toFormat('Y-m-d'); var_dump($result); Remove months from a date $result = Temporal::now()->subMonths(3)->toFormat('Y-m-d'); var_dump($result);","title":"Months"},{"location":"date-and-time/#years","text":"Add years to a date $result = Temporal::now()->addYears(3)->toFormat('Y-m-d'); var_dump($result); Remove years from a date $result = Temporal::now()->subYears(3)->toFormat('Y-m-d'); var_dump($result);","title":"Years"},{"location":"date-and-time/#hours","text":"Add hours to a time $result = Temporal::now()->addHours(3)->toFormat('H:i:s'); var_dump($result); Remove hours from a time $result = Temporal::now()->subHours(3)->toFormat('H:i:s'); var_dump($result);","title":"Hours"},{"location":"date-and-time/#minutes","text":"Add minutes to a time $result = Temporal::now()->addMinutes(3)->toFormat('H:i:s'); var_dump($result); Remove minutes from a time $result = Temporal::now()->subMinutes(3)->toFormat('H:i:s'); var_dump($result);","title":"Minutes"},{"location":"date-and-time/#returning-specific-times","text":"The Temporal component has methods to return specific times from a date/time, such as years, days, name of the month, and others. Date Temporal::now()->getDay(); Temporal::now()->getYear(); Temporal::now()->getMonthInt(); Temporal::now()->getMonthName(); Temporal::now()->getMonthShortName(); Time Temporal::now()->getHour(); Temporal::now()->getMinute(); Temporal::now()->getSecond();","title":"Returning specific times"},{"location":"date-and-time/#date-on-different-days","text":"If you want to manipulate a date other than the current date, you can use the createDatetime() method. This method, you can create a custom date and time. echo Temporal::createDatetime('2024-04-04 08:20:10')->toRFC1123(); If you need to get the date of the previous day, the current day or the next day, there are three methods to do this job. Temporal::today()->toRFC1036(); Temporal::yesterday()->toRFC1036(); Temporal::tomorrow()->toRFC1036();","title":"Date on different days"},{"location":"date-and-time/#check-days-of-the-week","text":"Temporal also has methods to check whether the current date is a specific day of the week. All methods below return true or false . Temporal::now()->isMonday(); Temporal::now()->isTuesday(); Temporal::now()->isWednesday(); Temporal::now()->isThursday(); Temporal::now()->isFriday(); Temporal::now()->isSaturday(); Temporal::now()->isSunday(); Temporal::now()->isWeekend();","title":"Check days of the week"},{"location":"date-and-time/#returning-datetimeimmutable-instance","text":"To return an instance of type DateTimeImmutable , use the getDateTimeImmutableInstance method. $temporal = Temporal::createDatetime('2024-04-04'); $immutable_datetime = $temporal->addMonths(3); $modify_datetime = $temporal->toFormat('Y-m-d'); var_dump($immutable_datetime->getImmutableDateTime()->format('Y-m-d')); // 2024-04-04 var_dump($modify_datetime); // 2024-07-04","title":"Returning DateTimeImmutable instance"},{"location":"dependency-container/","text":"Introduction Injecting dependencies can become a tedious task when many classes are involved. Before injecting a dependency it needs to be instantiated. So, we don't just take care of the \"injection\", we also need to have the knowledge of what objects it needs to work. A dependency injection container (DI Container) manages and automates instantiations. We tell him how an object should be created (this is the part that touches us, our knowledge about it) and then whenever we need it, we just need to use the container to obtain it. Solital implements the PSR-11, meaning you can easily create dependency containers. Consider this example: <?php class UserManager { private $mailer; public function __construct() { $this->mailer = new Mailer(); $this->mailer->setTransport('sendmail'); } public function setMailerTransport($transport) { $this->mailer->setTransport($transport); } } Here we have our UserManager service that is responsible for creating its Mailer dependency via setter injection. If we decide to later change the type of mailer that is used, and that mailer uses constructor injection rather than setter injection, we must alter our UserManager code, potentially breaking other methods that may use the setTransport method. Instead, the UserManager service should simply ask for a Mailer object, and get one. It should not care how it is created or what methods the mailer uses to configure itself, it just asks for one and receives one: class UserManager { private $mailer; public function __construct(Mailer $mailer) { $this->mailer = $mailer; } } The configuration of the mailer is now setup outside of the UserManager , and will not break anything if it is changed. So that leaves us with a question: Where should we write this \"wiring\" or configuration of the dependencies? That's where the container concept comes in. An IoC, or dependency injection container is the place where you would write up how your services should be created. Going back to the above example: $container->add('userManager', function($container) { $mailer = $container->get('mailer'); return new UserManager($mailer); }); $container->add('mailer', function() { $transport = 'gmail'; $mailer = new Mailer($transport); }); Now all we have to do is ask for the UserManager , and its Mailer dependency will be created for us. If we decide to change the transport methodback to sendmail at any point, all we have to do is change it in one place in the service configuration area. Usage Service container are a way to organize your container entries. Service container are nothing more than classes that implement the ServiceProvider interface that exposes a register method. The register method is always passed an instance of the container. For example, lets say that you have a suite of services that deal with user management. You could organize them into a single service provider class/file called UserServiceProvider . This class would then be responsible for adding all container entries related to user management. To use dependency injection, you must register your containers within the register method located in the ServiceContainer class located in the app/ folder. <?php namespace Solital; use Solital\\Core\\Container\\Interface\\ContainerInterface; use Solital\\Core\\Container\\Interface\\ServiceProviderInterface; class ServiceContainer implements ServiceProviderInterface { public function register(ContainerInterface $container) { $container->add('userManager', function($container) { $mailer = $container->get('mailer'); return new UserManager($mailer); }); $container->add('mailer', function() { $transport = 'gmail'; $mailer = new Mailer($transport); }); } } To use the container, use container() helper, Application::provider() or $container->get() method: $provider = container('mailer'); $provider = $container->get('mailer'); $provider = Application::provider('mailer'); var_dump($provider); Adding Definitions Services are defined by invokable callback functions. Most commonly, this is a closure (anonymous function) that explains how to create a service: $myServiceDefinition = function() { $obj = new Service(); return $obj; }; Parameters are simple primitive values that should be accessed throughout your application. It is assumed that your entry is a parameter if it is not an invokable function. To add a service or parameter to the container, use the Container::add method. $container = new Container(); $container->add('myParameter', 'value'); $container->add('myService', function() { return new MyService(); }); The container can also be accessed like an array. So adding entries is as easy as using array notation: $container['myParameter'] = 'value'; $container['myService'] = function() { return new MyService(); }; When defining services, note that an instance of the container is always passed as an argument to the invokable callback. This allows you to resolve nested dependencies. In our synopsis, we used the example of a UserManager service who needed a Mailer object. We can define how to create the mailer in one entry, and how to create the user manager in a separate entry like this: $container['userManager'] = function($container) { // The user manager needs a mailer, so get that from the container first $mailer = $container->get('mailer'); // Now pass that to the UserManager return new UserManager($mailer); }; $container['mailer'] = function() { return new Mailer(); }; $userManager = container('userManager'); This is known as manually wiring your dependencies. Retrieving Services and Parameters Once an entry is added to the container, we can resolve that entry by using the Container::get method, or via array access: $container['myParameter'] = 'value'; $myParameter = container('myParameter'); var_dump($myParameter); // outputs: 'value' $container['myService'] = function() { return new MyService(); }; $myService = $container['myService']; var_dump($myService instanceof MyService::class); // outputs: true Note that the service definition is executed and the result of the callback is what is assigned to $myService , rather than the literal callback function. If you would like a callback function to be interpreted as a literal value, you can use the Container::protect method: $container->add('myService', $container->protect(function() { return new MyService(); })); $myServiceFactory = container('myService'); var_dump($myServiceFactory instanceof \\Closure); // outputs: true By default, when the container resolves a service entry, that service will be \"shared\" across the life of the container. This means that when the container is asked for the service a second time, the same instance will be returned as the first. This is often times the desired behavior when dealing with database connections, mailers, and logger objects. It would be a waste of memory to create these types of objects multiple times. You would not want 20 different database connections open at the same time if you really only need one: $container->add('db', function() { ... // database configuration return new PDO(); }); $db = container('db'); $db2 = container('db'); var_dump($db === $db2); // outputs: true However, sometimes you do need to get a new instance of a service each time it is accessed. For those cases, simply define the service as a factory with Container::factory : $container->add('myService', $container->factory(function() { return new MyService(); })); $myService = container('myService'); $myService2 = container('myService'); var_dump($myService === $myService2); // outputs: false Extending Definitions Often times you need to modify a service after it has been created. This is often times called \"setter injection\" or \"decorating\". This can be achieved by using the Container::extend method. The extend method is passed the instance of the object and an instance of the container in that order. An extend will fail if: The entry does not exist The entry is a parameter The entry is currently being resolved The entry is protected The extend callback is not invokable Therefore, extending is meant to be done on existing service definitions only: $container['mailer'] = function() { return new Mailer(); }; $container->extend('mailer', function($mailer, $container) { $mailer->setTransport('sendmail'); $mailer->setUsername($container->get(...)); }); If, however, you leave the second argument empty and only assign an invokable callback, like so: $container->extend(function() {}); This will be treated as a global callback function that should be run on every resolve. This is also a cool way to see how inversion of control works. We can assign a callback to run whenever the container resolves any type of entry, and get some feedback about what it is creating. A great example of dependency injection comes from the Auryn container docs: class Car { private $engine; public function __construct(Engine $engine) { $this->engine = $engine; } } class Engine { private $sparkPlug; private $piston; public function __construct(SparkPlug $sparkPlug, Piston $piston) { $this->sparkPlug = $sparkPlug; $this->piston = $piston; } } As you can see we have a Car object that depends on an Engine object, and the Engine object depends on its own service objects SparkPlug and Piston . Using a normal object creation workflow, the wiring of these objects would look something like this: Application needs Car Car needs Engine so: Engine needs SparkPlug and Piston so: Engine creates SparkPlug Engine creates Piston Car creates engine Application creates Car However the wiring of objects using inversion of control looks like this: Application needs Car, which needs Engine, which needs SparkPlug and Piston so: Application creates SparkPlug and Piston Application creates Engine and gives it SparkPlug and Piston Application creates Car and gives it Engine You can see that the difference with inversion of control is that application (container) creates the dependencies in an inverted fashion, creating the lowest level dependencies first, and passing them up through the chain of services. This ensures that none of the services know how their dependencies are created, and that they are loosely coupled. We can have a look at this in action with something like this: // Create something to run on every resolve $container->extend(function($resolved, $container) { echo is_object($resolved) ? get_class($resolved) . ' created.<br />' : ''; }); // Define our services $container['sparkPlug'] = function() { return new SparkPlug(); }; $container['piston'] = function() { return new Piston(); }; $container['engine'] = function($c) { return new Engine($c['sparkPlug'], $c['piston']); }; $container['car'] = function($c) { return new Car($c['engine']); }; // Get our service $container->get('car'); This would then output the following: SparkPlug created. Piston created. Engine created. Car created. This is proof that the container uses the inversion of control principle since the global callback function gets called after each resolve.","title":"Dependency Container"},{"location":"dependency-container/#introduction","text":"Injecting dependencies can become a tedious task when many classes are involved. Before injecting a dependency it needs to be instantiated. So, we don't just take care of the \"injection\", we also need to have the knowledge of what objects it needs to work. A dependency injection container (DI Container) manages and automates instantiations. We tell him how an object should be created (this is the part that touches us, our knowledge about it) and then whenever we need it, we just need to use the container to obtain it. Solital implements the PSR-11, meaning you can easily create dependency containers. Consider this example: <?php class UserManager { private $mailer; public function __construct() { $this->mailer = new Mailer(); $this->mailer->setTransport('sendmail'); } public function setMailerTransport($transport) { $this->mailer->setTransport($transport); } } Here we have our UserManager service that is responsible for creating its Mailer dependency via setter injection. If we decide to later change the type of mailer that is used, and that mailer uses constructor injection rather than setter injection, we must alter our UserManager code, potentially breaking other methods that may use the setTransport method. Instead, the UserManager service should simply ask for a Mailer object, and get one. It should not care how it is created or what methods the mailer uses to configure itself, it just asks for one and receives one: class UserManager { private $mailer; public function __construct(Mailer $mailer) { $this->mailer = $mailer; } } The configuration of the mailer is now setup outside of the UserManager , and will not break anything if it is changed. So that leaves us with a question: Where should we write this \"wiring\" or configuration of the dependencies? That's where the container concept comes in. An IoC, or dependency injection container is the place where you would write up how your services should be created. Going back to the above example: $container->add('userManager', function($container) { $mailer = $container->get('mailer'); return new UserManager($mailer); }); $container->add('mailer', function() { $transport = 'gmail'; $mailer = new Mailer($transport); }); Now all we have to do is ask for the UserManager , and its Mailer dependency will be created for us. If we decide to change the transport methodback to sendmail at any point, all we have to do is change it in one place in the service configuration area.","title":"Introduction"},{"location":"dependency-container/#usage","text":"Service container are a way to organize your container entries. Service container are nothing more than classes that implement the ServiceProvider interface that exposes a register method. The register method is always passed an instance of the container. For example, lets say that you have a suite of services that deal with user management. You could organize them into a single service provider class/file called UserServiceProvider . This class would then be responsible for adding all container entries related to user management. To use dependency injection, you must register your containers within the register method located in the ServiceContainer class located in the app/ folder. <?php namespace Solital; use Solital\\Core\\Container\\Interface\\ContainerInterface; use Solital\\Core\\Container\\Interface\\ServiceProviderInterface; class ServiceContainer implements ServiceProviderInterface { public function register(ContainerInterface $container) { $container->add('userManager', function($container) { $mailer = $container->get('mailer'); return new UserManager($mailer); }); $container->add('mailer', function() { $transport = 'gmail'; $mailer = new Mailer($transport); }); } } To use the container, use container() helper, Application::provider() or $container->get() method: $provider = container('mailer'); $provider = $container->get('mailer'); $provider = Application::provider('mailer'); var_dump($provider);","title":"Usage"},{"location":"dependency-container/#adding-definitions","text":"Services are defined by invokable callback functions. Most commonly, this is a closure (anonymous function) that explains how to create a service: $myServiceDefinition = function() { $obj = new Service(); return $obj; }; Parameters are simple primitive values that should be accessed throughout your application. It is assumed that your entry is a parameter if it is not an invokable function. To add a service or parameter to the container, use the Container::add method. $container = new Container(); $container->add('myParameter', 'value'); $container->add('myService', function() { return new MyService(); }); The container can also be accessed like an array. So adding entries is as easy as using array notation: $container['myParameter'] = 'value'; $container['myService'] = function() { return new MyService(); }; When defining services, note that an instance of the container is always passed as an argument to the invokable callback. This allows you to resolve nested dependencies. In our synopsis, we used the example of a UserManager service who needed a Mailer object. We can define how to create the mailer in one entry, and how to create the user manager in a separate entry like this: $container['userManager'] = function($container) { // The user manager needs a mailer, so get that from the container first $mailer = $container->get('mailer'); // Now pass that to the UserManager return new UserManager($mailer); }; $container['mailer'] = function() { return new Mailer(); }; $userManager = container('userManager'); This is known as manually wiring your dependencies.","title":"Adding Definitions"},{"location":"dependency-container/#retrieving-services-and-parameters","text":"Once an entry is added to the container, we can resolve that entry by using the Container::get method, or via array access: $container['myParameter'] = 'value'; $myParameter = container('myParameter'); var_dump($myParameter); // outputs: 'value' $container['myService'] = function() { return new MyService(); }; $myService = $container['myService']; var_dump($myService instanceof MyService::class); // outputs: true Note that the service definition is executed and the result of the callback is what is assigned to $myService , rather than the literal callback function. If you would like a callback function to be interpreted as a literal value, you can use the Container::protect method: $container->add('myService', $container->protect(function() { return new MyService(); })); $myServiceFactory = container('myService'); var_dump($myServiceFactory instanceof \\Closure); // outputs: true By default, when the container resolves a service entry, that service will be \"shared\" across the life of the container. This means that when the container is asked for the service a second time, the same instance will be returned as the first. This is often times the desired behavior when dealing with database connections, mailers, and logger objects. It would be a waste of memory to create these types of objects multiple times. You would not want 20 different database connections open at the same time if you really only need one: $container->add('db', function() { ... // database configuration return new PDO(); }); $db = container('db'); $db2 = container('db'); var_dump($db === $db2); // outputs: true However, sometimes you do need to get a new instance of a service each time it is accessed. For those cases, simply define the service as a factory with Container::factory : $container->add('myService', $container->factory(function() { return new MyService(); })); $myService = container('myService'); $myService2 = container('myService'); var_dump($myService === $myService2); // outputs: false","title":"Retrieving Services and Parameters"},{"location":"dependency-container/#extending-definitions","text":"Often times you need to modify a service after it has been created. This is often times called \"setter injection\" or \"decorating\". This can be achieved by using the Container::extend method. The extend method is passed the instance of the object and an instance of the container in that order. An extend will fail if: The entry does not exist The entry is a parameter The entry is currently being resolved The entry is protected The extend callback is not invokable Therefore, extending is meant to be done on existing service definitions only: $container['mailer'] = function() { return new Mailer(); }; $container->extend('mailer', function($mailer, $container) { $mailer->setTransport('sendmail'); $mailer->setUsername($container->get(...)); }); If, however, you leave the second argument empty and only assign an invokable callback, like so: $container->extend(function() {}); This will be treated as a global callback function that should be run on every resolve. This is also a cool way to see how inversion of control works. We can assign a callback to run whenever the container resolves any type of entry, and get some feedback about what it is creating. A great example of dependency injection comes from the Auryn container docs: class Car { private $engine; public function __construct(Engine $engine) { $this->engine = $engine; } } class Engine { private $sparkPlug; private $piston; public function __construct(SparkPlug $sparkPlug, Piston $piston) { $this->sparkPlug = $sparkPlug; $this->piston = $piston; } } As you can see we have a Car object that depends on an Engine object, and the Engine object depends on its own service objects SparkPlug and Piston . Using a normal object creation workflow, the wiring of these objects would look something like this: Application needs Car Car needs Engine so: Engine needs SparkPlug and Piston so: Engine creates SparkPlug Engine creates Piston Car creates engine Application creates Car However the wiring of objects using inversion of control looks like this: Application needs Car, which needs Engine, which needs SparkPlug and Piston so: Application creates SparkPlug and Piston Application creates Engine and gives it SparkPlug and Piston Application creates Car and gives it Engine You can see that the difference with inversion of control is that application (container) creates the dependencies in an inverted fashion, creating the lowest level dependencies first, and passing them up through the chain of services. This ensures that none of the services know how their dependencies are created, and that they are loosely coupled. We can have a look at this in action with something like this: // Create something to run on every resolve $container->extend(function($resolved, $container) { echo is_object($resolved) ? get_class($resolved) . ' created.<br />' : ''; }); // Define our services $container['sparkPlug'] = function() { return new SparkPlug(); }; $container['piston'] = function() { return new Piston(); }; $container['engine'] = function($c) { return new Engine($c['sparkPlug'], $c['piston']); }; $container['car'] = function($c) { return new Car($c['engine']); }; // Get our service $container->get('car'); This would then output the following: SparkPlug created. Piston created. Engine created. Car created. This is proof that the container uses the inversion of control principle since the global callback function gets called after each resolve.","title":"Extending Definitions"},{"location":"deploy/","text":"To deploy your project made in Solital Framework, do a git pull on your hosting. Then, update all components using composer update . Solital may receive some important updates during this period of development. Apache There is a htaccess file inside the public/ folder, but Apache needs to point to this folder. Therefore, in the root folder of your project, insert this other htaccess file below: RewriteEngine on # Force HTTPS RewriteCond %{HTTPS} off # Redirect to public/ with HTTPS RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301] RewriteCond %{HTTP_HOST} ^YOUR_DOMAIN.com$ [NC,OR] RewriteCond %{HTTP_HOST} ^www.YOUR_DOMAIN.com$ RewriteCond %{REQUEST_URI} !public/ RewriteRule (.*) /public/$1 [L] Replace YOUR_DOMAIN by the name of your primary domain. Nginx If you are using Nginx please make sure that url-rewriting is enabled. You can easily enable url-rewriting by adding the following configuration for the Nginx configuration-file for the demo-project. location / { try_files $uri $uri/ /index.php?$query_string; }","title":"Deploy"},{"location":"deploy/#apache","text":"There is a htaccess file inside the public/ folder, but Apache needs to point to this folder. Therefore, in the root folder of your project, insert this other htaccess file below: RewriteEngine on # Force HTTPS RewriteCond %{HTTPS} off # Redirect to public/ with HTTPS RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301] RewriteCond %{HTTP_HOST} ^YOUR_DOMAIN.com$ [NC,OR] RewriteCond %{HTTP_HOST} ^www.YOUR_DOMAIN.com$ RewriteCond %{REQUEST_URI} !public/ RewriteRule (.*) /public/$1 [L] Replace YOUR_DOMAIN by the name of your primary domain.","title":"Apache"},{"location":"deploy/#nginx","text":"If you are using Nginx please make sure that url-rewriting is enabled. You can easily enable url-rewriting by adding the following configuration for the Nginx configuration-file for the demo-project. location / { try_files $uri $uri/ /index.php?$query_string; }","title":"Nginx"},{"location":"dump/","text":"Sometimes it is necessary to dump the database. This process is very simple, just run the following command: php vinci db:dump Any dump files you run will be stored in app/Storage/dump . Excluding tables from the dump If there are tables in your database that you do not want to dump, use the --exclude argument php vinci db:dump --exclude=table1,table2 For Windows The process to perform the dump on Windows is a little different, you first need to edit the database.yaml file. You will need to indicate the location of mysqldump as shown below: dump_windows: mysql: C:\\wamp64\\bin\\mysql\\mysql8.2.0\\bin pgsql: C:\\Program Files\\PostgreSQL\\14\\bin sqlite: Then run the command php vinci db:dump .","title":"Dump"},{"location":"dump/#excluding-tables-from-the-dump","text":"If there are tables in your database that you do not want to dump, use the --exclude argument php vinci db:dump --exclude=table1,table2","title":"Excluding tables from the dump"},{"location":"dump/#for-windows","text":"The process to perform the dump on Windows is a little different, you first need to edit the database.yaml file. You will need to indicate the location of mysqldump as shown below: dump_windows: mysql: C:\\wamp64\\bin\\mysql\\mysql8.2.0\\bin pgsql: C:\\Program Files\\PostgreSQL\\14\\bin sqlite: Then run the command php vinci db:dump .","title":"For Windows"},{"location":"environment-variables/","text":"Introduction The .env file has all the variables that Solital uses. The idea here is that by placing some information in the environment, you are protecting your application (example: access credentials that are not in a text file, protected from accidental copies), and having other less sensitive information in conventional files to facilitate copying and migration. Usage Solital uses the Dotenv class to handle all environment variables. All Solital variables are loaded using the env method. This method is already configured in the config.php file. But, if you want to check if a variable exists, you can use the isset() method. Dotenv::isset('MY_ENVIRONMENT_VARIABLE'); Solital Variables Key used for encryption and passwords. Use the php vinci generate:hash command to generate a key. WARNING: When creating a new project, an encrypted key is already generated. Changing the generated key can break your project APP_HASH= Displays all errors that Solital or PHP raises. Activate only in development mode ERRORS_DISPLAY=true Database connection variables. To find out more, see Katrina ORM DB_DRIVE= DB_HOST= DB_NAME= DB_USER= DB_PASS= SQLITE_DIR= Variables of the Mailer class MAIL_DEBUG= MAIL_HOST= MAIL_USER= MAIL_PASS= MAIL_SECURITY= MAIL_PORT= Variables used in encryption. It is recommended that you add new values to these variables. If you are using the `APP_HASH` variable, then it is not necessary to use the variables below FIRST_SECRET=first_secret SECOND_SECRET=second_secret Checking project status To check the status of Solita, you can run the php vinci status command. This command checks whether there are variables that have not been configured correctly. Using other components If you don't want to use the Dotenv class, you can use other libraries like vlucas/phpdotenv .","title":"Environment Variables"},{"location":"environment-variables/#introduction","text":"The .env file has all the variables that Solital uses. The idea here is that by placing some information in the environment, you are protecting your application (example: access credentials that are not in a text file, protected from accidental copies), and having other less sensitive information in conventional files to facilitate copying and migration.","title":"Introduction"},{"location":"environment-variables/#usage","text":"Solital uses the Dotenv class to handle all environment variables. All Solital variables are loaded using the env method. This method is already configured in the config.php file. But, if you want to check if a variable exists, you can use the isset() method. Dotenv::isset('MY_ENVIRONMENT_VARIABLE');","title":"Usage"},{"location":"environment-variables/#solital-variables","text":"Key used for encryption and passwords. Use the php vinci generate:hash command to generate a key.","title":"Solital Variables"},{"location":"environment-variables/#checking-project-status","text":"To check the status of Solita, you can run the php vinci status command. This command checks whether there are variables that have not been configured correctly.","title":"Checking project status"},{"location":"environment-variables/#using-other-components","text":"If you don't want to use the Dotenv class, you can use other libraries like vlucas/phpdotenv .","title":"Using other components"},{"location":"event-loop/","text":"PHP's new feature Fibers allows for easier creation of asynchronous applications, and a key component of designing such an application is the event loop. The event loop is responsible for monitoring external resources for interesting events such as new input data or state changes. Once an event is detected, the event loop will resume the fibers that are interested in that event so they can process it. There are many ways to implement such a loop, ranging from a trivial sleep and resume to a complex, multifeatured event monitoring system. In this article, we'll look at a few examples and build up on the complexity as we go. Below is an example of how to use EventLoop in your project: $loop = container('solital-eventloop'); // Or: new Solital\\Core\\Queue\\EventLoop(); $loop->defer(function() use ($loop){ $loop->sleep(0.2); foreach (range(1, 5) as $value) { echo $value; $loop->next(); } }); $loop->defer(function() use ($loop){ foreach (range(1, 10) as $value) { echo $value; $loop->next(); } }); $loop->deferWithTimer(0.5, function() use ($loop){ foreach (range(1, 10) as $value) { echo $value; $loop->next(); } }); $loop->run();","title":"Event Loop"},{"location":"events/","text":"This section will help you understand how to register your own callbacks to events in the router. It will also cover the basics of event-handlers; how to use the handlers provided with the router and how to create your own custom event-handlers. Available events This section contains all available events that can be registered using the EventHandler . All event callbacks will retrieve a EventArgument object as parameter. This object contains easy access to event-name, router- and request instance and any special event-arguments related to the given event. You can see what special event arguments each event returns in the list below. Name Special arguments Description EVENT_ALL - Fires when a event is triggered EVENT_INIT loadedRoutes Fires when router is initializing and before routes are loaded EVENT_LOAD loadedRoutes Fires when all routes has been loaded and rendered, just before the output is returned EVENT_ADD_ROUTE route Fires when route is added to the router EVENT_REWRITE rewriteUrl rewriteRoute Fires when a url-rewrite is and just before the routes are re-initialized EVENT_BOOT bootmanagers Fires when the router is booting. This happens just before boot-managers are rendered and before any routes has been loaded EVENT_RENDER_BOOTMANAGER bootmanagers bootmanager Fires before a boot-manager is rendered EVENT_LOAD_ROUTES routes Fires when the router is about to load all routes EVENT_FIND_ROUTE name Fires whenever the `findRoute` method is called within the `Router`. This usually happens when the router tries to find routes that contains a certain url, usually after the `EventHandler::EVENT_GET_URL` event EVENT_GET_URL name parameters getParams Fires whenever the `Router::getUrl` method or `url`-helper function is called and the router tries to find the route EVENT_MATCH_ROUTE route Fires when a route is matched and valid (correct request-type etc). and before the route is rendered EVENT_RENDER_ROUTE route Fires before a route is rendered EVENT_LOAD_EXCEPTIONS exception exceptionHandlers Fires when the router is loading exception-handlers EVENT_RENDER_EXCEPTION exception exceptionHandler exceptionHandlers Fires before the router is rendering a exception-handler EVENT_RENDER_MIDDLEWARES route middlewares Fires before middlewares for a route is rendered EVENT_RENDER_CSRF csrfVerifier Fires before the CSRF-verifier is rendered Registering new event To register a new event you need to create a new instance of the EventHandler object. On this object you can add as many callbacks as you like by calling the registerEvent method. When you've registered events, make sure to add it to the router by calling Course::addEventHandler() . We recommend that you add your event-handlers within your routes.php . Example: use Solital\\Core\\Course\\Handlers\\EventHandler; use Solital\\Core\\Course\\Event\\EventArgument; // --- your routes goes here --- $eventHandler = new EventHandler(); // Add event that fires when a route is rendered $eventHandler->register(EventHandler::EVENT_RENDER_ROUTE, function(EventArgument $argument) { // Get the route by using the special argument for this event. $route = $argument->route; // DO STUFF... }); Course::addEventHandler($eventHandler); Custom EventHandlers EventHandler is the class that manages events and must inherit from the EventHandlerInterface interface. The handler knows how to handle events for the given handler-type. Most of the time the basic \\Solital\\Core\\Course\\Handler\\EventHandler class will be more than enough for most people as you simply register an event which fires when triggered. Let's go over how to create your very own event-handler class. Below is a basic example of a custom event-handler called DatabaseDebugHandler . The idea of the sample below is to logs all events to the database when triggered. Hopefully it will be enough to give you an idea on how the event-handlers work. namespace Demo\\Handlers; use Solital\\Core\\Course\\Event\\EventArgument; use Solital\\Core\\Course\\Router; class DatabaseDebugHandler implements EventHandlerInterface { /** * Debug callback * @var \\Closure */ protected $callback; public function __construct() { $this->callback = function (EventArgument $argument) { // todo: store log in database }; } /** * Get events. * * @param string|null $name Filter events by name. * @return array */ public function getEvents(?string $name): array { return [ $name => [ $this->callback, ], ]; } /** * Fires any events registered with given event-name * * @param Router $router Router instance * @param string $name Event name * @param array ...$eventArgs Event arguments */ public function fireEvents(Router $router, string $name, ...$eventArgs): void { $callback = $this->callback; $callback(new EventArgument($router, $eventArgs)); } /** * Set debug callback * * @param \\Closure $event */ public function setCallback(\\Closure $event): void { $this->callback = $event; } } Using the PSR-14 It is possible to use the PSR-14 through the EventDispatcher class. You can create the test class below: class UserTest { public function testLow() { echo \"Running Low ...\"; } public function testNormal() { echo \"Running Normal ...\"; } public function testHigh() { echo \"Running High ...\"; } } Then, use the addListener method to add the event referring to the UserTest class. You can define the priority of each method and the order in which it will be executed. To do this, use a number in the last parameter of addListener . $provider = new ListenerProvider(); $event = new EventDispatcher($provider); $user = new UserTest(); $provider->addListener(function (UserTest $user) { $user->testLow(); }, 1); $provider->addListener(function (UserTest $user) { $user->testNormal(); }, 2); $provider->addListener(function (UserTest $user) { $user->testHigh(); }, 3); $event->dispatch($user); As defined in the priority, the result will be Running High... , Running Normal... and Running Low... .","title":"Events"},{"location":"events/#available-events","text":"This section contains all available events that can be registered using the EventHandler . All event callbacks will retrieve a EventArgument object as parameter. This object contains easy access to event-name, router- and request instance and any special event-arguments related to the given event. You can see what special event arguments each event returns in the list below. Name Special arguments Description EVENT_ALL - Fires when a event is triggered EVENT_INIT loadedRoutes Fires when router is initializing and before routes are loaded EVENT_LOAD loadedRoutes Fires when all routes has been loaded and rendered, just before the output is returned EVENT_ADD_ROUTE route Fires when route is added to the router EVENT_REWRITE rewriteUrl rewriteRoute Fires when a url-rewrite is and just before the routes are re-initialized EVENT_BOOT bootmanagers Fires when the router is booting. This happens just before boot-managers are rendered and before any routes has been loaded EVENT_RENDER_BOOTMANAGER bootmanagers bootmanager Fires before a boot-manager is rendered EVENT_LOAD_ROUTES routes Fires when the router is about to load all routes EVENT_FIND_ROUTE name Fires whenever the `findRoute` method is called within the `Router`. This usually happens when the router tries to find routes that contains a certain url, usually after the `EventHandler::EVENT_GET_URL` event EVENT_GET_URL name parameters getParams Fires whenever the `Router::getUrl` method or `url`-helper function is called and the router tries to find the route EVENT_MATCH_ROUTE route Fires when a route is matched and valid (correct request-type etc). and before the route is rendered EVENT_RENDER_ROUTE route Fires before a route is rendered EVENT_LOAD_EXCEPTIONS exception exceptionHandlers Fires when the router is loading exception-handlers EVENT_RENDER_EXCEPTION exception exceptionHandler exceptionHandlers Fires before the router is rendering a exception-handler EVENT_RENDER_MIDDLEWARES route middlewares Fires before middlewares for a route is rendered EVENT_RENDER_CSRF csrfVerifier Fires before the CSRF-verifier is rendered","title":"Available events"},{"location":"events/#registering-new-event","text":"To register a new event you need to create a new instance of the EventHandler object. On this object you can add as many callbacks as you like by calling the registerEvent method. When you've registered events, make sure to add it to the router by calling Course::addEventHandler() . We recommend that you add your event-handlers within your routes.php . Example: use Solital\\Core\\Course\\Handlers\\EventHandler; use Solital\\Core\\Course\\Event\\EventArgument; // --- your routes goes here --- $eventHandler = new EventHandler(); // Add event that fires when a route is rendered $eventHandler->register(EventHandler::EVENT_RENDER_ROUTE, function(EventArgument $argument) { // Get the route by using the special argument for this event. $route = $argument->route; // DO STUFF... }); Course::addEventHandler($eventHandler);","title":"Registering new event"},{"location":"events/#custom-eventhandlers","text":"EventHandler is the class that manages events and must inherit from the EventHandlerInterface interface. The handler knows how to handle events for the given handler-type. Most of the time the basic \\Solital\\Core\\Course\\Handler\\EventHandler class will be more than enough for most people as you simply register an event which fires when triggered. Let's go over how to create your very own event-handler class. Below is a basic example of a custom event-handler called DatabaseDebugHandler . The idea of the sample below is to logs all events to the database when triggered. Hopefully it will be enough to give you an idea on how the event-handlers work. namespace Demo\\Handlers; use Solital\\Core\\Course\\Event\\EventArgument; use Solital\\Core\\Course\\Router; class DatabaseDebugHandler implements EventHandlerInterface { /** * Debug callback * @var \\Closure */ protected $callback; public function __construct() { $this->callback = function (EventArgument $argument) { // todo: store log in database }; } /** * Get events. * * @param string|null $name Filter events by name. * @return array */ public function getEvents(?string $name): array { return [ $name => [ $this->callback, ], ]; } /** * Fires any events registered with given event-name * * @param Router $router Router instance * @param string $name Event name * @param array ...$eventArgs Event arguments */ public function fireEvents(Router $router, string $name, ...$eventArgs): void { $callback = $this->callback; $callback(new EventArgument($router, $eventArgs)); } /** * Set debug callback * * @param \\Closure $event */ public function setCallback(\\Closure $event): void { $this->callback = $event; } }","title":"Custom EventHandlers"},{"location":"events/#using-the-psr-14","text":"It is possible to use the PSR-14 through the EventDispatcher class. You can create the test class below: class UserTest { public function testLow() { echo \"Running Low ...\"; } public function testNormal() { echo \"Running Normal ...\"; } public function testHigh() { echo \"Running High ...\"; } } Then, use the addListener method to add the event referring to the UserTest class. You can define the priority of each method and the order in which it will be executed. To do this, use a number in the last parameter of addListener . $provider = new ListenerProvider(); $event = new EventDispatcher($provider); $user = new UserTest(); $provider->addListener(function (UserTest $user) { $user->testLow(); }, 1); $provider->addListener(function (UserTest $user) { $user->testNormal(); }, 2); $provider->addListener(function (UserTest $user) { $user->testHigh(); }, 3); $event->dispatch($user); As defined in the priority, the result will be Running High... , Running Normal... and Running Low... .","title":"Using the PSR-14"},{"location":"exceptions/","text":"Introduction Solital uses the Modern PHP Exception component to handle all exceptions and display them to the user in an intuitive and modern way. You can check the complete documentation for this component to better understand its use, but here you will see how this component works in Solital. Customizing exceptions To customize exceptions, and also enable night mode, you can change the settings in the exceptions.yaml file. Changing the page title title: My title Enabling dark mode # Default: false dark_mode: true Enabling production mode # Default: false production_mode: true To change the message, change the error_message variable: production_mode: true error_message: Something wrong! Load CSS files if there is no internet connection # Use `false` only if you have no internet connection enable_cdn_assets: false Enable occurrences If you want to have a history of all exceptions and errors that your application displays, you can enable the occurrences using the enable_occurrences option on exceptions.yaml . enable_occurrences: true Don't forget to configure the database. # Database for Modern PHP Exceptions db_drive: mysql db_host: localhost db_name: database_name db_user: root db_pass: pass Creating a solution for an exception If you are creating a custom exception class, you can add a solution to resolve this exception. For that, use the static getSolution method implementing the SolutionInterface interface: <?php namespace Test; use ModernPHPException\\Solution; use ModernPHPException\\Interface\\SolutionInterface; class CustomException extends \\Exception implements SolutionInterface { public function getSolution(): Solution { return Solution::createSolution('My Solution') ->setDescription('description') ->setDocs('https://google.com'); } #... createSolution: Name of solution to fix exception setDescription: Detailed description of exception solution setDocs: If a documentation exists, this method will display a button for a documentation. By default, the name of the button will be Read More , but you can change the name by changing the second parameter of the method","title":"Exceptions"},{"location":"exceptions/#introduction","text":"Solital uses the Modern PHP Exception component to handle all exceptions and display them to the user in an intuitive and modern way. You can check the complete documentation for this component to better understand its use, but here you will see how this component works in Solital.","title":"Introduction"},{"location":"exceptions/#customizing-exceptions","text":"To customize exceptions, and also enable night mode, you can change the settings in the exceptions.yaml file. Changing the page title title: My title Enabling dark mode # Default: false dark_mode: true Enabling production mode # Default: false production_mode: true To change the message, change the error_message variable: production_mode: true error_message: Something wrong! Load CSS files if there is no internet connection # Use `false` only if you have no internet connection enable_cdn_assets: false Enable occurrences If you want to have a history of all exceptions and errors that your application displays, you can enable the occurrences using the enable_occurrences option on exceptions.yaml . enable_occurrences: true Don't forget to configure the database. # Database for Modern PHP Exceptions db_drive: mysql db_host: localhost db_name: database_name db_user: root db_pass: pass","title":"Customizing exceptions"},{"location":"exceptions/#creating-a-solution-for-an-exception","text":"If you are creating a custom exception class, you can add a solution to resolve this exception. For that, use the static getSolution method implementing the SolutionInterface interface: <?php namespace Test; use ModernPHPException\\Solution; use ModernPHPException\\Interface\\SolutionInterface; class CustomException extends \\Exception implements SolutionInterface { public function getSolution(): Solution { return Solution::createSolution('My Solution') ->setDescription('description') ->setDocs('https://google.com'); } #... createSolution: Name of solution to fix exception setDescription: Detailed description of exception solution setDocs: If a documentation exists, this method will display a button for a documentation. By default, the name of the button will be Read More , but you can change the name by changing the second parameter of the method","title":"Creating a solution for an exception"},{"location":"file-system/","text":"You can manipulate folders and files within Solital through the HandleFiles class, such as creating folders, removing folders, listing files and deleting files. use Solital\\Core\\FileSystem\\HandleFiles; $handle = new HandleFiles(); // Or use container $handle = container('handler-file'); List files within a folder list multiple files Use the folder() method to define the folder containing the files in Solital to be listed. To list all files within that folder, chain the files() method. /** Array return */ $res = $handle->folder(\"folder_name\")->files(); pre($res); list single file /** String return */ $res = $handle->folder(\"folder_name\")->file('README.md'); pre($res); To list only a single file within the folder, use the file() method passing as a parameter the file you want to search for Check if a file exists To check if there is a file inside the folder, use fileExists() . /** Boolean return */ $res = $handle->folder(\"folder_name\")->fileExists(\"README.md\"); pre($res); You can delete the file if it exists, to do so enter true in the second parameter. /** Boolean return */ $res = $handle->folder(\"folder_name\")->fileExists(\"README.md\", true); pre($res); Create folder To create a folder inside Solital, use only the create() method. /** Boolean return */ $res = $handle->create(\"folder_name\"); pre($res); You can define the type of permission the folder will have. The default is 0777. /** Boolean return */ $res = $handle->create(\"folder_name\", 0755); pre($res); Remove folder To delete a folder inside Solital, use only the remove() method. This method will delete a folder if it is empty. /** Boolean return */ $res = $handle->remove(\"folder_name\"); pre($res); The remove() method checks for files inside the folder. If you want to delete the files inside the folder, pass false in the second parameter. /** Boolean return */ $res = $handle->remove(\"folder_name\", false); pre($res); Get and Put Contents It is possible to use the native PHP functions file_get_contents and file_put_contents at the same time. The getAndPutContents method performs this process. $res = $handle->getAndPutContents('file.txt', 'file_bkp.txt'); pre($res); Copy Make a copy of a file using the copy method. /** Boolean return */ $res = $handle->copy('file.txt', 'file_bkp.txt'); pre($res); If you want to delete the original photo after copying, use true . /** Boolean return */ $res = $handle->copy('file.txt', 'file_bkp.txt', true); pre($res); Handling permissions You can change and view file and folder permissions. List permissions The getPermission method lists the permissions that the file or folder has. /** Null|string return */ $res = $handle->getPermission('file.txt'); pre($res); List full permissions To return full permissions, use the getFullPermission method. /** String return */ $res = $handle->getFullPermission('file.txt'); pre($res); Change permissions The setPermission method changes the permissions that the file or folder will have. /** Boolean return */ $handle->setPermission('file.txt', 0777); Modify owner of the file Use the setOwner method to modify the owner of the file. /** Boolean return */ $res = $handle->setOwner('file.txt', 'root'); pre($res);","title":"File System"},{"location":"file-system/#list-files-within-a-folder","text":"list multiple files Use the folder() method to define the folder containing the files in Solital to be listed. To list all files within that folder, chain the files() method. /** Array return */ $res = $handle->folder(\"folder_name\")->files(); pre($res); list single file /** String return */ $res = $handle->folder(\"folder_name\")->file('README.md'); pre($res); To list only a single file within the folder, use the file() method passing as a parameter the file you want to search for","title":"List files within a folder"},{"location":"file-system/#check-if-a-file-exists","text":"To check if there is a file inside the folder, use fileExists() . /** Boolean return */ $res = $handle->folder(\"folder_name\")->fileExists(\"README.md\"); pre($res); You can delete the file if it exists, to do so enter true in the second parameter. /** Boolean return */ $res = $handle->folder(\"folder_name\")->fileExists(\"README.md\", true); pre($res);","title":"Check if a file exists"},{"location":"file-system/#create-folder","text":"To create a folder inside Solital, use only the create() method. /** Boolean return */ $res = $handle->create(\"folder_name\"); pre($res); You can define the type of permission the folder will have. The default is 0777. /** Boolean return */ $res = $handle->create(\"folder_name\", 0755); pre($res);","title":"Create folder"},{"location":"file-system/#remove-folder","text":"To delete a folder inside Solital, use only the remove() method. This method will delete a folder if it is empty. /** Boolean return */ $res = $handle->remove(\"folder_name\"); pre($res); The remove() method checks for files inside the folder. If you want to delete the files inside the folder, pass false in the second parameter. /** Boolean return */ $res = $handle->remove(\"folder_name\", false); pre($res);","title":"Remove folder"},{"location":"file-system/#get-and-put-contents","text":"It is possible to use the native PHP functions file_get_contents and file_put_contents at the same time. The getAndPutContents method performs this process. $res = $handle->getAndPutContents('file.txt', 'file_bkp.txt'); pre($res);","title":"Get and Put Contents"},{"location":"file-system/#copy","text":"Make a copy of a file using the copy method. /** Boolean return */ $res = $handle->copy('file.txt', 'file_bkp.txt'); pre($res); If you want to delete the original photo after copying, use true . /** Boolean return */ $res = $handle->copy('file.txt', 'file_bkp.txt', true); pre($res);","title":"Copy"},{"location":"file-system/#handling-permissions","text":"You can change and view file and folder permissions.","title":"Handling permissions"},{"location":"file-system/#list-permissions","text":"The getPermission method lists the permissions that the file or folder has. /** Null|string return */ $res = $handle->getPermission('file.txt'); pre($res);","title":"List permissions"},{"location":"file-system/#list-full-permissions","text":"To return full permissions, use the getFullPermission method. /** String return */ $res = $handle->getFullPermission('file.txt'); pre($res);","title":"List full permissions"},{"location":"file-system/#change-permissions","text":"The setPermission method changes the permissions that the file or folder will have. /** Boolean return */ $handle->setPermission('file.txt', 0777);","title":"Change permissions"},{"location":"file-system/#modify-owner-of-the-file","text":"Use the setOwner method to modify the owner of the file. /** Boolean return */ $res = $handle->setOwner('file.txt', 'root'); pre($res);","title":"Modify owner of the file"},{"location":"helpers/","text":"Helpers are functions that help the developer manipulate classes, without having to instantiate them. Here you will find the helpers that exist in Solital Framework. Some specific helpers are not listed on this page, but you can find them on the next pages of the documentation. Some helpers can be replaced by methods, as long as you use them inside a Controller. Debug Debug functions are present in the Modern PHP Exception component . An easy function to pull all details of the debug backtrace. get_debug_backtrace() Function to returns the value of var_dump() instead of outputting it. echo var_dump_buffer() PHP function to replace var_dump(), print_r() based on the XDebug style. var_dump_debug() Dump PHP value and die script. dump_die() View a PHP Closure's Source. closure_dump() Improved functions Generate a uniquid ID uniqid_real(int|float $lenght = 13) Instances Manipulate the ArrayCollection class without having to instantiate it. collection(mixed $value = null) Manipulate the Str class without having to instantiate it. str(string $string) Return a SimpleCache instance. cache(?string $drive) Convert an array to JSON and display an error message in case of failure. encodeJSON($value) Convert a JSON to an object and display an error message in case of failure. true to convert JSON to an array. decodeJSON($value, bool $toArray = false) Create a message using Message class without having to instantiate it message(string $key, string $msg = \"\") Cryptograph an value using Hash class without having to instantiate it encrypt(string $value, string $time = '+1 hour') Decryptograph an value using Hash class without having to instantiate it decrypt(string $key) Handles PHP sessions. To get a value from an existing session, leave the $value parameter empty. To create a new session, inform the session key in the first parameter, and the session value in the second parameter. See more in Session and Cookies . /** * $key: index that will identify the session * $value: session value * $defaultValue: array of values (see Session class documentation) * $delete: if the value is `true`, the session will be deleted. * $take: returns the requested value and removes it from the session. */ session( string $key, mixed $value = null, mixed $defaultValue = null, bool $delete = false, bool $take = false ) Memorize provides simple in-var cache for closures. It can be used to create lazy functions. Function takes closure and optional argument paramsHash. If the closure with the same arguments was run before memorize will return result from cache without the closure call. At the first call result will be calculated and stored in cache. memorize(Closure $lambda, $paramsHash = null) Output Formatted var_dump . pre($value) Write any message in the browser LOG, which can be viewed at any time. console_log(...$messages) Password Generate password hash using PHP Secure Password component. pass_hash($password, int $cost = 10) Checks the hash generated by the pass_hash helper or the PHP Secure Password component. pass_verify($password, string $hash) Reflection Get attributes' method. reflection_get_attributes(object|string $class_name, string|null $method, string $attribute_name) Gets a ReflectionProperty for a class's property. reflection_get_property(string|object $class, string $property) Reports information about an extension. reflection_extension_info(string $extension_name) Creates a new class instance from given arguments. reflection_new_instance(object|string $objectOrClass, ...$args) Creates a new class instance without invoking the constructor. reflection_instance_without_construct(object|string $objectOrClass) Invokes a reflected method reflection_invoke_method(object|string $objectOrClass, string $method, ...$args) Router Handles the URI class. See more in routes . url(?string $name = null, $parameters = null, ?array $getParams) Get input class. See more in Input and params . input(string $index = null, string $defaultValue = null, ...$methods) Redirect to another route. to_route(string $url, ?int $code = null) Get the current full URL. get_url(string $uri = null) Get a middleware middleware(string $value) Server Handles the Request class. request() Handles the Response class. response() Defines a limit on requests that can be made at a certain time . request_limit(string $key, int $limit = 5, int $seconds = 60) Checks if a value was previously sent in the requisition. request_repeat(string $key, string $value) Removes GET parameters in the URL and reloads the page without those parameters. remove_param() Returns the IP address of the client. get_client_ip(?bool $header_containing_ip_address = null) Check to see if the current page is being served over SSL. is_https() Determine if current page request type is ajax. is_ajax() Wolf Template See Wolf Template to use Wolf helpers. Load a CSS file into the public/assets/_css/ folder. load_css(string $asset) Loads the minified CSS file created by the minify()->style() method. load_min_css() Load a Javascript file into the public/assets/_js/ folder. load_js(string $asset) Loads the minified Javascript file created by the minify()->script() method. load_min_js() Load a image file into the public/assets/_img/ folder. load_img(string $asset) Load a file into the public/assets/ folder. load_file(string $asset) Includes any template that is inside the resource/view folder extend(string $view) Displayed code only in production mode or only in development mode conditional(string $needle, bool $value) Get current csrf-token. See more in CSRF Protection . csrf_token() Form method spoofing. spoofing(string $method) Others Returns the container defined in the ServiceContainer class. container(string $container_name)","title":"Helpers"},{"location":"helpers/#debug","text":"Debug functions are present in the Modern PHP Exception component . An easy function to pull all details of the debug backtrace. get_debug_backtrace() Function to returns the value of var_dump() instead of outputting it. echo var_dump_buffer() PHP function to replace var_dump(), print_r() based on the XDebug style. var_dump_debug() Dump PHP value and die script. dump_die() View a PHP Closure's Source. closure_dump()","title":"Debug"},{"location":"helpers/#improved-functions","text":"Generate a uniquid ID uniqid_real(int|float $lenght = 13)","title":"Improved functions"},{"location":"helpers/#instances","text":"Manipulate the ArrayCollection class without having to instantiate it. collection(mixed $value = null) Manipulate the Str class without having to instantiate it. str(string $string) Return a SimpleCache instance. cache(?string $drive) Convert an array to JSON and display an error message in case of failure. encodeJSON($value) Convert a JSON to an object and display an error message in case of failure. true to convert JSON to an array. decodeJSON($value, bool $toArray = false) Create a message using Message class without having to instantiate it message(string $key, string $msg = \"\") Cryptograph an value using Hash class without having to instantiate it encrypt(string $value, string $time = '+1 hour') Decryptograph an value using Hash class without having to instantiate it decrypt(string $key) Handles PHP sessions. To get a value from an existing session, leave the $value parameter empty. To create a new session, inform the session key in the first parameter, and the session value in the second parameter. See more in Session and Cookies . /** * $key: index that will identify the session * $value: session value * $defaultValue: array of values (see Session class documentation) * $delete: if the value is `true`, the session will be deleted. * $take: returns the requested value and removes it from the session. */ session( string $key, mixed $value = null, mixed $defaultValue = null, bool $delete = false, bool $take = false ) Memorize provides simple in-var cache for closures. It can be used to create lazy functions. Function takes closure and optional argument paramsHash. If the closure with the same arguments was run before memorize will return result from cache without the closure call. At the first call result will be calculated and stored in cache. memorize(Closure $lambda, $paramsHash = null)","title":"Instances"},{"location":"helpers/#output","text":"Formatted var_dump . pre($value) Write any message in the browser LOG, which can be viewed at any time. console_log(...$messages)","title":"Output"},{"location":"helpers/#password","text":"Generate password hash using PHP Secure Password component. pass_hash($password, int $cost = 10) Checks the hash generated by the pass_hash helper or the PHP Secure Password component. pass_verify($password, string $hash)","title":"Password"},{"location":"helpers/#reflection","text":"Get attributes' method. reflection_get_attributes(object|string $class_name, string|null $method, string $attribute_name) Gets a ReflectionProperty for a class's property. reflection_get_property(string|object $class, string $property) Reports information about an extension. reflection_extension_info(string $extension_name) Creates a new class instance from given arguments. reflection_new_instance(object|string $objectOrClass, ...$args) Creates a new class instance without invoking the constructor. reflection_instance_without_construct(object|string $objectOrClass) Invokes a reflected method reflection_invoke_method(object|string $objectOrClass, string $method, ...$args)","title":"Reflection"},{"location":"helpers/#router","text":"Handles the URI class. See more in routes . url(?string $name = null, $parameters = null, ?array $getParams) Get input class. See more in Input and params . input(string $index = null, string $defaultValue = null, ...$methods) Redirect to another route. to_route(string $url, ?int $code = null) Get the current full URL. get_url(string $uri = null) Get a middleware middleware(string $value)","title":"Router"},{"location":"helpers/#server","text":"Handles the Request class. request() Handles the Response class. response() Defines a limit on requests that can be made at a certain time . request_limit(string $key, int $limit = 5, int $seconds = 60) Checks if a value was previously sent in the requisition. request_repeat(string $key, string $value) Removes GET parameters in the URL and reloads the page without those parameters. remove_param() Returns the IP address of the client. get_client_ip(?bool $header_containing_ip_address = null) Check to see if the current page is being served over SSL. is_https() Determine if current page request type is ajax. is_ajax()","title":"Server"},{"location":"helpers/#wolf-template","text":"See Wolf Template to use Wolf helpers. Load a CSS file into the public/assets/_css/ folder. load_css(string $asset) Loads the minified CSS file created by the minify()->style() method. load_min_css() Load a Javascript file into the public/assets/_js/ folder. load_js(string $asset) Loads the minified Javascript file created by the minify()->script() method. load_min_js() Load a image file into the public/assets/_img/ folder. load_img(string $asset) Load a file into the public/assets/ folder. load_file(string $asset) Includes any template that is inside the resource/view folder extend(string $view) Displayed code only in production mode or only in development mode conditional(string $needle, bool $value) Get current csrf-token. See more in CSRF Protection . csrf_token() Form method spoofing. spoofing(string $method)","title":"Wolf Template"},{"location":"helpers/#others","text":"Returns the container defined in the ServiceContainer class. container(string $container_name)","title":"Others"},{"location":"http-client/","text":"Introduction Solital has a component to manipulate the HTTP client, useful for consuming API and making HTTP requests. Basic use To make basic use of the component, you will need use HttpClient class. Then, call the function get , post or other, and the url as a parameter. use Solital\\Core\\Http\\Client\\HttpClient; $response = HttpClient::get('http://127.0.0.1:8080/api/get')->responseJson(); pre($response); Supported methods HttpClient supports the methods below. HttpClient::get() HttpClient::post() HttpClient::put() HttpClient::delete() HttpClient::patch() HttpClient::options() Return types You can return the answer in json, array or object. The methods below show an example. /** Return json */ $client->responseJson(); /** Return array */ $client->responseArray(); /** Return object */ $client->responseObject(); If you want to debug the request, use the enableVerboseOutput() method. $response = HttpClient::get('http://127.0.0.1:8080/api/get')->enableVerboseOutput()->responseJson(); pre($response); Sending data If you are using a POST or PUT request, for example, and need to send data to the HTTP header, you can pass an array with the values on second parameter. $data = ['email' => 'solital@email.com']; $response = HttpClient::post('http://127.0.0.1:8080/api/post', $data)->responseJson(); $response = HttpClient::put('http://127.0.0.1:8080/api/put', $data)->responseJson(); Custom Headers By default, HttpClient has the following headers: Content-Type: application/json Accept: application/json To add other headers to the request, use setHeaders method. $headers = [ 'Content-Type: application/pdf' ]; HttpClient::get('http://127.0.0.1:8080/api/get')->setHeaders($headers)->responseJson(); Disabling SSL verification HttpClient, by default, use SSL verification. To disable verification, use the disableSSL() method. HttpClient::get('http://127.0.0.1:8080/api/get')->disableSSL()->responseJson(); Authentication Basic authentication If you are handling an API with authentication in basic, you can use the basicAuth() method to do the authentication. The first parameter will be the username, while the second parameter will be the password. HttpClient::get('http://127.0.0.1:8080/api/get')->basicAuth('user', 'pass')->responseJson(); Bearer authentication For authentications using the bearer token, you can use the bearerAuth() method to provide the authentication token. HttpClient::get('http://127.0.0.1:8080/api/get')->bearerAuth('2edac0d91305c9207d36eda3cbf2c0d7')->responseJson(); Securing your API When we work with REST API, we need to protect our routes from unauthorized users. With JWT token The most common way to secure an API is through a JWT token. To perform this type of protection, use the protectRoute() method of the JWT class. use Solital\\Core\\Http\\Client\\JWT; Course::get('/api/get', function () { JWT::protectRoute(\"your-secret\"); }); To authenticate, you can generate a token using the encode method of the JWT class and send this token using the bearerToken() method. use Solital\\Core\\Http\\Client\\JWT; $secret = \"your-secret\"; $payload = [ \"sub\" => \"1234567890\", \"name\" => \"Brenno\", \"role\" => \"admin\" ]; $token = JWT::encode($payload, $secret); HttpClient::get('http://127.0.0.1:8080/api/get')->bearerAuth($token)->responseJson(); With Basic Auth To secure your API using basic authentication, use Guardian class with protectBasicAuth() method providing the username and password to authenticate. use Solital\\Core\\Security\\Guardian; Guardian::protectBasicAuth('admin', 'admin'); With Digest Auth To use digest to protect your API, use the protectDigestAuth() method. In this method, you must use an array to inform the username and password. You can define multiple users for this authentication type. use Solital\\Core\\Security\\Guardian; Guardian::protectDigestAuth(['admin' => 'admin', 'user2' => 'pass2']); Unauthorize an authenticated user If you want to deauthorize a user already authenticating (using basic or digest), you can use the unauthorizeAuth method. use Solital\\Core\\Security\\Guardian; Guardian::unauthorizeAuth(); Asynchronous requests If you need to make multiple requests, you can use the sendAsyncRequest() method. This method makes use of PHP's curl_multi_init function. In routes, you will use the async() method to mark routes as asynchronous requests. $response = HttpClient::sendAsyncRequest(function () { HttpClient::get('http://127.0.0.1:8080/api/get')->async(); HttpClient::post('http://127.0.0.1:8080/api/post', ['email' => 'solital@email.com'])->async(); })->responseObject(); print_r($response); Upload and download You can upload or download a file using the CurlHandle class. # Upload $url = 'http://127.0.0.1:8080/api/file'; CurlHandle::upload($url, 'data test', 'test.txt'); # Download $url = 'https://images.pexels.com/photos/...'; CurlHandle::downloader($url, 'photo.jpg');","title":"HTTP Client"},{"location":"http-client/#introduction","text":"Solital has a component to manipulate the HTTP client, useful for consuming API and making HTTP requests.","title":"Introduction"},{"location":"http-client/#basic-use","text":"To make basic use of the component, you will need use HttpClient class. Then, call the function get , post or other, and the url as a parameter. use Solital\\Core\\Http\\Client\\HttpClient; $response = HttpClient::get('http://127.0.0.1:8080/api/get')->responseJson(); pre($response);","title":"Basic use"},{"location":"http-client/#supported-methods","text":"HttpClient supports the methods below. HttpClient::get() HttpClient::post() HttpClient::put() HttpClient::delete() HttpClient::patch() HttpClient::options()","title":"Supported methods"},{"location":"http-client/#return-types","text":"You can return the answer in json, array or object. The methods below show an example. /** Return json */ $client->responseJson(); /** Return array */ $client->responseArray(); /** Return object */ $client->responseObject(); If you want to debug the request, use the enableVerboseOutput() method. $response = HttpClient::get('http://127.0.0.1:8080/api/get')->enableVerboseOutput()->responseJson(); pre($response);","title":"Return types"},{"location":"http-client/#sending-data","text":"If you are using a POST or PUT request, for example, and need to send data to the HTTP header, you can pass an array with the values on second parameter. $data = ['email' => 'solital@email.com']; $response = HttpClient::post('http://127.0.0.1:8080/api/post', $data)->responseJson(); $response = HttpClient::put('http://127.0.0.1:8080/api/put', $data)->responseJson();","title":"Sending data"},{"location":"http-client/#custom-headers","text":"By default, HttpClient has the following headers: Content-Type: application/json Accept: application/json To add other headers to the request, use setHeaders method. $headers = [ 'Content-Type: application/pdf' ]; HttpClient::get('http://127.0.0.1:8080/api/get')->setHeaders($headers)->responseJson();","title":"Custom Headers"},{"location":"http-client/#disabling-ssl-verification","text":"HttpClient, by default, use SSL verification. To disable verification, use the disableSSL() method. HttpClient::get('http://127.0.0.1:8080/api/get')->disableSSL()->responseJson();","title":"Disabling SSL verification"},{"location":"http-client/#authentication","text":"","title":"Authentication"},{"location":"http-client/#basic-authentication","text":"If you are handling an API with authentication in basic, you can use the basicAuth() method to do the authentication. The first parameter will be the username, while the second parameter will be the password. HttpClient::get('http://127.0.0.1:8080/api/get')->basicAuth('user', 'pass')->responseJson();","title":"Basic authentication"},{"location":"http-client/#bearer-authentication","text":"For authentications using the bearer token, you can use the bearerAuth() method to provide the authentication token. HttpClient::get('http://127.0.0.1:8080/api/get')->bearerAuth('2edac0d91305c9207d36eda3cbf2c0d7')->responseJson();","title":"Bearer authentication"},{"location":"http-client/#securing-your-api","text":"When we work with REST API, we need to protect our routes from unauthorized users.","title":"Securing your API"},{"location":"http-client/#with-jwt-token","text":"The most common way to secure an API is through a JWT token. To perform this type of protection, use the protectRoute() method of the JWT class. use Solital\\Core\\Http\\Client\\JWT; Course::get('/api/get', function () { JWT::protectRoute(\"your-secret\"); }); To authenticate, you can generate a token using the encode method of the JWT class and send this token using the bearerToken() method. use Solital\\Core\\Http\\Client\\JWT; $secret = \"your-secret\"; $payload = [ \"sub\" => \"1234567890\", \"name\" => \"Brenno\", \"role\" => \"admin\" ]; $token = JWT::encode($payload, $secret); HttpClient::get('http://127.0.0.1:8080/api/get')->bearerAuth($token)->responseJson();","title":"With JWT token"},{"location":"http-client/#with-basic-auth","text":"To secure your API using basic authentication, use Guardian class with protectBasicAuth() method providing the username and password to authenticate. use Solital\\Core\\Security\\Guardian; Guardian::protectBasicAuth('admin', 'admin');","title":"With Basic Auth"},{"location":"http-client/#with-digest-auth","text":"To use digest to protect your API, use the protectDigestAuth() method. In this method, you must use an array to inform the username and password. You can define multiple users for this authentication type. use Solital\\Core\\Security\\Guardian; Guardian::protectDigestAuth(['admin' => 'admin', 'user2' => 'pass2']);","title":"With Digest Auth"},{"location":"http-client/#unauthorize-an-authenticated-user","text":"If you want to deauthorize a user already authenticating (using basic or digest), you can use the unauthorizeAuth method. use Solital\\Core\\Security\\Guardian; Guardian::unauthorizeAuth();","title":"Unauthorize an authenticated user"},{"location":"http-client/#asynchronous-requests","text":"If you need to make multiple requests, you can use the sendAsyncRequest() method. This method makes use of PHP's curl_multi_init function. In routes, you will use the async() method to mark routes as asynchronous requests. $response = HttpClient::sendAsyncRequest(function () { HttpClient::get('http://127.0.0.1:8080/api/get')->async(); HttpClient::post('http://127.0.0.1:8080/api/post', ['email' => 'solital@email.com'])->async(); })->responseObject(); print_r($response);","title":"Asynchronous requests"},{"location":"http-client/#upload-and-download","text":"You can upload or download a file using the CurlHandle class. # Upload $url = 'http://127.0.0.1:8080/api/file'; CurlHandle::upload($url, 'data test', 'test.txt'); # Download $url = 'https://images.pexels.com/photos/...'; CurlHandle::downloader($url, 'photo.jpg');","title":"Upload and download"},{"location":"input-and-params/","text":"Solital offers libraries and helpers that makes it easy to manage and manipulate input-parameters like $_POST , $_GET and $_FILE . You can use the InputHandler class to easily access and manage parameters from your request. The InputHandler class offers extended features such as copying/moving uploaded files directly on the object, getting file-extension, mime-type etc. Get single parameter value # With Helper input($index, $defaultValue, ...$methods); # With method $this->getRequestParams($index, $defaultValue, ...$methods); To quickly get a value from a parameter, you can use the input helper function or the getRequestParams method. The getRequestParams method can only be used inside a Controller. This will automatically trim the value and ensure that it's not empty. If it's empty the $defaultValue will be returned instead. Note: This function returns a string unless the parameters are grouped together, in that case it will return an array of values. Example: This example matches both POST and GET request-methods and if name is empty the default-value \"Guest\" will be returned. #With helper $name = input('name', 'Guest', 'post', 'get'); # With method $name = $this->getRequestParams('name', 'Guest', 'post', 'get'); Get parameter object When dealing with file-uploads it can be useful to retrieve the raw parameter object. Search for object with default-value across multiple or specific request-methods: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. #With Helper $object = input()->find($index, $defaultValue = null, ...$methods); # With method $object = $this->getRequestParams()->find($index, $defaultValue = null, ...$methods); Getting specific $_GET parameter as InputItem object: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. # With Helper $object = input()->get($index, $defaultValue = null); # With method $object = $this->getRequestParams()->get($index, $defaultValue = null); Getting specific $_POST parameter as InputItem object: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. # With Helper $object = input()->post($index, $defaultValue = null); # With method $object = $this->getRequestParams()->post($index, $defaultValue = null); Getting specific $_FILE parameter as InputFile object: The example below will return an InputFile object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputFile objects. # With Helper $object = input()->file($index, $defaultValue = null); # With method $object = $this->getRequestParams()->file($index, $defaultValue = null); Managing files Below you will find some code to help you upload files in a quick way. /** * From a form on the page like this * <input type=\"file\" name=\"images\" /> * * Only file */ $ext = input()->file('image')->getExtension(); $imgMain = 'IMG-'.uniqid().\".\".$ext; input()->file('image')->move(dirname(__DIR__).'/photos/'.$imgMain); /** * Loop through a collection of files uploaded from a form on the page like this * <input type=\"file\" name=\"images[]\" multiple /> * * Multiple files */ foreach ($photo as $photo) { $ext = $photo->getExtension(); $img = 'IMG-'.uniqid().\".\".$ext; $photo->move(dirname(__DIR__).'/photos/'.$img); } Or, if you use the getRequestParams method: /** * Only file */ $ext = $this->getRequestParams()->file('image')->getExtension(); $imgMain = 'IMG-'.uniqid().\".\".$ext; $this->getRequestParams()->file('image')->move(dirname(__DIR__).'/photos/'.$imgMain); /** * Multiple files */ foreach ($photo as $photo) { $ext = $photo->getExtension(); $img = 'IMG-'.uniqid().\".\".$ext; $photo->move(dirname(__DIR__).'/photos/'.$img); } Get all parameters In array: # Get all $values = input()->all(); # Only match specific keys $values = input()->all([ 'company_name', 'user_id' ]); In JSON: $values = input()->getAllJson(); All object implements the InputItemInterface interface and will always contain these methods: getIndex() - returns the index/key of the input. getName() - returns a human friendly name for the input (company_name will be Company Name etc). getValue() - returns the value of the input. InputFile has the same methods as above along with some other file-specific methods like: getFilename - get the filename. getTmpName() - get file temporary name. getSize() - get file size. move($destination) - move file to destination. getContents() - get file content. getType() - get mime-type for file. getError() - get file upload error. hasError() - returns bool if an error occurred while uploading (if getError is not 0). toArray() - returns raw array","title":"Input and params"},{"location":"input-and-params/#get-single-parameter-value","text":"# With Helper input($index, $defaultValue, ...$methods); # With method $this->getRequestParams($index, $defaultValue, ...$methods); To quickly get a value from a parameter, you can use the input helper function or the getRequestParams method. The getRequestParams method can only be used inside a Controller. This will automatically trim the value and ensure that it's not empty. If it's empty the $defaultValue will be returned instead. Note: This function returns a string unless the parameters are grouped together, in that case it will return an array of values. Example: This example matches both POST and GET request-methods and if name is empty the default-value \"Guest\" will be returned. #With helper $name = input('name', 'Guest', 'post', 'get'); # With method $name = $this->getRequestParams('name', 'Guest', 'post', 'get');","title":"Get single parameter value"},{"location":"input-and-params/#get-parameter-object","text":"When dealing with file-uploads it can be useful to retrieve the raw parameter object. Search for object with default-value across multiple or specific request-methods: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. #With Helper $object = input()->find($index, $defaultValue = null, ...$methods); # With method $object = $this->getRequestParams()->find($index, $defaultValue = null, ...$methods); Getting specific $_GET parameter as InputItem object: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. # With Helper $object = input()->get($index, $defaultValue = null); # With method $object = $this->getRequestParams()->get($index, $defaultValue = null); Getting specific $_POST parameter as InputItem object: The example below will return an InputItem object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputItem objects. # With Helper $object = input()->post($index, $defaultValue = null); # With method $object = $this->getRequestParams()->post($index, $defaultValue = null); Getting specific $_FILE parameter as InputFile object: The example below will return an InputFile object if the parameter was found or return the $defaultValue . If parameters are grouped, it will return an array of InputFile objects. # With Helper $object = input()->file($index, $defaultValue = null); # With method $object = $this->getRequestParams()->file($index, $defaultValue = null);","title":"Get parameter object"},{"location":"input-and-params/#managing-files","text":"Below you will find some code to help you upload files in a quick way. /** * From a form on the page like this * <input type=\"file\" name=\"images\" /> * * Only file */ $ext = input()->file('image')->getExtension(); $imgMain = 'IMG-'.uniqid().\".\".$ext; input()->file('image')->move(dirname(__DIR__).'/photos/'.$imgMain); /** * Loop through a collection of files uploaded from a form on the page like this * <input type=\"file\" name=\"images[]\" multiple /> * * Multiple files */ foreach ($photo as $photo) { $ext = $photo->getExtension(); $img = 'IMG-'.uniqid().\".\".$ext; $photo->move(dirname(__DIR__).'/photos/'.$img); } Or, if you use the getRequestParams method: /** * Only file */ $ext = $this->getRequestParams()->file('image')->getExtension(); $imgMain = 'IMG-'.uniqid().\".\".$ext; $this->getRequestParams()->file('image')->move(dirname(__DIR__).'/photos/'.$imgMain); /** * Multiple files */ foreach ($photo as $photo) { $ext = $photo->getExtension(); $img = 'IMG-'.uniqid().\".\".$ext; $photo->move(dirname(__DIR__).'/photos/'.$img); }","title":"Managing files"},{"location":"input-and-params/#get-all-parameters","text":"In array: # Get all $values = input()->all(); # Only match specific keys $values = input()->all([ 'company_name', 'user_id' ]); In JSON: $values = input()->getAllJson(); All object implements the InputItemInterface interface and will always contain these methods: getIndex() - returns the index/key of the input. getName() - returns a human friendly name for the input (company_name will be Company Name etc). getValue() - returns the value of the input. InputFile has the same methods as above along with some other file-specific methods like: getFilename - get the filename. getTmpName() - get file temporary name. getSize() - get file size. move($destination) - move file to destination. getContents() - get file content. getType() - get mime-type for file. getError() - get file upload error. hasError() - returns bool if an error occurred while uploading (if getError is not 0). toArray() - returns raw array","title":"Get all parameters"},{"location":"json/","text":"You can manipulate JSON using the JSON class or using the helpers encodeJSON and decodeJSON . The difference of this class for json_encode and json_decode is that you can automatically view errors when encoding/decoding a JSON, in addition to looking for a value within a JSON and reading external files. There are two ways to use this class, using the helpers mentioned above, or by instantiating the JSON class. # Instantiating the JSON class use Solital\\Core\\Resource\\JSON; $json = new JSON(); # Using the helpers encodeJSON and decodeJSON encodeJSON($json); decodeJSON($json); Predefined Constants By default, the JSON_UNESCAPED_UNICODE constant is defined in the constructor of the JSON class or the helper encodeJSON . It is possible to add more than one constant following the model below: # Class $json = new JSON(JSON_HEX_TAG | JSON_HEX_AMP | JSON_UNESCAPED_UNICODE); # Helper encodeJSON($json, JSON_HEX_TAG | JSON_HEX_AMP | JSON_UNESCAPED_UNICODE); Encode JSON The encode method creates a JSON from an array, or use the encodeJSON helper. $array = [\"name\" => \"Adith\u00fda\", \"age\" => 20]; # Class $json = new JSON(); $res = $json->encode($array); # Helper $res = encodeJSON($array); /* Return JSON */ pre($res); Decode JSON The decode method decodes JSON into an object or array. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; # Class $json = new JSON(); $res = $json->decode($json_file); # Helper $res = decodeJSON($json_file); /* Return object */ pre($res); To return an associative array, use true in the second parameter. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; # Class $json = new JSON(); $res = $json->decode($json_file, true); # Helper $res = decodeJSON($json_file, true); /* Return array */ pre($res); Returning a value in JSON If you need to read a value from the JSON file, use the inJson method. Inform JSON in the first parameter and the name of the key that contains the value in the second parameter. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; $json = new JSON(); $res = $json->inJson($json , 'Organization'); /* Return string */ pre($res); Read an external JSON file If you want to read an external file, use readFile . This method works in a similar way to the decode method. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; $json = new JSON(); $res = $json->readFile('data.json'); /* Return object */ pre($res); Returning in array $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; $json = new JSON(); $res = $json->readFile('data.json', true); /* Return array */ pre($res); Returning errors A JSON containing the type of error is returned whenever there is a failure to code or decode a JSON. Below is an example of how it is returned: { \"json_error\": \"Syntax error, malformed JSON\" } Enabling Exceptions To enable exceptions in case there is a Json reading error, change the value of the json_exception key to true . You can find this key in the bootstrap.yaml configuration file. json_exception: true","title":"JSON"},{"location":"json/#predefined-constants","text":"By default, the JSON_UNESCAPED_UNICODE constant is defined in the constructor of the JSON class or the helper encodeJSON . It is possible to add more than one constant following the model below: # Class $json = new JSON(JSON_HEX_TAG | JSON_HEX_AMP | JSON_UNESCAPED_UNICODE); # Helper encodeJSON($json, JSON_HEX_TAG | JSON_HEX_AMP | JSON_UNESCAPED_UNICODE);","title":"Predefined Constants"},{"location":"json/#encode-json","text":"The encode method creates a JSON from an array, or use the encodeJSON helper. $array = [\"name\" => \"Adith\u00fda\", \"age\" => 20]; # Class $json = new JSON(); $res = $json->encode($array); # Helper $res = encodeJSON($array); /* Return JSON */ pre($res);","title":"Encode JSON"},{"location":"json/#decode-json","text":"The decode method decodes JSON into an object or array. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; # Class $json = new JSON(); $res = $json->decode($json_file); # Helper $res = decodeJSON($json_file); /* Return object */ pre($res); To return an associative array, use true in the second parameter. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; # Class $json = new JSON(); $res = $json->decode($json_file, true); # Helper $res = decodeJSON($json_file, true); /* Return array */ pre($res);","title":"Decode JSON"},{"location":"json/#returning-a-value-in-json","text":"If you need to read a value from the JSON file, use the inJson method. Inform JSON in the first parameter and the name of the key that contains the value in the second parameter. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; $json = new JSON(); $res = $json->inJson($json , 'Organization'); /* Return string */ pre($res);","title":"Returning a value in JSON"},{"location":"json/#read-an-external-json-file","text":"If you want to read an external file, use readFile . This method works in a similar way to the decode method. $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; $json = new JSON(); $res = $json->readFile('data.json'); /* Return object */ pre($res); Returning in array $json_file = '{\"Organization\": \"PHP Documentation Team\"}'; $json = new JSON(); $res = $json->readFile('data.json', true); /* Return array */ pre($res);","title":"Read an external JSON file"},{"location":"json/#returning-errors","text":"A JSON containing the type of error is returned whenever there is a failure to code or decode a JSON. Below is an example of how it is returned: { \"json_error\": \"Syntax error, malformed JSON\" }","title":"Returning errors"},{"location":"json/#enabling-exceptions","text":"To enable exceptions in case there is a Json reading error, change the value of the json_exception key to true . You can find this key in the bootstrap.yaml configuration file. json_exception: true","title":"Enabling Exceptions"},{"location":"katrina-1.0/","text":"Getting Started Katrina ORM is a component to bring the object-oriented application development paradigm closer to the relational database paradigm. It helps when carrying out common routines, such as the famous CRUD (create, read, edit and delete), in addition to having a login and data paging system. Requirements PHP >= 7.2 (Compatible with PHP 8) PHP PDO extension enabled Installation Katrina ORM is already installed by default in Solital. But if you are going to install in another project, use the command below to download via Composer. composer require solital/katrina Settings In Solital: # DATABASE CONFIG DB_DRIVE=\"your_drive\" DB_HOST=\"your_host\" DB_NAME=\"your_database_name\" DB_USER=\"your_user\" DB_PASS=\"your_password\" In another project: define('DB_CONFIG', [ 'DRIVE' => 'your_drive', 'HOST' => 'your_host', 'DBNAME' => 'your_database_name', 'USER' => 'your_user', 'PASS' => 'your_password' ]); For SQLite Some differences exist for connecting to an SQLite database. First, add an additional index called SQLITE_DIR in the DB_CONFIG constant. This constant must have the absolute path where the SQLite database file will be located. Then, assign the value sqlite in the index DRIVE . define('DB_CONFIG', [ 'DRIVE' => 'sqlite', 'DBNAME' => 'your_database_name.db', 'SQLITE_DIR' => '/path/to/file/' ]); In Solital: # DATABASE CONFIG DB_DRIVE=\"your_drive\" DB_HOST=\"your_host\" DB_NAME=\"your_database_name\" DB_USER=\"your_user\" DB_PASS=\"your_password\" SQLITE_DIR=\"/path/to/file/\" Initial structure You can use katrina in two ways: 1\u00b0) In Solital, extend the model already created and define the variables $table , $primaryKey and $columns in your model's constructor as listed below: <?php namespace Solital\\Components\\Model; use Solital\\Components\\Model\\Model; class User extends Model { public function __construct() { $this->table = 'your_database_table'; $this->primaryKey = 'primary_key_of_the_table'; $this->columns = [ 'first_column_of_the_table', 'second column of the table', #... ]; } public function get() { return $this->instance()->select()->build(\"ALL\"); } } 2\u00b0) Or if you are using it in another project <?php use Katrina\\Katrina as Katrina; class User { # String private $table = 'your_database_table'; # String private $primaryKey = 'primary_key_of_the_table'; # Array private $columns = [ 'first_column_of_the_table', 'second column of the table', #... ]; public function instance() { $katrina = new Katrina($this->table, $this->columnPrimaryKey, $this->columns); return $katrina; } public function get() { return $this->instance()->select()->build(\"ALL\"); } } Data manipulation - CRUD List To list all fields in the table, use select() as shown in the previous example. By default, the method will list all fields in the table. public function get() { return $this->instance()->select()->build(\"ALL\"); } To list a single value, pass the table field id as a parameter, and in build() method use ONLY . public function get() { return $this->instance()->select(3)->build(\"ONLY\"); } To specify which fields you want to list, pass the values \u200b\u200bas parameters. public function get() { return $this->instance()->select(null, null, \"name, city, country\")->build(\"ALL\"); } WHERE If you need the WHERE clause, use the second parameter. public function get() { return $this->instance()->select(null, 'name=\"Clark\"', \"name, city, country\") ->build(\"ALL\"); } With primary key: public function get() { return $this->instance()->select(3, 'name=\"Clark\"', \"name, city, country\") ->build(\"ONLY\"); } LIMIT public function get() { return $this->instance()->select()->limit(2, 5)->build(\"ALL\"); } LIKE The LIKE operator must always be used with the WHERE . public function get() { return $this->instance()->select(null, \"name\")->like(\"%Harvey%\")->build(\"ALL\"); } ORDER BY public function get() { return $this->instance()->select()->order(\"name\")->build(\"ALL\"); } By default, the result will always return ascending. To return values descending, use false in the second parameter. public function get() { return $this->instance()->select()->order(\"name\", false)->build(\"ALL\"); } BETWEEN The BETWEEN operator must always be used with the WHERE . public function get() { return $this->instance()->select(null, \"age\")->between(18, 25)->build(\"ALL\"); } Listing foreign key The innerJoin() method returns the values of two tables that have a foreign key. The first parameter will be the name of the table that has a relationship with the current table. The second will be an array containing in the first index the column name of the current table that has the foreign key, and in the second index the column name of the primary key of the other table. To make it easier, see an example below. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"]) ->build(\"ALL\"); } If you need to use the WHERE clause, pass the command in the third parameter as shown below. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"], \"order_status=true\")->build(\"ALL\"); } You can inform which fields you want to return. \"a\" is your main table while \"b\" is your table that has the foreign key. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"], \"order_status=true\", \"a.idPerson, a.name, b.street\", \"address\", \"idAddress\")->build(\"ALL\"); } Custom SELECT You can create a custom SELECT statement. To do this, use the function customQueryOnly to return a single value from the database, and customQueryAll to return all values from the database. public function getAll() { return $this->instance()->customQueryAll(\"SELECT a.idSession, SUM(b.price) AS price, SUM(a.qtd) AS qtd FROM tb_order a INNER JOIN tb_product b WHERE MONTH( a.created_at) = MONTH(NOW()) GROUP BY a.idSession\"); } public function getOnly() { return $this->instance()->customQueryOnly(\"SELECT a.idSession, SUM(b.price) AS price, SUM(a.qtd) AS qtd FROM tb_order a INNER JOIN tb_product b WHERE MONTH( a.created_at) = MONTH(NOW()) GROUP BY a.idSession\"); } Insert The insert() method inserts the values \u200b\u200binto the table. It is NOT necessary to use build() method to insert the data. To do this, create an array with the values \u200b\u200bthat the method will receive /** * Return bool */ public function insert() { $res = $this->instance()->insert(['Clark', 'Metropolis', 'EUA']); return $res; } To return the last insert ID, pass a true in the second parameter. /** * Return array * * ['res'] => 'true', * ['lastId'] => '2' */ public function insert() { $res = $this->instance()->insert(['Clark', 'Metropolis', 'EUA'], true); return $res; } Update The update() method updates the values \u200b\u200bin the table. It is NOT necessary to use build() method to update the data. The process is similar to the insert method. The first parameter is the columns that will be updated, the second parameter the values \u200b\u200band the third the row id . You can use an integer or a string in the third parameter public function update() { $res = $this->instance()->update(['name', 'age'], ['Specter', '41'], \"id=3\"); return $res; } Or public function update() { $res = $this->instance()->update(['name', 'age'], ['Specter', '41'], 3); return $res; } Delete The delete() method deletes the values \u200b\u200bin the table. Enter the value of the line to be deleted, the value being the primary key. public function delete() { $res = $this->instance()->delete(3)->build(); return $res; } Or a string public function delete() { $res = $this->instance()->delete(\"Bruce\")->build(); return $res; } By default, the delete method uses the column name of the primary key to delete the row, but you can use the name of another column using the second parameter. public function delete() { $res = $this->instance()->delete(\"Bruce\", \"name\")->build(); return $res; } Force delete with foreign key In some cases there may be a need to delete a record with the foreign key from another table. To disable foreign key checking, you can use the third parameter as true . public function delete() { $res = $this->instance()->delete(3, null, true)->build(); return $res; } Manipulating tables Create a new table The createTable() method starts opening the table. After inserting the fields and data types that the tables will have, use closeTable() to close the table. For a better understanding see the syntax below. $res = $this->instance() /* Starts the table by specifying its name */ ->createTable(\"your_table_name\") /* Fields and table type */ ->int(\"id_orm\")->primary()->increment() ->varchar(\"name\", 20)->unique()->notNull()->default(\"specter\") ->int(\"age\", 3)->unsigned()->notNull() ->varchar(\"email\", 30)->default(\"harvey.specter@gmail.com\")->notNull() ->varchar(\"profession\", 40) ->int(\"tipo\") ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") /* Close the command to create the table */ ->closeTable() /* Compile the code above */ ->build(); List tables To have a list of all the tables in your database, use the listTables() method by passing ALL in the build() method. public function get() { $res = $this->instance()->listTables()->build(\"ALL\"); return $res; } List columns To list the columns of a table, use the describeTable() method passing as a parameter the name of your table together with ALL in the build() public function get() { $res = $this->instance()->describeTable(\"your_table\")->build(\"ALL\"); return $res; } Alter table The alter() method performs the procedures of adding, changing and deleting a field from the database table. Add new field Use add() method together with the data type to add a new field. public function get() { $res = $this->instance() ->alter(\"message\")->add() ->varchar(\"first_field\", 10) ->build(); } Drop column Use the drop() method to delete a column from the table. public function get() { $res = $this->instance() ->alter(\"message\")->drop(\"type\") ->build(); } Modify column Use the modify SQL with the modify() method. public function get() { $res = $this->instance() ->alter(\"message\")->modify() ->varchar(\"person_type\", 100) ->build(); } Change column Use the change() method to change a column. As a parameter, pass the current column name. public function get() { $res = $this->instance() ->alter(\"message\")->change(\"person_type\") ->varchar(\"type\", 100) ->build(); } Rename table Use the rename() method to rename a database table. Use the first parameter the current table name and the second parameter the new table name. public function get() { $res = $this->instance() ->rename(\"message\", \"new_message\") ->build(); } Adding foreign key To add a foreign key to an already created table, use the addConstraint() method to add a constraint; foreign() to inform the column and references() to refer to the table. public function get() { $res = $this->instance() ->alter(\"message\")->addConstraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") ->build(); } NOTE: if you are creating a new table, use the constraint() method instead of addConstraint() as shown below: #... ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") #... Drop table To delete a table from the database, use the dropTable() method. public function get() { $res = $this->instance() ->dropTable(\"message\") ->build(); } Truncate table To use the sql truncate command, use the truncate() method. public function get() { $res = $this->instance() ->truncate() ->build(); } By default, the database checks the table's foreign key and locks the truncate command. To disable foreign key verification, enter true as a parameter. public function get() { $res = $this->instance() ->truncate(true) ->build(); } Procedure To call a database procedure, use the call() method. public function get() { $res = $this->instance()->call('procedure_name'); return $res; } To use procedure parameters, pass the values in array format. public function get() { $res = $this->instance()->call('procedure_name' , ['param_1, param_2, param_3']); return $res; } Pagination The pagination() method creates a system for paging results. To initialize, the first parameter must be the table you want to use to start paging. The second parameter will list the amount of values that will be returned from the table as shown in the example below. public function get() { $res = $this->instance()->pagination('your_table', 3); return $res; } The above method will return an array containing rows indexes that will return values, and arrows that will return commands for pagination. To use pagination with relationship in another table, in the third parameter pass an array containing the name of the table that has a relationship with the current table, the column name of the current table that has the foreign key and the column name of the primary key of the another table. public function get() { $res = $this->instance()->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key']); return $res; } INNER JOIN If you want to use pagination with a table that has a foreign key, pass an array in the third parameter. In the first index, insert the name of the table that is linked to the current table, in the second index the name of the column that contains the foreign key and in the third index the column name of the primary key of the table that references the current table public function get() { $res = $this->instance()->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key'], \"status=true\"); return $res; } WHERE clause To use the WHERE clause, use the fourth parameter as shown below. public function get() { $res = $this->instance()->pagination('your_table', 3, null, \"status=true\"); return $res; } Wolf Templte To use in the Wolf template, use it this way. $html = $this->instance()->pagination('your_table', 3); Wolf::loadView('home', [ 'rows' => $html['rows'], 'arrows' => $html['arrows'] ]); And in your view, return the results that way. <table> <thead> <tr> <th>Name</th> <th>Age</th> <th>Gender</th> </tr> </thead> <tbody> <?php foreach ($rows as $r): ?> <tr> <td><?= $r['name'] ?></td> <td><?= $r['age'] ?></td> <td><?= $r['gender'] ?></td> </tr> <?php endforeach; ?> </tbody> </table> <?php echo $arrows; The result will be as follows: Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female << 1 2 3 >> To change the arrows ( << and >> ), use the last two parameters of the pagination() method. The result will be: public function get() { $res = $this->instance()->pagination('your_table', 3, null, null, \"First\", \"Last\"); return $res; } Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female First 1 2 3 Last Custom Pagination If you have a very complex SELECT statement, you can use the customPagination method. This method already has a LIMIT by default, in addition to being able to change the name of the arrows. public function get() { $res = $this->instance()->customPagination(\"SELECT created_at, order_status, idSession, SUM(idOrder) AS idOrder FROM `tb_order` GROUP BY created_at, order_status, idSession\", 3, \"First\", \"Last\"); return $res; } Customizing arrows CSS You can customize the look of the arrows through the classes pagination_first_item , pagination_atual_item , pagination_others_itens and pagination_last_item . Below is a customization to serve as an example: .pagination_atual_item { background-color: #B5B5B5; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item, .pagination_others_itens, .pagination_last_item { background-color: #4682B4; color: #FFF; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item:hover, .pagination_others_itens:hover, .pagination_last_item:hover { background-color: #0071E3; color: #FFF !important; transition: 0.2s; } Types of data Below is listed the attributes and data supported by Katrina ORM: String data Types varchar(\"column_name\", size) char(\"column_name\", size) tinytext(\"column_name\", size) mediumtext(\"column_name\", size) longtext(\"column_name\", size) text(\"column_name\") Numerical data Types tinyint(\"column_name\", size) smallint(\"column_name\", size) mediumint(\"column_name\", size) bigint(\"column_name\", size) int(\"column_name\", size) decimal(\"column_name\", value1, value2) Date and time Types date(\"column_name\") year(\"column_name\") time(\"column_name\") datetime(\"column_name\") timestamp(\"column_name\") Boolean Types boolean(\"column_name\") Attributes Types default(\"default_value\") unique() unsigned() incremet() notNull() primary() after(\"column_name\") first()","title":"Katrina 1.0"},{"location":"katrina-1.0/#getting-started","text":"Katrina ORM is a component to bring the object-oriented application development paradigm closer to the relational database paradigm. It helps when carrying out common routines, such as the famous CRUD (create, read, edit and delete), in addition to having a login and data paging system.","title":"Getting Started"},{"location":"katrina-1.0/#requirements","text":"PHP >= 7.2 (Compatible with PHP 8) PHP PDO extension enabled","title":"Requirements"},{"location":"katrina-1.0/#installation","text":"Katrina ORM is already installed by default in Solital. But if you are going to install in another project, use the command below to download via Composer. composer require solital/katrina","title":"Installation"},{"location":"katrina-1.0/#settings","text":"In Solital: # DATABASE CONFIG DB_DRIVE=\"your_drive\" DB_HOST=\"your_host\" DB_NAME=\"your_database_name\" DB_USER=\"your_user\" DB_PASS=\"your_password\" In another project: define('DB_CONFIG', [ 'DRIVE' => 'your_drive', 'HOST' => 'your_host', 'DBNAME' => 'your_database_name', 'USER' => 'your_user', 'PASS' => 'your_password' ]);","title":"Settings"},{"location":"katrina-1.0/#for-sqlite","text":"Some differences exist for connecting to an SQLite database. First, add an additional index called SQLITE_DIR in the DB_CONFIG constant. This constant must have the absolute path where the SQLite database file will be located. Then, assign the value sqlite in the index DRIVE . define('DB_CONFIG', [ 'DRIVE' => 'sqlite', 'DBNAME' => 'your_database_name.db', 'SQLITE_DIR' => '/path/to/file/' ]); In Solital: # DATABASE CONFIG DB_DRIVE=\"your_drive\" DB_HOST=\"your_host\" DB_NAME=\"your_database_name\" DB_USER=\"your_user\" DB_PASS=\"your_password\" SQLITE_DIR=\"/path/to/file/\"","title":"For SQLite"},{"location":"katrina-1.0/#initial-structure","text":"You can use katrina in two ways: 1\u00b0) In Solital, extend the model already created and define the variables $table , $primaryKey and $columns in your model's constructor as listed below: <?php namespace Solital\\Components\\Model; use Solital\\Components\\Model\\Model; class User extends Model { public function __construct() { $this->table = 'your_database_table'; $this->primaryKey = 'primary_key_of_the_table'; $this->columns = [ 'first_column_of_the_table', 'second column of the table', #... ]; } public function get() { return $this->instance()->select()->build(\"ALL\"); } } 2\u00b0) Or if you are using it in another project <?php use Katrina\\Katrina as Katrina; class User { # String private $table = 'your_database_table'; # String private $primaryKey = 'primary_key_of_the_table'; # Array private $columns = [ 'first_column_of_the_table', 'second column of the table', #... ]; public function instance() { $katrina = new Katrina($this->table, $this->columnPrimaryKey, $this->columns); return $katrina; } public function get() { return $this->instance()->select()->build(\"ALL\"); } }","title":"Initial structure"},{"location":"katrina-1.0/#data-manipulation-crud","text":"","title":"Data manipulation - CRUD"},{"location":"katrina-1.0/#list","text":"To list all fields in the table, use select() as shown in the previous example. By default, the method will list all fields in the table. public function get() { return $this->instance()->select()->build(\"ALL\"); } To list a single value, pass the table field id as a parameter, and in build() method use ONLY . public function get() { return $this->instance()->select(3)->build(\"ONLY\"); } To specify which fields you want to list, pass the values \u200b\u200bas parameters. public function get() { return $this->instance()->select(null, null, \"name, city, country\")->build(\"ALL\"); } WHERE If you need the WHERE clause, use the second parameter. public function get() { return $this->instance()->select(null, 'name=\"Clark\"', \"name, city, country\") ->build(\"ALL\"); } With primary key: public function get() { return $this->instance()->select(3, 'name=\"Clark\"', \"name, city, country\") ->build(\"ONLY\"); } LIMIT public function get() { return $this->instance()->select()->limit(2, 5)->build(\"ALL\"); } LIKE The LIKE operator must always be used with the WHERE . public function get() { return $this->instance()->select(null, \"name\")->like(\"%Harvey%\")->build(\"ALL\"); } ORDER BY public function get() { return $this->instance()->select()->order(\"name\")->build(\"ALL\"); } By default, the result will always return ascending. To return values descending, use false in the second parameter. public function get() { return $this->instance()->select()->order(\"name\", false)->build(\"ALL\"); } BETWEEN The BETWEEN operator must always be used with the WHERE . public function get() { return $this->instance()->select(null, \"age\")->between(18, 25)->build(\"ALL\"); }","title":"List"},{"location":"katrina-1.0/#listing-foreign-key","text":"The innerJoin() method returns the values of two tables that have a foreign key. The first parameter will be the name of the table that has a relationship with the current table. The second will be an array containing in the first index the column name of the current table that has the foreign key, and in the second index the column name of the primary key of the other table. To make it easier, see an example below. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"]) ->build(\"ALL\"); } If you need to use the WHERE clause, pass the command in the third parameter as shown below. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"], \"order_status=true\")->build(\"ALL\"); } You can inform which fields you want to return. \"a\" is your main table while \"b\" is your table that has the foreign key. public function get() { return $this->instance()->innerJoin(\"address\", [\"idForeignAddress\", \"idAddress\"], \"order_status=true\", \"a.idPerson, a.name, b.street\", \"address\", \"idAddress\")->build(\"ALL\"); }","title":"Listing foreign key"},{"location":"katrina-1.0/#custom-select","text":"You can create a custom SELECT statement. To do this, use the function customQueryOnly to return a single value from the database, and customQueryAll to return all values from the database. public function getAll() { return $this->instance()->customQueryAll(\"SELECT a.idSession, SUM(b.price) AS price, SUM(a.qtd) AS qtd FROM tb_order a INNER JOIN tb_product b WHERE MONTH( a.created_at) = MONTH(NOW()) GROUP BY a.idSession\"); } public function getOnly() { return $this->instance()->customQueryOnly(\"SELECT a.idSession, SUM(b.price) AS price, SUM(a.qtd) AS qtd FROM tb_order a INNER JOIN tb_product b WHERE MONTH( a.created_at) = MONTH(NOW()) GROUP BY a.idSession\"); }","title":"Custom SELECT"},{"location":"katrina-1.0/#insert","text":"The insert() method inserts the values \u200b\u200binto the table. It is NOT necessary to use build() method to insert the data. To do this, create an array with the values \u200b\u200bthat the method will receive /** * Return bool */ public function insert() { $res = $this->instance()->insert(['Clark', 'Metropolis', 'EUA']); return $res; } To return the last insert ID, pass a true in the second parameter. /** * Return array * * ['res'] => 'true', * ['lastId'] => '2' */ public function insert() { $res = $this->instance()->insert(['Clark', 'Metropolis', 'EUA'], true); return $res; }","title":"Insert"},{"location":"katrina-1.0/#update","text":"The update() method updates the values \u200b\u200bin the table. It is NOT necessary to use build() method to update the data. The process is similar to the insert method. The first parameter is the columns that will be updated, the second parameter the values \u200b\u200band the third the row id . You can use an integer or a string in the third parameter public function update() { $res = $this->instance()->update(['name', 'age'], ['Specter', '41'], \"id=3\"); return $res; } Or public function update() { $res = $this->instance()->update(['name', 'age'], ['Specter', '41'], 3); return $res; }","title":"Update"},{"location":"katrina-1.0/#delete","text":"The delete() method deletes the values \u200b\u200bin the table. Enter the value of the line to be deleted, the value being the primary key. public function delete() { $res = $this->instance()->delete(3)->build(); return $res; } Or a string public function delete() { $res = $this->instance()->delete(\"Bruce\")->build(); return $res; } By default, the delete method uses the column name of the primary key to delete the row, but you can use the name of another column using the second parameter. public function delete() { $res = $this->instance()->delete(\"Bruce\", \"name\")->build(); return $res; } Force delete with foreign key In some cases there may be a need to delete a record with the foreign key from another table. To disable foreign key checking, you can use the third parameter as true . public function delete() { $res = $this->instance()->delete(3, null, true)->build(); return $res; }","title":"Delete"},{"location":"katrina-1.0/#manipulating-tables","text":"","title":"Manipulating tables"},{"location":"katrina-1.0/#create-a-new-table","text":"The createTable() method starts opening the table. After inserting the fields and data types that the tables will have, use closeTable() to close the table. For a better understanding see the syntax below. $res = $this->instance() /* Starts the table by specifying its name */ ->createTable(\"your_table_name\") /* Fields and table type */ ->int(\"id_orm\")->primary()->increment() ->varchar(\"name\", 20)->unique()->notNull()->default(\"specter\") ->int(\"age\", 3)->unsigned()->notNull() ->varchar(\"email\", 30)->default(\"harvey.specter@gmail.com\")->notNull() ->varchar(\"profession\", 40) ->int(\"tipo\") ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") /* Close the command to create the table */ ->closeTable() /* Compile the code above */ ->build();","title":"Create a new table"},{"location":"katrina-1.0/#list-tables","text":"To have a list of all the tables in your database, use the listTables() method by passing ALL in the build() method. public function get() { $res = $this->instance()->listTables()->build(\"ALL\"); return $res; }","title":"List tables"},{"location":"katrina-1.0/#list-columns","text":"To list the columns of a table, use the describeTable() method passing as a parameter the name of your table together with ALL in the build() public function get() { $res = $this->instance()->describeTable(\"your_table\")->build(\"ALL\"); return $res; }","title":"List columns"},{"location":"katrina-1.0/#alter-table","text":"The alter() method performs the procedures of adding, changing and deleting a field from the database table. Add new field Use add() method together with the data type to add a new field. public function get() { $res = $this->instance() ->alter(\"message\")->add() ->varchar(\"first_field\", 10) ->build(); } Drop column Use the drop() method to delete a column from the table. public function get() { $res = $this->instance() ->alter(\"message\")->drop(\"type\") ->build(); } Modify column Use the modify SQL with the modify() method. public function get() { $res = $this->instance() ->alter(\"message\")->modify() ->varchar(\"person_type\", 100) ->build(); } Change column Use the change() method to change a column. As a parameter, pass the current column name. public function get() { $res = $this->instance() ->alter(\"message\")->change(\"person_type\") ->varchar(\"type\", 100) ->build(); } Rename table Use the rename() method to rename a database table. Use the first parameter the current table name and the second parameter the new table name. public function get() { $res = $this->instance() ->rename(\"message\", \"new_message\") ->build(); }","title":"Alter table"},{"location":"katrina-1.0/#adding-foreign-key","text":"To add a foreign key to an already created table, use the addConstraint() method to add a constraint; foreign() to inform the column and references() to refer to the table. public function get() { $res = $this->instance() ->alter(\"message\")->addConstraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") ->build(); } NOTE: if you are creating a new table, use the constraint() method instead of addConstraint() as shown below: #... ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") #...","title":"Adding foreign key"},{"location":"katrina-1.0/#drop-table","text":"To delete a table from the database, use the dropTable() method. public function get() { $res = $this->instance() ->dropTable(\"message\") ->build(); }","title":"Drop table"},{"location":"katrina-1.0/#truncate-table","text":"To use the sql truncate command, use the truncate() method. public function get() { $res = $this->instance() ->truncate() ->build(); } By default, the database checks the table's foreign key and locks the truncate command. To disable foreign key verification, enter true as a parameter. public function get() { $res = $this->instance() ->truncate(true) ->build(); }","title":"Truncate table"},{"location":"katrina-1.0/#procedure","text":"To call a database procedure, use the call() method. public function get() { $res = $this->instance()->call('procedure_name'); return $res; } To use procedure parameters, pass the values in array format. public function get() { $res = $this->instance()->call('procedure_name' , ['param_1, param_2, param_3']); return $res; }","title":"Procedure"},{"location":"katrina-1.0/#pagination","text":"The pagination() method creates a system for paging results. To initialize, the first parameter must be the table you want to use to start paging. The second parameter will list the amount of values that will be returned from the table as shown in the example below. public function get() { $res = $this->instance()->pagination('your_table', 3); return $res; } The above method will return an array containing rows indexes that will return values, and arrows that will return commands for pagination. To use pagination with relationship in another table, in the third parameter pass an array containing the name of the table that has a relationship with the current table, the column name of the current table that has the foreign key and the column name of the primary key of the another table. public function get() { $res = $this->instance()->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key']); return $res; } INNER JOIN If you want to use pagination with a table that has a foreign key, pass an array in the third parameter. In the first index, insert the name of the table that is linked to the current table, in the second index the name of the column that contains the foreign key and in the third index the column name of the primary key of the table that references the current table public function get() { $res = $this->instance()->pagination('your_table', 3, ['foreign_table', 'column_foreign_key', 'column_primary_key'], \"status=true\"); return $res; } WHERE clause To use the WHERE clause, use the fourth parameter as shown below. public function get() { $res = $this->instance()->pagination('your_table', 3, null, \"status=true\"); return $res; } Wolf Templte To use in the Wolf template, use it this way. $html = $this->instance()->pagination('your_table', 3); Wolf::loadView('home', [ 'rows' => $html['rows'], 'arrows' => $html['arrows'] ]); And in your view, return the results that way. <table> <thead> <tr> <th>Name</th> <th>Age</th> <th>Gender</th> </tr> </thead> <tbody> <?php foreach ($rows as $r): ?> <tr> <td><?= $r['name'] ?></td> <td><?= $r['age'] ?></td> <td><?= $r['gender'] ?></td> </tr> <?php endforeach; ?> </tbody> </table> <?php echo $arrows; The result will be as follows: Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female << 1 2 3 >> To change the arrows ( << and >> ), use the last two parameters of the pagination() method. The result will be: public function get() { $res = $this->instance()->pagination('your_table', 3, null, null, \"First\", \"Last\"); return $res; } Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female First 1 2 3 Last","title":"Pagination"},{"location":"katrina-1.0/#custom-pagination","text":"If you have a very complex SELECT statement, you can use the customPagination method. This method already has a LIMIT by default, in addition to being able to change the name of the arrows. public function get() { $res = $this->instance()->customPagination(\"SELECT created_at, order_status, idSession, SUM(idOrder) AS idOrder FROM `tb_order` GROUP BY created_at, order_status, idSession\", 3, \"First\", \"Last\"); return $res; } Customizing arrows CSS You can customize the look of the arrows through the classes pagination_first_item , pagination_atual_item , pagination_others_itens and pagination_last_item . Below is a customization to serve as an example: .pagination_atual_item { background-color: #B5B5B5; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item, .pagination_others_itens, .pagination_last_item { background-color: #4682B4; color: #FFF; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item:hover, .pagination_others_itens:hover, .pagination_last_item:hover { background-color: #0071E3; color: #FFF !important; transition: 0.2s; }","title":"Custom Pagination"},{"location":"katrina-1.0/#types-of-data","text":"Below is listed the attributes and data supported by Katrina ORM: String data Types varchar(\"column_name\", size) char(\"column_name\", size) tinytext(\"column_name\", size) mediumtext(\"column_name\", size) longtext(\"column_name\", size) text(\"column_name\") Numerical data Types tinyint(\"column_name\", size) smallint(\"column_name\", size) mediumint(\"column_name\", size) bigint(\"column_name\", size) int(\"column_name\", size) decimal(\"column_name\", value1, value2) Date and time Types date(\"column_name\") year(\"column_name\") time(\"column_name\") datetime(\"column_name\") timestamp(\"column_name\") Boolean Types boolean(\"column_name\") Attributes Types default(\"default_value\") unique() unsigned() incremet() notNull() primary() after(\"column_name\") first()","title":"Types of data"},{"location":"katrina-orm/","text":"Version Katrina ORM is currently at version 2.x . To read documentation for previous versions choose one of the links below. 1.x Getting Started Katrina ORM is a component that brings the object-oriented application development paradigm closer to the relational database paradigm. It helps to carry out common routines, such as the famous CRUD (create, read, edit and delete), in addition to having a data paging system. Katrina ORM uses the Active Record standard to manipulate the data in the database. Requirements PHP >= 8.3 PDO extension enabled Installation Katrina ORM is already installed by default in Solital. But if you are going to install in another project, use the command below to download via Composer. composer require solital/katrina Settings In Solital: # DATABASE CONFIG DB_DRIVE=your_drive DB_HOST=your_host DB_NAME=your_database_name DB_USER=your_user DB_PASS=your_password In another project: define('DB_CONFIG', [ 'DRIVE' => 'your_drive', 'HOST' => 'your_host', 'DBNAME' => 'your_database_name', 'USER' => 'your_user', 'PASS' => 'your_password' ]); For SQLite Some differences exist for connecting to an SQLite database. First, add an additional index called SQLITE_DIR in the DB_CONFIG constant. This constant must have the absolute path where the SQLite database file will be located. Then, assign the value sqlite in the index DRIVE . define('DB_CONFIG', [ 'DRIVE' => 'sqlite', 'DBNAME' => 'your_database_name.db', 'SQLITE_DIR' => '/path/to/file/' ]); In Solital: # DATABASE CONFIG DB_DRIVE=your_drive DB_HOST=your_host DB_NAME=your_database_name DB_USER=your_user DB_PASS=your_password SQLITE_DIR=/path/to/file/ Initial structure To initialize the Katrina ORM in your Model, just extend the Katrina class. <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { } Changing default fields By default, your class table name is the class name itself, and the primary key name is id . You can change these settings using the $table and $id properties. <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { /** * @var null|string */ protected ?string $table = \"tb_user\"; /** * @var null|string */ protected ?string $id = \"id_user\"; } Listing values from a table SELECT query To list all fields in the table, use all() as shown in the previous example. User::all(); FIND To list a single value, use find() method; User::find(2); Users::findFirst(); // Returns the first value in the table Or, use the select method: /** * Fetch all */ User::select()->get(); /** * Fetch only */ User::select()->where('id', 2)->getUnique(); /** * Fetch all with column name */ User::select(\"name\")->get(); If you need to raise an exception if no value is returned, use the findwithException method. User::findwithException(2); LATEST You can return the latest values from the database in descending order using the latest method: User::latest()->get(); By default, the latest method will sort using the created_at column. If this column does not exist in your table, you can pass the name of another column as a parameter. User::latest('users')->get(); WHERE The WHERE clause is used to filter records. It is used to extract only those records that fulfill a specified condition. /** * Katrina will look for a record that has `foo` in the table. */ User::select()->where(\"name\", \"foo\")->get(); /** * Katrina will look for a record whose age is greater than 10. */ User::select()->where(\"age\", 10, \">\")->get(); /** * Katrina will look for a record that is under the age of 10. */ User::select()->where(\"age\", 10, \"<\")->get(); To save time and avoid using the and method, you can pass an array as a parameter in the where method with multiple conditions. User::select()->where([ 'name', 'foo', 'age', 10 ])->get(); AND The AND operator displays a record if all the conditions separated by AND are TRUE . User::select()->where(\"brand\", 'visa')->and(\"cvv\", '502')->get(); OR The OR operator displays a record if any of the conditions separated by OR is TRUE . User::select()->where(\"brand\", 'visa')->or(\"cvv\", '502')->get(); LIKE Used in a WHERE clause to search for a specified pattern in a column. User::select()->where(\"name\")->like(\"%foo%\")->get(); BETWEEN Selects values within a given range. The values can be numbers, text, or dates. User::select()->where(\"age\")->between(10, 22)->get(); LIMIT Used to specify the number of records to return. User::select()->limit(0, 3)->get(); ORDER BY Used to sort the result-set in ascending or descending order. User::select()->order(\"name\")->get(); By default, the result will always return ascending. To return values descending, use false in the second parameter. User::select()->order(\"name\", false)->get(); GROUP BY The GROUP BY statement groups rows that have the same values into summary rows, like \"find the number of customers in each country\". The group by SQL command requires the use of a function. Use the group() method together with the Functions class (see here ). User::select(\"name, \" . Functions::count('*', 'qtd'))->group(\"name\")->get(); COUNT The count method returns the total number of values in a table. User::count(); If you want to specify the name of a column, use the first parameter. And to use the WHERE clause, use the second parameter. // `Email` column User::count(\"email\"); // `Email` column with WHERE clause User::count(\"email\", \"email='solital@gmail.com'\"); INNER JOIN query The innerJoin() method returns the values of two tables that have a foreign key. The first parameter represents the table containing the foreign key. The second parameter represents the id of the foreign key. User::select() ->innerJoin(\"table1\", \"id1\") ->innerJoin(\"table2\", \"id2\") ->get(); If you need to use the WHERE clause, use the where() method. User::select() ->innerJoin(\"table1\", \"id1\") ->innerJoin(\"table2\", \"id2\") ->where(\"phone\", 123123123) ->get(); NOTE: If you have two or more tables where the column names are the same, remember to specify the table names in the where() method: User::select() ->innerJoin(\"table1\", \"id1\") ->innerJoin(\"table2\", \"id2\") ->where(\"table1.phone\", 123123123) ->get(); SELECT inside SELECT Some SQL queries need to have multiple SELECTs, and sometimes those SELECTs are inside other SELECTs. If you need such a query, follow the example: $sql = User::select(\"name\")->where(\"name\", \"solital\")->rawQuery(); $result = User::select(\"name, age\")->where(\"name\", Functions::subquery($sql))->get(); var_dump($result); The rawQuery() function will return an SQL string (you can use a var_dump() to parse the returned string). Then, to use that SQL string inside another query, use the subquery() function. Creating and updating data INSERT query Katrina uses the ActiveRecord standard to insert and update database data. However, if you don't want to use the ActiveRecord pattern, you can use the insert() and update() methods. With ActiveRecord To insert data in the table, you must use the column name as a value. If your table has name , age and email columns, then the values should be used following that same sequence. Note the code below: $user = new User(); $user->name = \"Harvey Specter\"; $user->age = 40; $user->email = \"harvey@pearsonspecterlitt.com\"; $user->save(); With the insert method To save data, you must pass an array in which the keys will be the columns of the table. The values of these keys will be inserted into the database. User::insert([ 'name' => 'Harvey Specter', 'age' => 40, 'email' => 'harvey@pearsonspecterlitt.com' ]); If you want to retrieve the last ID entered, use the lastId() method. $res = User::insert([ 'name' => 'Harvey Specter', 'age' => 40, 'email' => 'harvey@pearsonspecterlitt.com' ])->lastId(); var_dump($res); UPDATE query With ActiveRecord The process for updating a record in the table is very similar to inserting a record. However, you need to specify the id of your table: $user = new User(); $user->id = 1; $user->name = \"Harvey Specter\"; $user->age = 42; $user->email = \"harvey@specterlitt.com\"; $user->save(); With the update method The process for updating a value in the database using the update method is similar to using the insert method. The difference is that you will use the where method to define the values that will be updated. And to save those changes, the saveUpdate method must be present. User::update([ 'name' => 'Harvey Specter', 'age' => 42, 'email' => 'harvey@specterlitt.com' ])->where('id', 1)->saveUpdate(); Deleting data To delete a record from the table, use the delete() method. User::delete('id', 2); If you want to delete a row that has a foreign key in another table, the $safe_mode parameter must be changed to false : User::delete('id', 2, false); Functions Katrina 2 supports SQL functions. You can use a function in an SQL query using the Function Method: use Katrina\\Functions\\Functions; User::select(\"name, \" . Functions::count('*', 'qtd'))->group(\"name\")->get(); When using a function, you can rename the table name when viewing the data using the $as parameter. Functions::count(as: 'qtd'); Functions::concat(as: 'result'); Functions::trim(as: 'string'); //... Below is a list of all the functions present in Katrina ORM: Aggregate Functions Date Functions Math Functions String Functions avg() now() abs() concat() count() curdate() round() ltrim() max() date() truncate() rtrim() min() hour() - trim() sum() day() - - groupConcat() month() - - - year() - - - datediff() - - - currentTimestamp() - - Custom functions If the function you want does not exist or has not yet been implemented in the Katrina ORM, you can use the custom() method. In the first parameter, you must enter the name of the SQL function. In the second parameter, the value of this function. And in the third parameter, you can rename the table when returning the data. Functions::custom('sum', '*', 'result'); Manipulating tables Create a new table The createTable() method starts opening the table. After inserting the fields and data types that the tables will have, use closeTable() to close the table. For a better understanding see the syntax below. User::createTable(\"your_table_name\") /* Fields and table type */ ->int(\"id_user\")->primary()->increment() ->varchar(\"name\", 20)->unique()->notNull()->default(\"specter\") ->int(\"age\", 3)->unsigned()->notNull() ->varchar(\"email\", 30)->default(\"harvey.specter@gmail.com\")->notNull() ->varchar(\"profession\", 40) ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") ->createdUpdatedAt() /* Close the command to create the table */ ->closeTable(); For POSTGRESQL Postgresql doesn't natively support the AUTO_INCREMENT command. An alternative is to use the SERIAL command. So, if you are going to create a table using Postgresql as a database, use the serial() method. User::createTable(\"your_table_name\") ->serial('id_user')->primary() # ... UUIDs On certain occasions it is necessary to generate a unique identifier for each record. These identifiers are called UUID (universally unique identifiers). To create a field in a table that will receive a UUID, use the uuid() method. This method will generate a field of binary type. User::createTable(\"your_table_name\") ->uuid('id')->primary() # ... When creating a field in the table that will receive a UUID and be defined as the primary key, you must enable increment in the class. <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { protected ?bool $uuid_increment = true; } If you use the insert() method instead of the standard Active Record to save the data in the table, you must pass the UUID manually. To do this, use the uuidToBin() method. use Katrina\\Functions\\Functions; User::insert([ 'id' => Functions::uuidToBin(), 'name' => 'Harvey Specter', 'age' => 40, 'email' => 'harvey@pearsonspecterlitt.com' ]); When using the uuidToBin method, the UUID is converted to binary. When returning data and converting back to UUID, use the binToUuid() method. foreach(Users::all() as $user) { echo Functions::binToUuid($user->id) . PHP_EOL; } Remember that Katrina ORM uses UUID in version 4 . Timestamps If you want to change the name of the created_at and updated_at columns, use the properties below: <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { protected string $created_at = 'created_date'; protected string $updated_at = 'updated_date'; } You can also rename columns when creating a table in the database using the createdUpdatedAt method. // ... ->createdUpdatedAt('created_date', 'updated_date') // ... List tables To have a list of all the tables in your database, use the listTables() method. User::listTables(); List columns To list the columns of a table, use the describeTable() method. User::describeTable(); Drop table If it is necessary to drop the table, use the dropTable() method. User::dropTable(); Alter table The alter() method performs the procedures of adding, changing and deleting a field from the database table. Add new field Use add() method together with the data type to add a new field. User::alter()->varchar(\"username\", 20)->add(); Drop column Use the drop() method to delete a column from the table. User::alter()->drop(\"username\"); Modify column Use the modify SQL with the modify() method. User::alter()->varchar(\"name\", 100)->modify(); Rename table Use the rename() method to rename a database table. User::alter()->rename(\"new_table_name\"); Adding foreign key To add a foreign key to an already created table, use the constraint() method to add a constraint; foreign() to inform the column and references() to refer to the table. User::alter()->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\"); Truncate table To use the sql truncate command, use the truncate() method. User::truncate(); By default, the database checks the table's foreign key and locks the truncate command. To disable foreign key verification, enter true as a parameter. User::truncate(true); Procedure To call a database procedure, use the call() method. User::call('procedure_name'); To use procedure parameters, pass the values in array format. User::call('procedure_name' , ['param_1, param_2, param_3']); Transactions Transactions are typically implemented by \"saving-up\" your batch of changes to be applied all at once; this has the nice side effect of drastically improving the efficiency of those updates. In other words, transactions can make your scripts faster and potentially more robust (you still need to use them correctly to reap that benefit). public static function transaction() { try { $pdo = Connection::getInstance(); $pdo->beginTransaction(); // code... $pdo->commit(); } catch (\\PDOException $e) { $pdo->rollback(); echo $e->getMessage(); } } // Using transactions User::transaction(); Pagination The pagination() method creates a system for paging results. To initialize, the first parameter must be the table you want to use to start paging. The second parameter will list the amount of values that will be returned from the table as shown in the example below. $users = new User(); $values = $users->pagination('your_table', 3); To retrieve the table values from the database, you can use the getRows() method. And to use pagination, use the getArrows() method. /** Returns table data */ $values->getRows(); /** Returns commands to advance or return */ $values->getArrows() To use pagination with relationship in another table, in the third parameter pass an array containing the name of the table that has a relationship with the current table, the column name of the current table that has the foreign key and the column name of the primary key of the another table. $users = new User(); $values = $users->pagination( \"your_table\", 3, [\"foreign_table\", \"column_foreign_key\", \"column_primary_key\"] ); Pagination with other table (INNER JOIN) If you want to use pagination with a table that has a foreign key, pass an array in the third parameter. In the first index, insert the name of the table that is linked to the current table, in the second index the name of the column that contains the foreign key and in the third index the column name of the primary key of the table that references the current table $users = new User(); $values = $users->pagination( \"your_table\", 3, [\"foreign_table\", \"column_foreign_key\", \"column_primary_key\"], \"status=true\" ); WHERE clause To use the WHERE clause, use the fourth parameter as shown below. $users = new User(); $values = $users->pagination(\"your_table\", 3, null, \"status=true\"); Wolf Template Data pagination is widely used in project templates. You can integrate pagination into Wolf Template as follows: $users = new User(); $values = $users->pagination(\"your_table\", 3); return view(\"home\", [ \"values\" => $values ]); In your template, retrieve the data like this: <table> <thead> <tr> <th>Name</th> <th>Age</th> <th>Gender</th> </tr> </thead> <tbody> {% foreach ($values->getRows() as $result): %} <tr> <td>{{ $result['name'] }}</td> <td>{{ $result['age'] }}</td> <td>{{ $result['gender'] }}</td> </tr> {% endforeach; %} </tbody> </table> {{ $values->getArrows(); }} The result will be as follows: Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female << 1 2 3 >> To change the arrows ( << and >> ), use the parameters of the getArrows() method. The result will be: {{ $values->getArrows('First', 'Last'); }} Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female First 2 3 Last Custom Pagination The pagination() method uses a basic SELECT statement. If you need to use a much more complex SELECT, consider using the customPagination() method. $user = new User(); $values = $user->customPagination( \"SELECT created_at, order_status, idSession, SUM(idOrder) AS idOrder FROM `tb_order` GROUP BY created_at, order_status, idSession\", 3 ); Customizing arrows CSS You can customize the look of the arrows through the classes pagination_first_item , pagination_atual_item , pagination_others_itens and pagination_last_item . Below is a customization to serve as an example: .pagination_atual_item { background-color: #B5B5B5; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item, .pagination_others_itens, .pagination_last_item { background-color: #4682B4; color: #FFF; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; text-decoration: none; } .pagination_first_item:hover, .pagination_others_itens:hover, .pagination_last_item:hover { background-color: #0071E3; color: #FFF !important; transition: 0.2s; } Cache To enable Katrina ORM caching in Solital, you must change the cache_database variable to true in the cache.yaml file. # Enable cache on Katrina ORM cache_database: true To configure caching in Solital, see the documentation here . If you are NOT using Katrina ORM together with Solital, you must configure the constants manually: define('DB_CACHE', [ 'CACHE_TYPE' => 'memcached', 'CACHE_HOST' => '127.0.0.1', 'CACHE_PORT' => 11211, 'CACHE_TTL' => 600 ]); Katrina ORM supports the following drivers Memcached Memcache APCu Yac In your Model, you will need to enable caching. To do this, add the following property: <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { /** * @var bool|null */ protected ?bool $cache = true; } Multiple connections In specific cases it is necessary to use two different databases. Katrina ORM supports you to use a second database. To do this, you must add the following variables to your .env file: DB_HOST_SECONDARY=localhost DB_NAME_SECONDARY=second_database DB_USER_SECONDARY=root DB_PASS_SECONDARY=\"\" SQLITE_DIR_SECONDARY=\"\" If you are NOT using Solital, you must create the following constants: define('DB_CONFIG_SECONDARY', [ 'HOST' => 'localhost', 'DBNAME' => 'second_database', 'USER' => 'root', 'PASS' => '', 'SQLITE_DIR' => '' ]); So, to use the second connection to the other database, use the connection method: # Main database User::select()->get(); # Second database User::connection('pgsql')::select()->get(); Types of data Below is listed the attributes and data supported by Katrina ORM: String data Numerical data Date and time varchar() tinyint() date() char() smallint() year() tinytext() mediumint() time() mediumtext() bigint() datetime() longtext() int() timestamp() text() decimal() - Attributes Boolean boolean() default() unique() - unsigned() - incremet() (MYSQL) - notNull() - primary() - after() - first() - serial() (POSTGRESQL) -","title":"Katrina ORM"},{"location":"katrina-orm/#version","text":"Katrina ORM is currently at version 2.x . To read documentation for previous versions choose one of the links below. 1.x","title":"Version"},{"location":"katrina-orm/#getting-started","text":"Katrina ORM is a component that brings the object-oriented application development paradigm closer to the relational database paradigm. It helps to carry out common routines, such as the famous CRUD (create, read, edit and delete), in addition to having a data paging system. Katrina ORM uses the Active Record standard to manipulate the data in the database.","title":"Getting Started"},{"location":"katrina-orm/#requirements","text":"PHP >= 8.3 PDO extension enabled","title":"Requirements"},{"location":"katrina-orm/#installation","text":"Katrina ORM is already installed by default in Solital. But if you are going to install in another project, use the command below to download via Composer. composer require solital/katrina","title":"Installation"},{"location":"katrina-orm/#settings","text":"In Solital: # DATABASE CONFIG DB_DRIVE=your_drive DB_HOST=your_host DB_NAME=your_database_name DB_USER=your_user DB_PASS=your_password In another project: define('DB_CONFIG', [ 'DRIVE' => 'your_drive', 'HOST' => 'your_host', 'DBNAME' => 'your_database_name', 'USER' => 'your_user', 'PASS' => 'your_password' ]);","title":"Settings"},{"location":"katrina-orm/#for-sqlite","text":"Some differences exist for connecting to an SQLite database. First, add an additional index called SQLITE_DIR in the DB_CONFIG constant. This constant must have the absolute path where the SQLite database file will be located. Then, assign the value sqlite in the index DRIVE . define('DB_CONFIG', [ 'DRIVE' => 'sqlite', 'DBNAME' => 'your_database_name.db', 'SQLITE_DIR' => '/path/to/file/' ]); In Solital: # DATABASE CONFIG DB_DRIVE=your_drive DB_HOST=your_host DB_NAME=your_database_name DB_USER=your_user DB_PASS=your_password SQLITE_DIR=/path/to/file/","title":"For SQLite"},{"location":"katrina-orm/#initial-structure","text":"To initialize the Katrina ORM in your Model, just extend the Katrina class. <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { }","title":"Initial structure"},{"location":"katrina-orm/#changing-default-fields","text":"By default, your class table name is the class name itself, and the primary key name is id . You can change these settings using the $table and $id properties. <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { /** * @var null|string */ protected ?string $table = \"tb_user\"; /** * @var null|string */ protected ?string $id = \"id_user\"; }","title":"Changing default fields"},{"location":"katrina-orm/#listing-values-from-a-table","text":"","title":"Listing values from a table"},{"location":"katrina-orm/#select-query","text":"To list all fields in the table, use all() as shown in the previous example. User::all(); FIND To list a single value, use find() method; User::find(2); Users::findFirst(); // Returns the first value in the table Or, use the select method: /** * Fetch all */ User::select()->get(); /** * Fetch only */ User::select()->where('id', 2)->getUnique(); /** * Fetch all with column name */ User::select(\"name\")->get(); If you need to raise an exception if no value is returned, use the findwithException method. User::findwithException(2); LATEST You can return the latest values from the database in descending order using the latest method: User::latest()->get(); By default, the latest method will sort using the created_at column. If this column does not exist in your table, you can pass the name of another column as a parameter. User::latest('users')->get(); WHERE The WHERE clause is used to filter records. It is used to extract only those records that fulfill a specified condition. /** * Katrina will look for a record that has `foo` in the table. */ User::select()->where(\"name\", \"foo\")->get(); /** * Katrina will look for a record whose age is greater than 10. */ User::select()->where(\"age\", 10, \">\")->get(); /** * Katrina will look for a record that is under the age of 10. */ User::select()->where(\"age\", 10, \"<\")->get(); To save time and avoid using the and method, you can pass an array as a parameter in the where method with multiple conditions. User::select()->where([ 'name', 'foo', 'age', 10 ])->get(); AND The AND operator displays a record if all the conditions separated by AND are TRUE . User::select()->where(\"brand\", 'visa')->and(\"cvv\", '502')->get(); OR The OR operator displays a record if any of the conditions separated by OR is TRUE . User::select()->where(\"brand\", 'visa')->or(\"cvv\", '502')->get(); LIKE Used in a WHERE clause to search for a specified pattern in a column. User::select()->where(\"name\")->like(\"%foo%\")->get(); BETWEEN Selects values within a given range. The values can be numbers, text, or dates. User::select()->where(\"age\")->between(10, 22)->get(); LIMIT Used to specify the number of records to return. User::select()->limit(0, 3)->get(); ORDER BY Used to sort the result-set in ascending or descending order. User::select()->order(\"name\")->get(); By default, the result will always return ascending. To return values descending, use false in the second parameter. User::select()->order(\"name\", false)->get(); GROUP BY The GROUP BY statement groups rows that have the same values into summary rows, like \"find the number of customers in each country\". The group by SQL command requires the use of a function. Use the group() method together with the Functions class (see here ). User::select(\"name, \" . Functions::count('*', 'qtd'))->group(\"name\")->get(); COUNT The count method returns the total number of values in a table. User::count(); If you want to specify the name of a column, use the first parameter. And to use the WHERE clause, use the second parameter. // `Email` column User::count(\"email\"); // `Email` column with WHERE clause User::count(\"email\", \"email='solital@gmail.com'\");","title":"SELECT query"},{"location":"katrina-orm/#inner-join-query","text":"The innerJoin() method returns the values of two tables that have a foreign key. The first parameter represents the table containing the foreign key. The second parameter represents the id of the foreign key. User::select() ->innerJoin(\"table1\", \"id1\") ->innerJoin(\"table2\", \"id2\") ->get(); If you need to use the WHERE clause, use the where() method. User::select() ->innerJoin(\"table1\", \"id1\") ->innerJoin(\"table2\", \"id2\") ->where(\"phone\", 123123123) ->get(); NOTE: If you have two or more tables where the column names are the same, remember to specify the table names in the where() method: User::select() ->innerJoin(\"table1\", \"id1\") ->innerJoin(\"table2\", \"id2\") ->where(\"table1.phone\", 123123123) ->get();","title":"INNER JOIN query"},{"location":"katrina-orm/#select-inside-select","text":"Some SQL queries need to have multiple SELECTs, and sometimes those SELECTs are inside other SELECTs. If you need such a query, follow the example: $sql = User::select(\"name\")->where(\"name\", \"solital\")->rawQuery(); $result = User::select(\"name, age\")->where(\"name\", Functions::subquery($sql))->get(); var_dump($result); The rawQuery() function will return an SQL string (you can use a var_dump() to parse the returned string). Then, to use that SQL string inside another query, use the subquery() function.","title":"SELECT inside SELECT"},{"location":"katrina-orm/#creating-and-updating-data","text":"","title":"Creating and updating data"},{"location":"katrina-orm/#insert-query","text":"Katrina uses the ActiveRecord standard to insert and update database data. However, if you don't want to use the ActiveRecord pattern, you can use the insert() and update() methods. With ActiveRecord To insert data in the table, you must use the column name as a value. If your table has name , age and email columns, then the values should be used following that same sequence. Note the code below: $user = new User(); $user->name = \"Harvey Specter\"; $user->age = 40; $user->email = \"harvey@pearsonspecterlitt.com\"; $user->save(); With the insert method To save data, you must pass an array in which the keys will be the columns of the table. The values of these keys will be inserted into the database. User::insert([ 'name' => 'Harvey Specter', 'age' => 40, 'email' => 'harvey@pearsonspecterlitt.com' ]); If you want to retrieve the last ID entered, use the lastId() method. $res = User::insert([ 'name' => 'Harvey Specter', 'age' => 40, 'email' => 'harvey@pearsonspecterlitt.com' ])->lastId(); var_dump($res);","title":"INSERT query"},{"location":"katrina-orm/#update-query","text":"With ActiveRecord The process for updating a record in the table is very similar to inserting a record. However, you need to specify the id of your table: $user = new User(); $user->id = 1; $user->name = \"Harvey Specter\"; $user->age = 42; $user->email = \"harvey@specterlitt.com\"; $user->save(); With the update method The process for updating a value in the database using the update method is similar to using the insert method. The difference is that you will use the where method to define the values that will be updated. And to save those changes, the saveUpdate method must be present. User::update([ 'name' => 'Harvey Specter', 'age' => 42, 'email' => 'harvey@specterlitt.com' ])->where('id', 1)->saveUpdate();","title":"UPDATE query"},{"location":"katrina-orm/#deleting-data","text":"To delete a record from the table, use the delete() method. User::delete('id', 2); If you want to delete a row that has a foreign key in another table, the $safe_mode parameter must be changed to false : User::delete('id', 2, false);","title":"Deleting data"},{"location":"katrina-orm/#functions","text":"Katrina 2 supports SQL functions. You can use a function in an SQL query using the Function Method: use Katrina\\Functions\\Functions; User::select(\"name, \" . Functions::count('*', 'qtd'))->group(\"name\")->get(); When using a function, you can rename the table name when viewing the data using the $as parameter. Functions::count(as: 'qtd'); Functions::concat(as: 'result'); Functions::trim(as: 'string'); //... Below is a list of all the functions present in Katrina ORM: Aggregate Functions Date Functions Math Functions String Functions avg() now() abs() concat() count() curdate() round() ltrim() max() date() truncate() rtrim() min() hour() - trim() sum() day() - - groupConcat() month() - - - year() - - - datediff() - - - currentTimestamp() - -","title":"Functions"},{"location":"katrina-orm/#custom-functions","text":"If the function you want does not exist or has not yet been implemented in the Katrina ORM, you can use the custom() method. In the first parameter, you must enter the name of the SQL function. In the second parameter, the value of this function. And in the third parameter, you can rename the table when returning the data. Functions::custom('sum', '*', 'result');","title":"Custom functions"},{"location":"katrina-orm/#manipulating-tables","text":"","title":"Manipulating tables"},{"location":"katrina-orm/#create-a-new-table","text":"The createTable() method starts opening the table. After inserting the fields and data types that the tables will have, use closeTable() to close the table. For a better understanding see the syntax below. User::createTable(\"your_table_name\") /* Fields and table type */ ->int(\"id_user\")->primary()->increment() ->varchar(\"name\", 20)->unique()->notNull()->default(\"specter\") ->int(\"age\", 3)->unsigned()->notNull() ->varchar(\"email\", 30)->default(\"harvey.specter@gmail.com\")->notNull() ->varchar(\"profession\", 40) ->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\") ->createdUpdatedAt() /* Close the command to create the table */ ->closeTable(); For POSTGRESQL Postgresql doesn't natively support the AUTO_INCREMENT command. An alternative is to use the SERIAL command. So, if you are going to create a table using Postgresql as a database, use the serial() method. User::createTable(\"your_table_name\") ->serial('id_user')->primary() # ...","title":"Create a new table"},{"location":"katrina-orm/#uuids","text":"On certain occasions it is necessary to generate a unique identifier for each record. These identifiers are called UUID (universally unique identifiers). To create a field in a table that will receive a UUID, use the uuid() method. This method will generate a field of binary type. User::createTable(\"your_table_name\") ->uuid('id')->primary() # ... When creating a field in the table that will receive a UUID and be defined as the primary key, you must enable increment in the class. <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { protected ?bool $uuid_increment = true; } If you use the insert() method instead of the standard Active Record to save the data in the table, you must pass the UUID manually. To do this, use the uuidToBin() method. use Katrina\\Functions\\Functions; User::insert([ 'id' => Functions::uuidToBin(), 'name' => 'Harvey Specter', 'age' => 40, 'email' => 'harvey@pearsonspecterlitt.com' ]); When using the uuidToBin method, the UUID is converted to binary. When returning data and converting back to UUID, use the binToUuid() method. foreach(Users::all() as $user) { echo Functions::binToUuid($user->id) . PHP_EOL; } Remember that Katrina ORM uses UUID in version 4 .","title":"UUIDs"},{"location":"katrina-orm/#timestamps","text":"If you want to change the name of the created_at and updated_at columns, use the properties below: <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { protected string $created_at = 'created_date'; protected string $updated_at = 'updated_date'; } You can also rename columns when creating a table in the database using the createdUpdatedAt method. // ... ->createdUpdatedAt('created_date', 'updated_date') // ...","title":"Timestamps"},{"location":"katrina-orm/#list-tables","text":"To have a list of all the tables in your database, use the listTables() method. User::listTables();","title":"List tables"},{"location":"katrina-orm/#list-columns","text":"To list the columns of a table, use the describeTable() method. User::describeTable();","title":"List columns"},{"location":"katrina-orm/#drop-table","text":"If it is necessary to drop the table, use the dropTable() method. User::dropTable();","title":"Drop table"},{"location":"katrina-orm/#alter-table","text":"The alter() method performs the procedures of adding, changing and deleting a field from the database table. Add new field Use add() method together with the data type to add a new field. User::alter()->varchar(\"username\", 20)->add(); Drop column Use the drop() method to delete a column from the table. User::alter()->drop(\"username\"); Modify column Use the modify SQL with the modify() method. User::alter()->varchar(\"name\", 100)->modify(); Rename table Use the rename() method to rename a database table. User::alter()->rename(\"new_table_name\");","title":"Alter table"},{"location":"katrina-orm/#adding-foreign-key","text":"To add a foreign key to an already created table, use the constraint() method to add a constraint; foreign() to inform the column and references() to refer to the table. User::alter()->constraint(\"dev_cons_fk\")->foreign(\"type\")->references(\"dev\", \"iddev\");","title":"Adding foreign key"},{"location":"katrina-orm/#truncate-table","text":"To use the sql truncate command, use the truncate() method. User::truncate(); By default, the database checks the table's foreign key and locks the truncate command. To disable foreign key verification, enter true as a parameter. User::truncate(true);","title":"Truncate table"},{"location":"katrina-orm/#procedure","text":"To call a database procedure, use the call() method. User::call('procedure_name'); To use procedure parameters, pass the values in array format. User::call('procedure_name' , ['param_1, param_2, param_3']);","title":"Procedure"},{"location":"katrina-orm/#transactions","text":"Transactions are typically implemented by \"saving-up\" your batch of changes to be applied all at once; this has the nice side effect of drastically improving the efficiency of those updates. In other words, transactions can make your scripts faster and potentially more robust (you still need to use them correctly to reap that benefit). public static function transaction() { try { $pdo = Connection::getInstance(); $pdo->beginTransaction(); // code... $pdo->commit(); } catch (\\PDOException $e) { $pdo->rollback(); echo $e->getMessage(); } } // Using transactions User::transaction();","title":"Transactions"},{"location":"katrina-orm/#pagination","text":"The pagination() method creates a system for paging results. To initialize, the first parameter must be the table you want to use to start paging. The second parameter will list the amount of values that will be returned from the table as shown in the example below. $users = new User(); $values = $users->pagination('your_table', 3); To retrieve the table values from the database, you can use the getRows() method. And to use pagination, use the getArrows() method. /** Returns table data */ $values->getRows(); /** Returns commands to advance or return */ $values->getArrows() To use pagination with relationship in another table, in the third parameter pass an array containing the name of the table that has a relationship with the current table, the column name of the current table that has the foreign key and the column name of the primary key of the another table. $users = new User(); $values = $users->pagination( \"your_table\", 3, [\"foreign_table\", \"column_foreign_key\", \"column_primary_key\"] );","title":"Pagination"},{"location":"katrina-orm/#pagination-with-other-table-inner-join","text":"If you want to use pagination with a table that has a foreign key, pass an array in the third parameter. In the first index, insert the name of the table that is linked to the current table, in the second index the name of the column that contains the foreign key and in the third index the column name of the primary key of the table that references the current table $users = new User(); $values = $users->pagination( \"your_table\", 3, [\"foreign_table\", \"column_foreign_key\", \"column_primary_key\"], \"status=true\" );","title":"Pagination with other table (INNER JOIN)"},{"location":"katrina-orm/#where-clause","text":"To use the WHERE clause, use the fourth parameter as shown below. $users = new User(); $values = $users->pagination(\"your_table\", 3, null, \"status=true\");","title":"WHERE clause"},{"location":"katrina-orm/#wolf-template","text":"Data pagination is widely used in project templates. You can integrate pagination into Wolf Template as follows: $users = new User(); $values = $users->pagination(\"your_table\", 3); return view(\"home\", [ \"values\" => $values ]); In your template, retrieve the data like this: <table> <thead> <tr> <th>Name</th> <th>Age</th> <th>Gender</th> </tr> </thead> <tbody> {% foreach ($values->getRows() as $result): %} <tr> <td>{{ $result['name'] }}</td> <td>{{ $result['age'] }}</td> <td>{{ $result['gender'] }}</td> </tr> {% endforeach; %} </tbody> </table> {{ $values->getArrows(); }} The result will be as follows: Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female << 1 2 3 >> To change the arrows ( << and >> ), use the parameters of the getArrows() method. The result will be: {{ $values->getArrows('First', 'Last'); }} Name Age Gender Sam 47 Male Dean 49 Male Marry 52 Female First 2 3 Last","title":"Wolf Template"},{"location":"katrina-orm/#custom-pagination","text":"The pagination() method uses a basic SELECT statement. If you need to use a much more complex SELECT, consider using the customPagination() method. $user = new User(); $values = $user->customPagination( \"SELECT created_at, order_status, idSession, SUM(idOrder) AS idOrder FROM `tb_order` GROUP BY created_at, order_status, idSession\", 3 );","title":"Custom Pagination"},{"location":"katrina-orm/#customizing-arrows-css","text":"You can customize the look of the arrows through the classes pagination_first_item , pagination_atual_item , pagination_others_itens and pagination_last_item . Below is a customization to serve as an example: .pagination_atual_item { background-color: #B5B5B5; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; } .pagination_first_item, .pagination_others_itens, .pagination_last_item { background-color: #4682B4; color: #FFF; padding: 10px; margin: 5px; border-radius: 5px; margin-top: 30px; transition: 0.2s; text-decoration: none; } .pagination_first_item:hover, .pagination_others_itens:hover, .pagination_last_item:hover { background-color: #0071E3; color: #FFF !important; transition: 0.2s; }","title":"Customizing arrows CSS"},{"location":"katrina-orm/#cache","text":"To enable Katrina ORM caching in Solital, you must change the cache_database variable to true in the cache.yaml file. # Enable cache on Katrina ORM cache_database: true To configure caching in Solital, see the documentation here . If you are NOT using Katrina ORM together with Solital, you must configure the constants manually: define('DB_CACHE', [ 'CACHE_TYPE' => 'memcached', 'CACHE_HOST' => '127.0.0.1', 'CACHE_PORT' => 11211, 'CACHE_TTL' => 600 ]); Katrina ORM supports the following drivers Memcached Memcache APCu Yac In your Model, you will need to enable caching. To do this, add the following property: <?php namespace Solital\\Components\\Model; use Katrina\\Katrina; class User extends Katrina { /** * @var bool|null */ protected ?bool $cache = true; }","title":"Cache"},{"location":"katrina-orm/#multiple-connections","text":"In specific cases it is necessary to use two different databases. Katrina ORM supports you to use a second database. To do this, you must add the following variables to your .env file: DB_HOST_SECONDARY=localhost DB_NAME_SECONDARY=second_database DB_USER_SECONDARY=root DB_PASS_SECONDARY=\"\" SQLITE_DIR_SECONDARY=\"\" If you are NOT using Solital, you must create the following constants: define('DB_CONFIG_SECONDARY', [ 'HOST' => 'localhost', 'DBNAME' => 'second_database', 'USER' => 'root', 'PASS' => '', 'SQLITE_DIR' => '' ]); So, to use the second connection to the other database, use the connection method: # Main database User::select()->get(); # Second database User::connection('pgsql')::select()->get();","title":"Multiple connections"},{"location":"katrina-orm/#types-of-data","text":"Below is listed the attributes and data supported by Katrina ORM: String data Numerical data Date and time varchar() tinyint() date() char() smallint() year() tinytext() mediumint() time() mediumtext() bigint() datetime() longtext() int() timestamp() text() decimal() - Attributes Boolean boolean() default() unique() - unsigned() - incremet() (MYSQL) - notNull() - primary() - after() - first() - serial() (POSTGRESQL) -","title":"Types of data"},{"location":"logger/","text":"First, every Logger has a channel , which is a name that will be associated with each entry of the logger log, and each part of the application can have a logger with a different channel to better differentiate them, facilitating the filtering of information, To the Logger must be added one or more handlers that are components that record the logs in certain ways, like the classic files or sockets and databases for example. Another important concept in the use of logs is the level of the log record, not all information has the same \u201cimportance\u201d in the log, or the same urgency to be dealt with, so entries in a log are categorized by levels: DEBUG: Debug information. INFO: Interesting events. For example: a user performed SQL login or logs. NOTICE: Normal but significant events. WARNING: Exceptional occurrences, but not errors. For example: Use of deprecated APIs, inappropriate use of an API. In general things that are not wrong but need attention. ERROR: Runtime errors that do not require immediate action, but must be logged and monitored. CRITICAL: Critical conditions. For example: An application component is not available, an unexpected exception has occurred. ALERT: Immediate action must be taken. Example: System crashed, database is unavailable, etc. It should trigger an alert for the person in charge to take action as soon as possible. EMERGENCY: Emergency: The system is unusable. Usage Solital uses the monolog library to make use of logs. First, you need to enable logging in the logger.yaml file. Change the enable_logs variable to true . enable_logs: true To use the log, use the Logger::channel() method, passing the channel to be used as a parameter. Logger::channel('single')->error('My info message'); The channel that will be used when calling this method will be defined within the logger.yaml file. channel: single: type: stream path: log/logs.log level: debug main: type: syslog path: log/syslogs.log level: error By default, Solital uses the single channel. Therefore, do not remove this channel. Logger file Taking a look at the logger.yaml file, we noticed some variables: # Channel name single: # Log type type: stream # Log path path: log/logs.log # Log debug level: debug Processor Processors are associated with log entry classes. They will inject information into entries' context. You can use monolog processors. To use monolog processors , add a variable called processor in your configuration file. mail: type: mail path: email@email.com level: debug processor: [IntrospectionProcessor, MemoryUsageProcessor, WebProcessor] Customer handlers By default, Solital offers two Monolog handlers. If you want to add one or several custom handlers, you can use the customHandler() method. $handler[] = new StreamHandler('path/to/log.log', Level::Debug); Logger::customHandler('custom-channel', $handler)->debug('My info message'); If necessary, you can use the third parameter to use a processor. $handler[] = new StreamHandler('path/to/log.log', Level::Debug); $processor = new IntrospectionProcessor(); Logger::customHandler('custom-channel', $handler, $processor)->debug('My info message');","title":"Logger"},{"location":"logger/#usage","text":"Solital uses the monolog library to make use of logs. First, you need to enable logging in the logger.yaml file. Change the enable_logs variable to true . enable_logs: true To use the log, use the Logger::channel() method, passing the channel to be used as a parameter. Logger::channel('single')->error('My info message'); The channel that will be used when calling this method will be defined within the logger.yaml file. channel: single: type: stream path: log/logs.log level: debug main: type: syslog path: log/syslogs.log level: error By default, Solital uses the single channel. Therefore, do not remove this channel.","title":"Usage"},{"location":"logger/#logger-file","text":"Taking a look at the logger.yaml file, we noticed some variables: # Channel name single: # Log type type: stream # Log path path: log/logs.log # Log debug level: debug","title":"Logger file"},{"location":"logger/#processor","text":"Processors are associated with log entry classes. They will inject information into entries' context. You can use monolog processors. To use monolog processors , add a variable called processor in your configuration file. mail: type: mail path: email@email.com level: debug processor: [IntrospectionProcessor, MemoryUsageProcessor, WebProcessor]","title":"Processor"},{"location":"logger/#customer-handlers","text":"By default, Solital offers two Monolog handlers. If you want to add one or several custom handlers, you can use the customHandler() method. $handler[] = new StreamHandler('path/to/log.log', Level::Debug); Logger::customHandler('custom-channel', $handler)->debug('My info message'); If necessary, you can use the third parameter to use a processor. $handler[] = new StreamHandler('path/to/log.log', Level::Debug); $processor = new IntrospectionProcessor(); Logger::customHandler('custom-channel', $handler, $processor)->debug('My info message');","title":"Customer handlers"},{"location":"mailer-component/","text":"Mailer is Solital's default class for sending emails. The Mailer class uses the PHPMailer component to send emails. In addition, you can create email queues asynchronously, and also use another email account to test your project. To use this component, first edit the .env file. MAIL_DEBUG=0 MAIL_HOST=mail.yourhost.com MAIL_USER=email@your_email.com MAIL_PASS=your_password MAIL_SECURITY=tls MAIL_PORT=587 The code below shows the use of the Mailer class with container helper: $mailer = container('solital-mailer'); // Add sender and recipient information $mailer->add('sender_email@gmail.com', 'Sender name', 'recipient_email@gmail.com', 'Recipient name'); // Send a file by email (OPTIONAL) $mailer->attach('image.png', 'image_name'); // Send an image in HTML (OPTIONAL) $mailer->embeddedImage('image.png', 'image', 'image'); // Send email $mailer->send('E-mail test', '<h1>E-mail test</h1><p>cid:image</p>'); // If there is an error if ($mailer->error()) { echo $mailer->error(); } If you prefer, you can create an instance of the mailer class or using the container through the Application class. $mailer = new Solital\\Core\\Resource\\Mail\\Mailer(); $mailer = Application::provider('solital-mailer'); E-mail queues To create an email queue, first check your database is connected. All emails will be saved in a database to be sent later. The process is similar to sending a standard email, the difference is the use of the queue() method. // Add sender and recipient information $mailer->add('sender_email@gmail.com', 'Sender name', 'recipient_email@gmail.com', 'Recipient name'); // Send email $mailer->queue('E-mail test', '<h1>E-mail test</h1>'); After the emails are saved in the database, use the sendQueue() method to send all the emails. You can set a delay in seconds for sending the emails (default is 5 seconds). $mailer = new Mailer(); $mailer->sendQueue(); // Delay 10 seconds $mailer->sendQueue(10); Test email If you want to perform tests using another email, you can change the settings using the mail.yaml file. When enabling this option, Solital will use the settings from the mail.yaml file instead of the settings from the .env file. Enable email testing by changing the mail_test_enable variable to true and changing the settings in this file. To enable exceptions when there is an error when sending the email, change the mail_exceptions variable to true . # Enable exception in Mailer class # Values: true, false mail_exceptions: true # Enable mail test in localhost mail_test: mail_test_enable: false mail_debug: 0 mail_host: mail_user: mail_pass: mail_security: tls mail_port: 587","title":"Mailer"},{"location":"mailer-component/#e-mail-queues","text":"To create an email queue, first check your database is connected. All emails will be saved in a database to be sent later. The process is similar to sending a standard email, the difference is the use of the queue() method. // Add sender and recipient information $mailer->add('sender_email@gmail.com', 'Sender name', 'recipient_email@gmail.com', 'Recipient name'); // Send email $mailer->queue('E-mail test', '<h1>E-mail test</h1>'); After the emails are saved in the database, use the sendQueue() method to send all the emails. You can set a delay in seconds for sending the emails (default is 5 seconds). $mailer = new Mailer(); $mailer->sendQueue(); // Delay 10 seconds $mailer->sendQueue(10);","title":"E-mail queues"},{"location":"mailer-component/#test-email","text":"If you want to perform tests using another email, you can change the settings using the mail.yaml file. When enabling this option, Solital will use the settings from the mail.yaml file instead of the settings from the .env file. Enable email testing by changing the mail_test_enable variable to true and changing the settings in this file. To enable exceptions when there is an error when sending the email, change the mail_exceptions variable to true . # Enable exception in Mailer class # Values: true, false mail_exceptions: true # Enable mail test in localhost mail_test: mail_test_enable: false mail_debug: 0 mail_host: mail_user: mail_pass: mail_security: tls mail_port: 587","title":"Test email"},{"location":"mask/","text":"StrMask is a Solital class to make masks for a string In your PHP application, use the static method apply of Mask: use Solital\\Core\\Resource\\Str\\StrMask; $output = StrMask::apply($inputValue, $maskExpression, $config); Arguments $inputValue : string - The input value to apply mask. $maskExpression : string - The mask expression for $output. $config : array - The configuration for operation Patterns The patterns are used to filter $inputValue: Code Meaning **0** digits (like 0 to 9 numbers) **9** digits (like 0 to 9 numbers), but optional **A** letters (uppercase or lowercase) and digits **S** only letters (uppercase or lowercase) Special chars Special chars are used in mask expressions to format output: / ( ) . : - space + , @ Thousand separator You can format a number in thousand separator and control precision. The mask keys are: separator : Input 1234.56 is ouputed as 1 234.56 dot_separator : Input 1234,56 is ouputed as 1.234,56 comma_separator : Input 1234.56 is ouputed as 1,234.56 To manage precision, keys shall be suffixed by .{Number} . Example: separator.1 : Input 1234.56743 is ouputed as 1 234.5 dot_separator.4 : Input 1234,56743 is ouputed as 1.234,5674 comma_separator.2 : Input 1234.56743 is ouputed as 1,234.56 Time validation You can format a time according limit: Mask Meaning **H** Input value shall be inside 0 and 2. **h** Input value shall be inside 0 and 3. **m** Input value shall be inside 0 and 4. **s** Input value shall be inside 0 and 5. Percent validation You can format a value from $inputValue as a percent and manage the precision. Use the key percent to have a extract value from $inputValue within 0 to 100. Suffix the key with .{Number} to manage precision ( percent.2 ). Example: $output = StrMask::apply(\"99.4125\", \"percent.2\"); // $output contains: 99.41 Prefix and suffix You have possibility to set suffix and prefix in output: $output = StrMask::apply(\"0102030405\", \"00 00 00 00 00\", [ \"prefix\" => \"My phone is \", \"suffix\" => \"!\" ]); // $output contains: My phone is 01 02 03 04 05!","title":"Mask"},{"location":"mask/#arguments","text":"$inputValue : string - The input value to apply mask. $maskExpression : string - The mask expression for $output. $config : array - The configuration for operation","title":"Arguments"},{"location":"mask/#patterns","text":"The patterns are used to filter $inputValue: Code Meaning **0** digits (like 0 to 9 numbers) **9** digits (like 0 to 9 numbers), but optional **A** letters (uppercase or lowercase) and digits **S** only letters (uppercase or lowercase)","title":"Patterns"},{"location":"mask/#special-chars","text":"Special chars are used in mask expressions to format output: / ( ) . : - space + , @","title":"Special chars"},{"location":"mask/#thousand-separator","text":"You can format a number in thousand separator and control precision. The mask keys are: separator : Input 1234.56 is ouputed as 1 234.56 dot_separator : Input 1234,56 is ouputed as 1.234,56 comma_separator : Input 1234.56 is ouputed as 1,234.56 To manage precision, keys shall be suffixed by .{Number} . Example: separator.1 : Input 1234.56743 is ouputed as 1 234.5 dot_separator.4 : Input 1234,56743 is ouputed as 1.234,5674 comma_separator.2 : Input 1234.56743 is ouputed as 1,234.56","title":"Thousand separator"},{"location":"mask/#time-validation","text":"You can format a time according limit: Mask Meaning **H** Input value shall be inside 0 and 2. **h** Input value shall be inside 0 and 3. **m** Input value shall be inside 0 and 4. **s** Input value shall be inside 0 and 5.","title":"Time validation"},{"location":"mask/#percent-validation","text":"You can format a value from $inputValue as a percent and manage the precision. Use the key percent to have a extract value from $inputValue within 0 to 100. Suffix the key with .{Number} to manage precision ( percent.2 ). Example: $output = StrMask::apply(\"99.4125\", \"percent.2\"); // $output contains: 99.41","title":"Percent validation"},{"location":"mask/#prefix-and-suffix","text":"You have possibility to set suffix and prefix in output: $output = StrMask::apply(\"0102030405\", \"00 00 00 00 00\", [ \"prefix\" => \"My phone is \", \"suffix\" => \"!\" ]); // $output contains: My phone is 01 02 03 04 05!","title":"Prefix and suffix"},{"location":"messages/","text":"Message is a component for displaying flash alerts in views rendered with Wolf Template. With it, it is possible to display a message of success, error or any other type of message. By default, this class is already instantiated in the Controller class. NOTE: if you do not extend the Controller class, you will need to instantiate the Message class. use Solital\\Core\\Resource\\Message; $message = new Message(); How to use You can create a normal message using the messages() helper. First, you must add an index to your message in the first parameter. This index serves to identify your message. In the second parameter, you will add your message. This will create a clean message without customizations (see more in Customizing messages ). message('msg.test', 'Just a test message displayed in the view!'); Using in Controllers If you are on a Controller. You have the option of not using the previous helper, as the Message class is already instantiated by default. To do this, use new() method. $this->message->new('msg.test', 'Just a test message displayed in the view!'); Returning messages To retrieve this message, use the get() method. /** With method in Controller */ echo $this->message->get('msg.test'); /** With helper */ echo message()->get('msg.test'); Customizing messages As mentioned at the beginning, the Message class has customized message options: info, success, warning and error. message()->info('msg.info.test', 'Info message test'); message()->success('msg.success.test', 'Success message test'); message()->warning('msg.warning.test', 'Warning message test'); message()->error('msg.error.test', 'Error message test'); Using one of the previous methods, you will get messages similar to these: <div class=\"alert-info\">Info message test</div> <div class=\"alert-success\">Success message test</div> <div class=\"alert-warning\">Warning message test</div> <div class=\"alert-error\">Error message test</div> Checking if a message exists If you want to know if a message exists, you can use the has() method. message()->has('msg.test'); This way you will check if a simple message exists. However, if you want to know if a custom message exists, you can use the following constants: message()->has('msg.info.test', Message::INFO); message()->has('msg.success.test', Message::SUCCESS); message()->has('msg.warning.test', Message::WARNING); message()->has('msg.error.test', Message::ERROR); Alternatively, if you want to know if there are only error messages, you can use the hasErrors() method. message()->hasErrors(); Using in Wolf Template To make use of this component in Wolf, the method of creating the message is exactly the same. The code represents a practical and recommended method of retrieving the message. <?php namespace Solital\\Components\\Controller; use Solital\\Core\\Http\\Controller\\Controller; class UserController extends Controller { /** * Construct */ public function __construct() { parent::_construct(); } /** * @return void */ public function home(): void { return view('home', [ 'msg' => message()->get('msg.test') // or use: $this->message->get('msg.test') ]); } /** * @return void */ public function generate(): void { message('msg.test', 'Just a test message displayed in the view!'); // Or use: $this->message->new('msg.test', 'Just a test message displayed in the view!'); } In your view, display the message this way: <div> {% if ($msg): %} <p>{{ $msg }}</p> {% endif; %} </div>","title":"Messages"},{"location":"messages/#how-to-use","text":"You can create a normal message using the messages() helper. First, you must add an index to your message in the first parameter. This index serves to identify your message. In the second parameter, you will add your message. This will create a clean message without customizations (see more in Customizing messages ). message('msg.test', 'Just a test message displayed in the view!');","title":"How to use"},{"location":"messages/#using-in-controllers","text":"If you are on a Controller. You have the option of not using the previous helper, as the Message class is already instantiated by default. To do this, use new() method. $this->message->new('msg.test', 'Just a test message displayed in the view!');","title":"Using in Controllers"},{"location":"messages/#returning-messages","text":"To retrieve this message, use the get() method. /** With method in Controller */ echo $this->message->get('msg.test'); /** With helper */ echo message()->get('msg.test');","title":"Returning messages"},{"location":"messages/#customizing-messages","text":"As mentioned at the beginning, the Message class has customized message options: info, success, warning and error. message()->info('msg.info.test', 'Info message test'); message()->success('msg.success.test', 'Success message test'); message()->warning('msg.warning.test', 'Warning message test'); message()->error('msg.error.test', 'Error message test'); Using one of the previous methods, you will get messages similar to these: <div class=\"alert-info\">Info message test</div> <div class=\"alert-success\">Success message test</div> <div class=\"alert-warning\">Warning message test</div> <div class=\"alert-error\">Error message test</div>","title":"Customizing messages"},{"location":"messages/#checking-if-a-message-exists","text":"If you want to know if a message exists, you can use the has() method. message()->has('msg.test'); This way you will check if a simple message exists. However, if you want to know if a custom message exists, you can use the following constants: message()->has('msg.info.test', Message::INFO); message()->has('msg.success.test', Message::SUCCESS); message()->has('msg.warning.test', Message::WARNING); message()->has('msg.error.test', Message::ERROR); Alternatively, if you want to know if there are only error messages, you can use the hasErrors() method. message()->hasErrors();","title":"Checking if a message exists"},{"location":"messages/#using-in-wolf-template","text":"To make use of this component in Wolf, the method of creating the message is exactly the same. The code represents a practical and recommended method of retrieving the message. <?php namespace Solital\\Components\\Controller; use Solital\\Core\\Http\\Controller\\Controller; class UserController extends Controller { /** * Construct */ public function __construct() { parent::_construct(); } /** * @return void */ public function home(): void { return view('home', [ 'msg' => message()->get('msg.test') // or use: $this->message->get('msg.test') ]); } /** * @return void */ public function generate(): void { message('msg.test', 'Just a test message displayed in the view!'); // Or use: $this->message->new('msg.test', 'Just a test message displayed in the view!'); } In your view, display the message this way: <div> {% if ($msg): %} <p>{{ $msg }}</p> {% endif; %} </div>","title":"Using in Wolf Template"},{"location":"middleware/","text":"The middleware in web applications is the mid-layer between the HTTP request and the application logic. The middleware process incoming requests and execute the code before the controller\u2019s actions. One of the main functions is filtering HTTP requests from the user\u2019s browser before the actual application logic. Create middleware The process to create a Middleware is quite simple: you can use the Vinci Console to create a middleware class. This class will be stored in app/Middleware/ . Command: php vinci create:middleware UserMiddleware Class: <?php namespace Solital\\Middleware; use Solital\\Core\\Http\\Middleware\\BaseMiddlewareInterface; class UserMiddleware implements BaseMiddlewareInterface { /** * @return void */ public function handle(): void { // ... } } Basic Middleware To assign middleware to all routes within a group, you may use the middleware key in the group attribute array. Middleware are executed in the order they are listed in the array: Course::group(['prefix' => '/admin', 'middleware' => '\\Solital\\Middleware\\UserMiddleware'], function () { Course::get(\"/login\", \"UserController@login\")->name('login'); Course::put(\"/logout\", \"UserController@logout\")->name('logout'); }); Use a helper If you don't want to type the entire middleware namespace, you can configure it in the middleware.yaml file and use the middleware helper. middleware.yaml middleware: login: UserMiddleware # Or: \\Solital\\Middleware\\UserMiddleware routes.php Course::group(['prefix' => '/admin', 'middleware' => middleware('login')], function () { Course::get(\"/login\", \"UserController@login\")->name('login'); Course::put(\"/logout\", \"UserController@logout\")->name('logout'); }); Adding Middleware If you only have one route that needs to add middleware, use the addMiddleware method. Course::match(['get', 'post'], '/user/login', 'UserMiddleware@login')->addMiddleware('\\Solital\\Middleware\\UserMiddleware:guest'); Restrict access to IP You can white and/or blacklist access to IP's using the build in IpRestrictAccess middleware. Create your own custom Middleware and extend the IpRestrictAccess class. The IpRestrictAccess class contains two properties ip_blocklist and ip_passlist that can be added to your middleware to change which IP's that have access to your routes. You can use * to restrict access to a range of ips. use Solital\\Core\\Http\\Middleware\\IpRestrictAccess; class IpRestrictMiddleware extends IpRestrictAccess implements BaseMiddlewareInterface { protected $ip_blocklist = [ '5.5.5.5', '8.8.*', ]; protected $ip_passlist = [ '8.8.2.2', ]; public function handle(): void { // ... } }","title":"Middleware"},{"location":"middleware/#create-middleware","text":"The process to create a Middleware is quite simple: you can use the Vinci Console to create a middleware class. This class will be stored in app/Middleware/ . Command: php vinci create:middleware UserMiddleware Class: <?php namespace Solital\\Middleware; use Solital\\Core\\Http\\Middleware\\BaseMiddlewareInterface; class UserMiddleware implements BaseMiddlewareInterface { /** * @return void */ public function handle(): void { // ... } }","title":"Create middleware"},{"location":"middleware/#basic-middleware","text":"To assign middleware to all routes within a group, you may use the middleware key in the group attribute array. Middleware are executed in the order they are listed in the array: Course::group(['prefix' => '/admin', 'middleware' => '\\Solital\\Middleware\\UserMiddleware'], function () { Course::get(\"/login\", \"UserController@login\")->name('login'); Course::put(\"/logout\", \"UserController@logout\")->name('logout'); });","title":"Basic Middleware"},{"location":"middleware/#use-a-helper","text":"If you don't want to type the entire middleware namespace, you can configure it in the middleware.yaml file and use the middleware helper. middleware.yaml middleware: login: UserMiddleware # Or: \\Solital\\Middleware\\UserMiddleware routes.php Course::group(['prefix' => '/admin', 'middleware' => middleware('login')], function () { Course::get(\"/login\", \"UserController@login\")->name('login'); Course::put(\"/logout\", \"UserController@logout\")->name('logout'); });","title":"Use a helper"},{"location":"middleware/#adding-middleware","text":"If you only have one route that needs to add middleware, use the addMiddleware method. Course::match(['get', 'post'], '/user/login', 'UserMiddleware@login')->addMiddleware('\\Solital\\Middleware\\UserMiddleware:guest');","title":"Adding Middleware"},{"location":"middleware/#restrict-access-to-ip","text":"You can white and/or blacklist access to IP's using the build in IpRestrictAccess middleware. Create your own custom Middleware and extend the IpRestrictAccess class. The IpRestrictAccess class contains two properties ip_blocklist and ip_passlist that can be added to your middleware to change which IP's that have access to your routes. You can use * to restrict access to a range of ips. use Solital\\Core\\Http\\Middleware\\IpRestrictAccess; class IpRestrictMiddleware extends IpRestrictAccess implements BaseMiddlewareInterface { protected $ip_blocklist = [ '5.5.5.5', '8.8.*', ]; protected $ip_passlist = [ '8.8.2.2', ]; public function handle(): void { // ... } }","title":"Restrict access to IP"},{"location":"migrations/","text":"Introduction Basically, it consists of maintaining the versioning of an application's database and manipulating it through code, enabling the sharing of all its change history. This makes life a lot easier for any development team, as it makes it possible to change the application schema just by executing the code responsible for it, which is also versioned and shared with the rest of the project. Creating migrations All migrations are stored in app/Database/Migrations . To create a migration, you must use the Vinci Console. php vinci create:migration user You can create a migration with a ready-made structure to create a table in the database, for that use the word create in the argument. php vinci create:migration create_user Structure of the migration Below is the structure of a standard migration: <?php namespace Solital\\Database\\Migrations; use Solital\\Core\\Database\\Migrations\\Migration; class Migration20211220193145 extends Migration { /** * Run migration * * @return mixed */ public function up() { // } /** * Roolback migration * * @return mixed */ public function down() { // } } If you used the word create in the argument, the default structure changes a bit like this: <?php namespace Solital\\Database\\Migrations; use Katrina\\Katrina; use Solital\\Core\\Database\\Migrations\\Migration; class Migration20211220193145 extends Migration { /** * Run migration * * @return mixed */ public function up() { Katrina::createTable(\"user\") ->int('id')->primary() // ... ->createdUpdatedAt() ->closeTable(); } /** * Roolback migration * * @return mixed */ public function down() { Katrina::dropTable(\"user\"); } } Running migrations To run migrations, it's simple: run the command below: php vinci migrate If you have a new migration or one that hasn't been run, use the --status option. php vinci migrate --status Rollback migrations If you want to roll back a migration, use the --rollback option. php vinci migrate --rollback The previous command will roll back all migrations created using the up() method. To limit the number of migrations, assign a value to --rollback . php vinci migrate --rollback=3","title":"Migrations"},{"location":"migrations/#introduction","text":"Basically, it consists of maintaining the versioning of an application's database and manipulating it through code, enabling the sharing of all its change history. This makes life a lot easier for any development team, as it makes it possible to change the application schema just by executing the code responsible for it, which is also versioned and shared with the rest of the project.","title":"Introduction"},{"location":"migrations/#creating-migrations","text":"All migrations are stored in app/Database/Migrations . To create a migration, you must use the Vinci Console. php vinci create:migration user You can create a migration with a ready-made structure to create a table in the database, for that use the word create in the argument. php vinci create:migration create_user","title":"Creating migrations"},{"location":"migrations/#structure-of-the-migration","text":"Below is the structure of a standard migration: <?php namespace Solital\\Database\\Migrations; use Solital\\Core\\Database\\Migrations\\Migration; class Migration20211220193145 extends Migration { /** * Run migration * * @return mixed */ public function up() { // } /** * Roolback migration * * @return mixed */ public function down() { // } } If you used the word create in the argument, the default structure changes a bit like this: <?php namespace Solital\\Database\\Migrations; use Katrina\\Katrina; use Solital\\Core\\Database\\Migrations\\Migration; class Migration20211220193145 extends Migration { /** * Run migration * * @return mixed */ public function up() { Katrina::createTable(\"user\") ->int('id')->primary() // ... ->createdUpdatedAt() ->closeTable(); } /** * Roolback migration * * @return mixed */ public function down() { Katrina::dropTable(\"user\"); } }","title":"Structure of the migration"},{"location":"migrations/#running-migrations","text":"To run migrations, it's simple: run the command below: php vinci migrate If you have a new migration or one that hasn't been run, use the --status option. php vinci migrate --status","title":"Running migrations"},{"location":"migrations/#rollback-migrations","text":"If you want to roll back a migration, use the --rollback option. php vinci migrate --rollback The previous command will roll back all migrations created using the up() method. To limit the number of migrations, assign a value to --rollback . php vinci migrate --rollback=3","title":"Rollback migrations"},{"location":"number/","text":"Solital has the Number class to manipulate numbers. You can use one of the methods below: use Solital\\Core\\Resource\\Number; // Reduce a number Number::reduce(1.2335566); // Format a number to currency Number::currency(12345678.90, 'BRL'); // Format a numer to percentage Number::percent(0.123); // Spellout rule-based format Number::spell(12345678); //Format a value Number::format(12345678.9); // lamp a given number between two other numbers Number::clamp(-2, 1, 100);","title":"Number"},{"location":"queue/","text":"Introduction Queues are an important solution, especially when need to create a processing task that may take a long time to complete and the user or the creating process cannot wait until the task is finished. This is the case for instance of sending newsletter email messages to many users. Usage The Queue component makes use of PHP 8.1 Fibers. As a result, queues are executed asynchronously. To create a queue, execute this command: php vinci create:queue UserQueue The queues will be stored inside the app/Queue folder. The structure that will be created is similar to this: <?php use Solital\\Core\\Queue\\Queue; class UserQueue extends Queue { protected float $sleep = 1; public function dispatch() { # ... } } All code must be added in the dispatch() method. Queue waiting time If you have code that takes a long time to execute, such as sending an email, you can set the waiting time by changing the value of the $sleep property. protected float $sleep = 5.3; With this, the Queue component will wait while executing other queues that you have created. Running a queue To run a queue, you will need to run the command: php vinci queue This command will run all queues you have created. Some queues that Solital creates will also run. You can run a specific queue. For that, use the --class option. php vinci queue --class=UserQueue","title":"Queue"},{"location":"queue/#introduction","text":"Queues are an important solution, especially when need to create a processing task that may take a long time to complete and the user or the creating process cannot wait until the task is finished. This is the case for instance of sending newsletter email messages to many users.","title":"Introduction"},{"location":"queue/#usage","text":"The Queue component makes use of PHP 8.1 Fibers. As a result, queues are executed asynchronously. To create a queue, execute this command: php vinci create:queue UserQueue The queues will be stored inside the app/Queue folder. The structure that will be created is similar to this: <?php use Solital\\Core\\Queue\\Queue; class UserQueue extends Queue { protected float $sleep = 1; public function dispatch() { # ... } } All code must be added in the dispatch() method.","title":"Usage"},{"location":"queue/#queue-waiting-time","text":"If you have code that takes a long time to execute, such as sending an email, you can set the waiting time by changing the value of the $sleep property. protected float $sleep = 5.3; With this, the Queue component will wait while executing other queues that you have created.","title":"Queue waiting time"},{"location":"queue/#running-a-queue","text":"To run a queue, you will need to run the command: php vinci queue This command will run all queues you have created. Some queues that Solital creates will also run. You can run a specific queue. For that, use the --class option. php vinci queue --class=UserQueue","title":"Running a queue"},{"location":"recovery-password/","text":"Setting This procedure uses the forgot method to define the database table (you can use a string with a table name or the Model name). The columns method the form's email field. In the values method, the e-mail that will be sent the recovery link is informed in the first parameter, and in the second parameter the URL that will be contained in the e-mail to change the password. The register method will check and send the email. Solital uses the default Model AuthModel . However, you can create a model and use it in the forgot() method. use Solital\\Core\\Kernel\\Model\\AuthModel; public function forgotPost(): void { $email = input()->post('email')->getValue(); $res = Auth::forgot(AuthModel::class) ->columns('username') ->values($email, url('change')) ->register(); if ($res == true) { message('forgot', 'Link sent to your email!'); response()->redirect(url('forgot')); } } Setting expiration time By default, the link sent is valid for 1 hour. You can change this behavior using the timeHash() method. Auth::forgot(AuthModel::class) ->columns('username') ->values($email, url('change')) # Here the code ->timeHash('+2 hours') ->register(); Changing email fields By default, \"User\" is sent as the name of the sender and recipient. \"Reset Password\" as the title of the email. To change these fields, use the customMailSender() and/or customMailFields() method. // Custom mail sender ->customMailSender('mail_sender@gmail.com'); // Custom sender, recipient and subject ->customMailFields('name_sender', 'name_recipient', 'subject'); The full code is: Auth::forgot(AuthModel::class) ->columns('username') ->values($email, url('change')) ->customMailSender('mail_sender@gmail.com') ->customMailFields('name_sender', 'name_recipient', 'subject') ->register(); Changing recovery template email To change the default email template, you can use Wolf to generate a new template. You will need to generate a link that will be used to validate the user's password change. To do this, use the $this->generateRecoveryLink method, informing as parameters the user's email, the url in which they will change their password and the time that this link will be valid. $wolf = new Wolf; $wolf->setArgs([ 'link' => $this->generateRecoveryLink('user_email@gmail.com', url('change'), '+2 hours') ]); $wolf->setView('auth.template-recovery-password'); $template = $wolf->render(); Then add this template to the last parameter of the customMailFields method. Auth::forgot(AuthModel::class) ->columns('username') ->values($email, url('change')) # Here the code ->customMailFields('name_sender', 'name_recipient', 'subject', $template) ->register(); Validade link To validate the information by clicking on the email link, you can use the structure below: /** * @param string $hash * * @return void */ public function change($hash): void { $res = Hash::decrypt($hash)->isValid(); if ($res == true) { $email = Hash::decrypt($hash)->value(); return view('auth.change-pass-form', [ 'title' => 'Change Password', 'email' => $email, 'hash' => $hash ]); } message('login', 'The informed link has already expired!'); response()->redirect(url('auth')); } Changing the password This procedure uses the change method to define the database table. The columns method defines the database user and password fields. The values method defines the user's email in the first parameter, and the new password in the second parameter. The register method will check and change the email. Auth::change(AuthModel::class) ->columns('username', 'password') ->values($email, $pass) ->register(); Password recovery structure You can create a predefined password recovery framework. To do so, use the php vinci auth:skeleton --forgot command. This command creates a controller with the name ForgotController . With it you will have all the basis to create a password recovery system. If you want to remove this structure, use php vinci auth:skeleton --forgot --remove .","title":"Recovery Password"},{"location":"recovery-password/#setting","text":"This procedure uses the forgot method to define the database table (you can use a string with a table name or the Model name). The columns method the form's email field. In the values method, the e-mail that will be sent the recovery link is informed in the first parameter, and in the second parameter the URL that will be contained in the e-mail to change the password. The register method will check and send the email. Solital uses the default Model AuthModel . However, you can create a model and use it in the forgot() method. use Solital\\Core\\Kernel\\Model\\AuthModel; public function forgotPost(): void { $email = input()->post('email')->getValue(); $res = Auth::forgot(AuthModel::class) ->columns('username') ->values($email, url('change')) ->register(); if ($res == true) { message('forgot', 'Link sent to your email!'); response()->redirect(url('forgot')); } }","title":"Setting"},{"location":"recovery-password/#setting-expiration-time","text":"By default, the link sent is valid for 1 hour. You can change this behavior using the timeHash() method. Auth::forgot(AuthModel::class) ->columns('username') ->values($email, url('change')) # Here the code ->timeHash('+2 hours') ->register();","title":"Setting expiration time"},{"location":"recovery-password/#changing-email-fields","text":"By default, \"User\" is sent as the name of the sender and recipient. \"Reset Password\" as the title of the email. To change these fields, use the customMailSender() and/or customMailFields() method. // Custom mail sender ->customMailSender('mail_sender@gmail.com'); // Custom sender, recipient and subject ->customMailFields('name_sender', 'name_recipient', 'subject'); The full code is: Auth::forgot(AuthModel::class) ->columns('username') ->values($email, url('change')) ->customMailSender('mail_sender@gmail.com') ->customMailFields('name_sender', 'name_recipient', 'subject') ->register();","title":"Changing email fields"},{"location":"recovery-password/#changing-recovery-template-email","text":"To change the default email template, you can use Wolf to generate a new template. You will need to generate a link that will be used to validate the user's password change. To do this, use the $this->generateRecoveryLink method, informing as parameters the user's email, the url in which they will change their password and the time that this link will be valid. $wolf = new Wolf; $wolf->setArgs([ 'link' => $this->generateRecoveryLink('user_email@gmail.com', url('change'), '+2 hours') ]); $wolf->setView('auth.template-recovery-password'); $template = $wolf->render(); Then add this template to the last parameter of the customMailFields method. Auth::forgot(AuthModel::class) ->columns('username') ->values($email, url('change')) # Here the code ->customMailFields('name_sender', 'name_recipient', 'subject', $template) ->register();","title":"Changing recovery template email"},{"location":"recovery-password/#validade-link","text":"To validate the information by clicking on the email link, you can use the structure below: /** * @param string $hash * * @return void */ public function change($hash): void { $res = Hash::decrypt($hash)->isValid(); if ($res == true) { $email = Hash::decrypt($hash)->value(); return view('auth.change-pass-form', [ 'title' => 'Change Password', 'email' => $email, 'hash' => $hash ]); } message('login', 'The informed link has already expired!'); response()->redirect(url('auth')); }","title":"Validade link"},{"location":"recovery-password/#changing-the-password","text":"This procedure uses the change method to define the database table. The columns method defines the database user and password fields. The values method defines the user's email in the first parameter, and the new password in the second parameter. The register method will check and change the email. Auth::change(AuthModel::class) ->columns('username', 'password') ->values($email, $pass) ->register();","title":"Changing the password"},{"location":"recovery-password/#password-recovery-structure","text":"You can create a predefined password recovery framework. To do so, use the php vinci auth:skeleton --forgot command. This command creates a controller with the name ForgotController . With it you will have all the basis to create a password recovery system. If you want to remove this structure, use php vinci auth:skeleton --forgot --remove .","title":"Password recovery structure"},{"location":"routes/","text":"Basic routing Below is a very basic example of setting up a route. First parameter is the url which the route should match - next parameter is a Closure or callback function that will be triggered once the route matches. Course::get('/', function() { return 'Hello world'; }); You can also create a route using the vinci console: php vinci create:router my-router # With comment php vinci create:router my-router --comment=\"This is a comment\" Available methods Here you can see a list over all available routes: Course::get($url, $callback, $settings); Course::post($url, $callback, $settings); Course::put($url, $callback, $settings); Course::patch($url, $callback, $settings); Course::delete($url, $callback, $settings); Course::options($url, $callback, $settings); Multiple HTTP-verbs Sometimes you might need to create a route that accepts multiple HTTP-verbs. If you need to match all HTTP-verbs you can use the any method. Course::match(['get', 'post'], '/', function() { // ... }); Course::any('foo', function() { // ... }); We've created a simple method which matches GET and POST which is most commonly used: Course::form('foo', function() { // ... }); Default Base Path This will allows users to set a default basepath for all url requests, which will be prepended to all url parameters. Course::setDefaultBasepath('/forum') Route parameters Required parameters You'll properly wondering by know how you parse parameters from your urls. For example, you might want to capture the users id from an url. You can do so by defining route-parameters. Course::get('/user/{id}', function ($userId) { return 'User with id: ' . $userId; }); You may define as many route parameters as required by your route: Course::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) { // ... }); Note: Route parameters are always encased within {} braces and should consist of alphabetic characters. Route parameters may not contain a - character. Use an underscore _ instead. Optional parameters Occasionally you may need to specify a route parameter, but make the presence of that route parameter optional. You may do so by placing a ? mark after the parameter name. Make sure to give the route's corresponding variable a default value: Course::get('/user/{name?}', function ($name = null) { return $name; }); Course::get('/user/{name?}', function ($name = 'Simon') { return $name; }); Regular expression constraints You may constrain the format of your route parameters using the where method on a route instance. The where method accepts the name of the parameter and a regular expression defining how the parameter should be constrained: Course::get('/user/{name}', function ($name) { // ... do stuff })->where('name', '[A-Za-z]+'); Course::get('/user/{id}', function ($id) { // ... do stuff })->where('id', '[0-9]+'); Course::get('/user/{id}/{name}', function ($id, $name) { // ... do stuff })->where(['id' => '[0-9]+', 'name' => '[a-z]+']); Regular expression route-match You can define a regular-expression match for the entire route if you wish. This is useful if you for example are creating a model-box which loads urls from ajax. The example below is using the following regular expression: /ajax/([\\w]+)/?([0-9]+)?/? which basically just matches /ajax/ and exspects the next parameter to be a string - and the next to be a number (but optional). Matches: /ajax/abc/ , /ajax/abc/123/ Won't match: /ajax/ Match groups specified in the regex will be passed on as parameters: Course::all('/ajax/abc/123', function($param1, $param2) { // param1 = abc // param2 = 123 })->setMatch('/\\/ajax\\/([\\w]+)\\/?([0-9]+)?\\/?/is'); Custom regex for matching parameters By default Solital uses the \\w regular expression when matching parameters. This decision was made with speed and reliability in mind, as this match will match both letters, number and most of the used symbols on the internet. However, sometimes it can be necessary to add a custom regular expression to match more advanced characters like - etc. Instead of adding a custom regular expression to all your parameters, you can simply add a global regular expression which will be used on all the parameters on the route. Note: If you the regular expression to be available across, we recommend using the global parameter on a group as demonstrated in the examples below. Example This example will ensure that all parameters use the [\\w\\-]+ regular expression when parsing. Course::get('/path/{parameter}', 'VideoController@home', ['defaultParameterRegex' => '[\\w\\-]+']); You can also apply this setting to a group if you need multiple routes to use your custom regular expression when parsing parameters. Course::group(['defaultParameterRegex' => '[\\w\\-]+'], function() { Course::get('/path/{parameter}', 'VideoController@home'); }); Named routes Named routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route by chaining the name method onto the route definition: Course::get('/user/profile', function () { // Your code here })->name('profile'); You can also specify names for Controller-actions: Course::get('/user/profile', 'UserController@profile')->name('profile'); Generating URLs To Named Routes Once you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via the global url helper-function (see helpers section): // Generating URLs... $url = url('profile'); If the named route defines parameters, you may pass the parameters as the second argument to the url function. The given parameters will automatically be inserted into the URL in their correct positions: Course::get('/user/{id}/profile', function ($id) { // })->name('profile'); $url = url('profile', ['id' => 1]); For more information on urls, please see the Urls section. Router groups Route groups allow you to share route attributes, such as middleware or namespaces, across a large number of routes without needing to define those attributes on each individual route. Shared attributes are specified in an array format as the first parameter to the Course::group method. Namespaces Solital already has the default namespace to search for controllers ( Solital\\Components\\Controller ) Note Group namespaces will only be added to routes with relative callbacks. For example if your route has an absolute callback like UserController@home , the namespace from the route will not be prepended. To fix this you can make the callback relative by removing the \\ in the beginning of the callback. Course::group(['namespace' => 'Admin'], function () { // Controllers Within The \"App\\Http\\Controllers\\Admin\" Namespace }); Subdomain-routing Route groups may also be used to handle sub-domain routing. Sub-domains may be assigned route parameters just like route urls, allowing you to capture a portion of the sub-domain for usage in your route or controller. The sub-domain may be specified using the domain key on the group attribute array: Course::group(['domain' => '{account}.myapp.com'], function () { Course::get('/user/{id}', function ($account, $id) { // }); }); Route prefixes The prefix group attribute may be used to prefix each route in the group with a given url. For example, you may want to prefix all route urls within the group with admin : Course::group(['prefix' => '/admin'], function () { Course::get('/users', function () { // Matches The \"/admin/users\" URL }); }); Partial groups Partial router groups has the same benefits as a normal group, but supports parameters and are only rendered once the url has matched. This can be extremely useful in situations, where you only want special routes to be added, when a certain criteria or logic has been met. NOTE: Use partial groups with caution as routes added within are only rendered and available once the url of the partial-group has matched. This can cause url() not to find urls for the routes added within. Example: Course::partialGroup('/admin/{applicationId}', function ($applicationId) { Course::get('/', function($applicationId) { // Matches The \"/admin/applicationId\" URL }); }); Custom class loader You can easily extend simple-router to support custom injection frameworks like php-di by taking advantage of the ability to add your custom class-loader. Class-loaders must inherit the ClassLoaderInterface interface. Example: class MyCustomClassLoader implements ClassLoaderInterface { /** * Load class * * @param string $class * @return object * @throws NotFoundHttpException */ public function loadClass(string $class) { if (\\class_exists($class) === false) { throw new NotFoundHttpException(sprintf('Class \"%s\" does not exist', $class), 404); } return new $class(); } /** * Load closure * * @param Callable $closure * @param array $parameters * @return mixed */ public function loadClosure(Callable $closure, array $parameters) { return \\call_user_func_array($closure, array_values($parameters)); } } Next, we need to configure our routes.php so the router uses our MyCustomClassLoader class for loading classes. This can be done by adding the following line to your routes.php file. Course::setCustomClassLoader(new MyCustomClassLoader()); Exception Handlers ExceptionHandler are classes that handles all exceptions. ExceptionsHandlers must implement the ExceptionHandlerInterface interface. Handling 404, 403 and other errors If you simply want to catch a 404 (page not found) etc. you can use the Course::error($callback) static helper method. This will add a callback method which is fired whenever an error occurs on all routes. The basic example below simply redirect the page to /not-found if an NotFoundHttpException (404) occurred. The code should be placed in the file that contains your routes. Course::get('/not-found', 'PageController@notFound'); Course::get('/forbidden', 'PageController@notFound'); Course::error(function(Request $request, \\Exception $exception) { switch($exception->getCode()) { // Page not found case 404: response()->redirect('/not-found'); // Forbidden case 403: response()->redirect('/forbidden'); } }); The example above will redirect all errors with http-code 404 (page not found) to /not-found and 403 (forbidden) to /forbidden . If you do not want a redirect, but want the error-page rendered on the current-url, you can tell the router to execute a rewrite callback like so: $request->setRewriteCallback('ErrorController@notFound'); If you will set the correct status for the browser error use: Course::response()->httpCode(404); Using custom exception handlers This is a basic example of an ExceptionHandler implementation. use Solital\\Core\\Http\\Request; use Solital\\Core\\Http\\Exception\\NotFoundHttpException; use Solital\\Core\\Exceptions\\ExceptionHandlerInterface; class CustomExceptionHandler implements ExceptionHandlerInterface { public function handleError(Request $request, \\Exception $error): void { /* You can use the exception handler to format errors depending on the request and type. */ if ($request->getUrl()->contains('/api')) { response()->json([ 'error' => $error->getMessage(), 'code' => $error->getCode(), ]); } /* The router will throw the NotFoundHttpException on 404 */ if($error instanceof NotFoundHttpException) { // Render custom 404-page $request->setRewriteCallback('Demo\\Controllers\\PageController@notFound'); return; } /* Other error */ if($error instanceof MyCustomException) { $request->setRewriteRoute( // Add new route based on current url (minus query-string) and add custom parameters. (new RouteUrl(url(null, null, []), 'PageController@error'))->setParameters(['exception' => $error]) ); return; } throw $error; } } You can add your custom exception-handler class to your group by using the exceptionHandler settings-attribute. exceptionHandler can be either class-name or array of class-names. Course::group(['exceptionHandler' => CustomExceptionHandler::class], function() { // Your routes here }); Prevent merge of parent exception-handlers By default the router will merge exception-handlers to any handlers provided by parent groups, and will be executed in the order of newest to oldest. If you want your groups exception handler to be executed independently, you can add the mergeExceptionHandlers attribute and set it to false . Course::group(['prefix' => '/', 'exceptionHandler' => FirstExceptionHandler::class, 'mergeExceptionHandlers' => false], function() { Course::group(['prefix' => '/admin', 'exceptionHandler' => SecondExceptionHandler::class], function() { // Both SecondExceptionHandler and FirstExceptionHandler will trigger (in that order). }); Course::group(['prefix' => '/user', 'exceptionHandler' => SecondExceptionHandler::class, 'mergeExceptionHandlers' => false], function() { // Only SecondExceptionHandler will trigger. }); }); URL Rewriting Changing current route Sometimes it can be useful to manipulate the route about to be loaded. Solital allows you to easily manipulate and change the routes which are about to be rendered. All information about the current route is stored in the \\Solital\\Core\\Course\\Router instance's loadedRoute property. For easy access you can use the shortcut helper function request() instead of calling the class directly \\Solital\\Core\\Course\\Course::router() . request()->setRewriteCallback('Example\\MyCustomClass@hello'); // -- or you can rewrite by url -- request()->setRewriteUrl('/my-rewrite-url'); Bootmanager: loading routes dynamically Sometimes it can be necessary to keep urls stored in the database, file or similar. In this example, we want the url /my-cat-is-beatiful to load the route /article/view/1 which the router knows, because it's defined in the routes.php file. To interfere with the router, we create a class that implements the RouterBootManagerInterface interface. This class will be loaded before any other rules in routes.php and allow us to \"change\" the current route, if any of our criteria are fulfilled (like coming from the url /my-cat-is-beatiful ). To create a bootmanager, run the command: php vinci create:boot CustomRouterRules All bootmanagers you create will be stored in the app/BootManager/ folder. <?php namespace Solital\\BootManager; use Solital\\Core\\Http\\Request; use Solital\\Core\\Course\\RouterBootManagerInterface; use Solital\\Core\\Course\\Router; class CustomRouterRules implements RouterBootManagerInterface { /** * Called when router is booting and before the routes is loaded. * * @param Router $router * @param Request $request */ public function boot(Router $router, Request $request): void { $rewriteRules = [ '/my-cat-is-beatiful' => '/article/view/1', '/horses-are-great' => '/article/view/2', ]; foreach ($rewriteRules as $url => $rule) { // If the current url matches the rewrite url, we use our custom route if ($request->getUri()->getPath() === $url) { $request->setRewriteUrl($rule); } } } } The above should be pretty self-explanatory and can easily be changed to loop through urls store in the database, file or cache. What happens is that if the current route matches the route defined in the index of our $rewriteRules array, we set the route to the array value instead. By doing this the route will now load the url /article/view/1 instead of /my-cat-is-beatiful . Adding routes manually The Course class referenced in the previous example, is just a simple helper class that knows how to communicate with the Router class. If you are up for a challenge, want the full control or simply just want to create your own Router helper class, this example is for you. use \\Solital\\Core\\Course\\Router; use \\Solital\\Core\\Course\\Route\\RouteUrl; /* Create new Router instance */ $router = new Router(); $route = new RouteUrl('/answer/1', function() { die('this callback will match /answer/1'); }); $route->addMiddleware(\\Demo\\Middlewares\\AuthMiddleware::class); $route->setNamespace('\\Demo\\Controllers'); $route->setPrefix('v1'); /* Add the route to the router */ $router->addRoute($route); Extending This is a simple example of an integration into a framework. The framework has it's own Router class which inherits from the Course class. This allows the framework to add custom functionality like loading a custom routes.php file or add debugging information etc. namespace Demo; use Solital\\Core\\Course\\Course; class Router extends Course { public static function start() { // change default namespace for all routes parent::setDefaultNamespace('\\Demo\\Controllers'); // change this to whatever makes sense in your project require_once 'routes.php'; // Do initial stuff parent::start(); } } Form Method Spoofing HTML forms do not support PUT , PATCH or DELETE actions. Therefore, when defining the PUT , PATCH or DELETE routes that are called from an HTML form, you will need to use the spoofing helper to add a hidden _method field to the form. The value sent with the _method field will be used as the HTTP request method: <form method=\"post\" action=\"{{ url() }}\"> {{ spoofing('put'); }} <!-- other input elements here --> </form> Accessing The Current Route You can access information about the current route loaded by using the following method: Course::request()->getLoadedRoute(); request()->getLoadedRoute(); Other examples You can find many other examples in the sample file below: <?php use Solital\\Core\\Course\\Course; /* Adding custom csrfVerifier here */ Course::csrfVerifier(new \\Demo\\Middlewares\\CsrfVerifier()); Course::group(['middleware' => \\Demo\\Middlewares\\Site::class, 'exceptionHandler' => \\Demo\\Handlers\\CustomExceptionHandler::class], function() { Course::get('/answers/{id}', 'ControllerAnswers@show', ['where' => ['id' => '[0-9]+']]); /** * Restful resource (see IRestController interface for available methods) */ Course::resource('/rest', ControllerRessource::class); /** * Load the entire controller (where url matches method names - getIndex(), postIndex(), putIndex()). * The url paths will determine which method to render. * * For example: * * GET /animals => getIndex() * GET /animals/view => getView() * POST /animals/save => postSave() * * etc. */ Course::controller('/animals', ControllerAnimals::class); }); Course::get('/page/404', 'ControllerPage@notFound', ['as' => 'page.notfound']);","title":"Routes"},{"location":"routes/#basic-routing","text":"Below is a very basic example of setting up a route. First parameter is the url which the route should match - next parameter is a Closure or callback function that will be triggered once the route matches. Course::get('/', function() { return 'Hello world'; }); You can also create a route using the vinci console: php vinci create:router my-router # With comment php vinci create:router my-router --comment=\"This is a comment\"","title":"Basic routing"},{"location":"routes/#available-methods","text":"Here you can see a list over all available routes: Course::get($url, $callback, $settings); Course::post($url, $callback, $settings); Course::put($url, $callback, $settings); Course::patch($url, $callback, $settings); Course::delete($url, $callback, $settings); Course::options($url, $callback, $settings);","title":"Available methods"},{"location":"routes/#multiple-http-verbs","text":"Sometimes you might need to create a route that accepts multiple HTTP-verbs. If you need to match all HTTP-verbs you can use the any method. Course::match(['get', 'post'], '/', function() { // ... }); Course::any('foo', function() { // ... }); We've created a simple method which matches GET and POST which is most commonly used: Course::form('foo', function() { // ... });","title":"Multiple HTTP-verbs"},{"location":"routes/#default-base-path","text":"This will allows users to set a default basepath for all url requests, which will be prepended to all url parameters. Course::setDefaultBasepath('/forum')","title":"Default Base Path"},{"location":"routes/#route-parameters","text":"","title":"Route parameters"},{"location":"routes/#required-parameters","text":"You'll properly wondering by know how you parse parameters from your urls. For example, you might want to capture the users id from an url. You can do so by defining route-parameters. Course::get('/user/{id}', function ($userId) { return 'User with id: ' . $userId; }); You may define as many route parameters as required by your route: Course::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) { // ... }); Note: Route parameters are always encased within {} braces and should consist of alphabetic characters. Route parameters may not contain a - character. Use an underscore _ instead.","title":"Required parameters"},{"location":"routes/#optional-parameters","text":"Occasionally you may need to specify a route parameter, but make the presence of that route parameter optional. You may do so by placing a ? mark after the parameter name. Make sure to give the route's corresponding variable a default value: Course::get('/user/{name?}', function ($name = null) { return $name; }); Course::get('/user/{name?}', function ($name = 'Simon') { return $name; });","title":"Optional parameters"},{"location":"routes/#regular-expression-constraints","text":"You may constrain the format of your route parameters using the where method on a route instance. The where method accepts the name of the parameter and a regular expression defining how the parameter should be constrained: Course::get('/user/{name}', function ($name) { // ... do stuff })->where('name', '[A-Za-z]+'); Course::get('/user/{id}', function ($id) { // ... do stuff })->where('id', '[0-9]+'); Course::get('/user/{id}/{name}', function ($id, $name) { // ... do stuff })->where(['id' => '[0-9]+', 'name' => '[a-z]+']);","title":"Regular expression constraints"},{"location":"routes/#regular-expression-route-match","text":"You can define a regular-expression match for the entire route if you wish. This is useful if you for example are creating a model-box which loads urls from ajax. The example below is using the following regular expression: /ajax/([\\w]+)/?([0-9]+)?/? which basically just matches /ajax/ and exspects the next parameter to be a string - and the next to be a number (but optional). Matches: /ajax/abc/ , /ajax/abc/123/ Won't match: /ajax/ Match groups specified in the regex will be passed on as parameters: Course::all('/ajax/abc/123', function($param1, $param2) { // param1 = abc // param2 = 123 })->setMatch('/\\/ajax\\/([\\w]+)\\/?([0-9]+)?\\/?/is');","title":"Regular expression route-match"},{"location":"routes/#custom-regex-for-matching-parameters","text":"By default Solital uses the \\w regular expression when matching parameters. This decision was made with speed and reliability in mind, as this match will match both letters, number and most of the used symbols on the internet. However, sometimes it can be necessary to add a custom regular expression to match more advanced characters like - etc. Instead of adding a custom regular expression to all your parameters, you can simply add a global regular expression which will be used on all the parameters on the route. Note: If you the regular expression to be available across, we recommend using the global parameter on a group as demonstrated in the examples below.","title":"Custom regex for matching parameters"},{"location":"routes/#example","text":"This example will ensure that all parameters use the [\\w\\-]+ regular expression when parsing. Course::get('/path/{parameter}', 'VideoController@home', ['defaultParameterRegex' => '[\\w\\-]+']); You can also apply this setting to a group if you need multiple routes to use your custom regular expression when parsing parameters. Course::group(['defaultParameterRegex' => '[\\w\\-]+'], function() { Course::get('/path/{parameter}', 'VideoController@home'); });","title":"Example"},{"location":"routes/#named-routes","text":"Named routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route by chaining the name method onto the route definition: Course::get('/user/profile', function () { // Your code here })->name('profile'); You can also specify names for Controller-actions: Course::get('/user/profile', 'UserController@profile')->name('profile');","title":"Named routes"},{"location":"routes/#generating-urls-to-named-routes","text":"Once you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via the global url helper-function (see helpers section): // Generating URLs... $url = url('profile'); If the named route defines parameters, you may pass the parameters as the second argument to the url function. The given parameters will automatically be inserted into the URL in their correct positions: Course::get('/user/{id}/profile', function ($id) { // })->name('profile'); $url = url('profile', ['id' => 1]); For more information on urls, please see the Urls section.","title":"Generating URLs To Named Routes"},{"location":"routes/#router-groups","text":"Route groups allow you to share route attributes, such as middleware or namespaces, across a large number of routes without needing to define those attributes on each individual route. Shared attributes are specified in an array format as the first parameter to the Course::group method.","title":"Router groups"},{"location":"routes/#namespaces","text":"Solital already has the default namespace to search for controllers ( Solital\\Components\\Controller )","title":"Namespaces"},{"location":"routes/#note","text":"Group namespaces will only be added to routes with relative callbacks. For example if your route has an absolute callback like UserController@home , the namespace from the route will not be prepended. To fix this you can make the callback relative by removing the \\ in the beginning of the callback. Course::group(['namespace' => 'Admin'], function () { // Controllers Within The \"App\\Http\\Controllers\\Admin\" Namespace });","title":"Note"},{"location":"routes/#subdomain-routing","text":"Route groups may also be used to handle sub-domain routing. Sub-domains may be assigned route parameters just like route urls, allowing you to capture a portion of the sub-domain for usage in your route or controller. The sub-domain may be specified using the domain key on the group attribute array: Course::group(['domain' => '{account}.myapp.com'], function () { Course::get('/user/{id}', function ($account, $id) { // }); });","title":"Subdomain-routing"},{"location":"routes/#route-prefixes","text":"The prefix group attribute may be used to prefix each route in the group with a given url. For example, you may want to prefix all route urls within the group with admin : Course::group(['prefix' => '/admin'], function () { Course::get('/users', function () { // Matches The \"/admin/users\" URL }); });","title":"Route prefixes"},{"location":"routes/#partial-groups","text":"Partial router groups has the same benefits as a normal group, but supports parameters and are only rendered once the url has matched. This can be extremely useful in situations, where you only want special routes to be added, when a certain criteria or logic has been met. NOTE: Use partial groups with caution as routes added within are only rendered and available once the url of the partial-group has matched. This can cause url() not to find urls for the routes added within. Example: Course::partialGroup('/admin/{applicationId}', function ($applicationId) { Course::get('/', function($applicationId) { // Matches The \"/admin/applicationId\" URL }); });","title":"Partial groups"},{"location":"routes/#custom-class-loader","text":"You can easily extend simple-router to support custom injection frameworks like php-di by taking advantage of the ability to add your custom class-loader. Class-loaders must inherit the ClassLoaderInterface interface. Example: class MyCustomClassLoader implements ClassLoaderInterface { /** * Load class * * @param string $class * @return object * @throws NotFoundHttpException */ public function loadClass(string $class) { if (\\class_exists($class) === false) { throw new NotFoundHttpException(sprintf('Class \"%s\" does not exist', $class), 404); } return new $class(); } /** * Load closure * * @param Callable $closure * @param array $parameters * @return mixed */ public function loadClosure(Callable $closure, array $parameters) { return \\call_user_func_array($closure, array_values($parameters)); } } Next, we need to configure our routes.php so the router uses our MyCustomClassLoader class for loading classes. This can be done by adding the following line to your routes.php file. Course::setCustomClassLoader(new MyCustomClassLoader());","title":"Custom class loader"},{"location":"routes/#exception-handlers","text":"ExceptionHandler are classes that handles all exceptions. ExceptionsHandlers must implement the ExceptionHandlerInterface interface.","title":"Exception Handlers"},{"location":"routes/#handling-404-403-and-other-errors","text":"If you simply want to catch a 404 (page not found) etc. you can use the Course::error($callback) static helper method. This will add a callback method which is fired whenever an error occurs on all routes. The basic example below simply redirect the page to /not-found if an NotFoundHttpException (404) occurred. The code should be placed in the file that contains your routes. Course::get('/not-found', 'PageController@notFound'); Course::get('/forbidden', 'PageController@notFound'); Course::error(function(Request $request, \\Exception $exception) { switch($exception->getCode()) { // Page not found case 404: response()->redirect('/not-found'); // Forbidden case 403: response()->redirect('/forbidden'); } }); The example above will redirect all errors with http-code 404 (page not found) to /not-found and 403 (forbidden) to /forbidden . If you do not want a redirect, but want the error-page rendered on the current-url, you can tell the router to execute a rewrite callback like so: $request->setRewriteCallback('ErrorController@notFound'); If you will set the correct status for the browser error use: Course::response()->httpCode(404);","title":"Handling 404, 403 and other errors"},{"location":"routes/#using-custom-exception-handlers","text":"This is a basic example of an ExceptionHandler implementation. use Solital\\Core\\Http\\Request; use Solital\\Core\\Http\\Exception\\NotFoundHttpException; use Solital\\Core\\Exceptions\\ExceptionHandlerInterface; class CustomExceptionHandler implements ExceptionHandlerInterface { public function handleError(Request $request, \\Exception $error): void { /* You can use the exception handler to format errors depending on the request and type. */ if ($request->getUrl()->contains('/api')) { response()->json([ 'error' => $error->getMessage(), 'code' => $error->getCode(), ]); } /* The router will throw the NotFoundHttpException on 404 */ if($error instanceof NotFoundHttpException) { // Render custom 404-page $request->setRewriteCallback('Demo\\Controllers\\PageController@notFound'); return; } /* Other error */ if($error instanceof MyCustomException) { $request->setRewriteRoute( // Add new route based on current url (minus query-string) and add custom parameters. (new RouteUrl(url(null, null, []), 'PageController@error'))->setParameters(['exception' => $error]) ); return; } throw $error; } } You can add your custom exception-handler class to your group by using the exceptionHandler settings-attribute. exceptionHandler can be either class-name or array of class-names. Course::group(['exceptionHandler' => CustomExceptionHandler::class], function() { // Your routes here });","title":"Using custom exception handlers"},{"location":"routes/#prevent-merge-of-parent-exception-handlers","text":"By default the router will merge exception-handlers to any handlers provided by parent groups, and will be executed in the order of newest to oldest. If you want your groups exception handler to be executed independently, you can add the mergeExceptionHandlers attribute and set it to false . Course::group(['prefix' => '/', 'exceptionHandler' => FirstExceptionHandler::class, 'mergeExceptionHandlers' => false], function() { Course::group(['prefix' => '/admin', 'exceptionHandler' => SecondExceptionHandler::class], function() { // Both SecondExceptionHandler and FirstExceptionHandler will trigger (in that order). }); Course::group(['prefix' => '/user', 'exceptionHandler' => SecondExceptionHandler::class, 'mergeExceptionHandlers' => false], function() { // Only SecondExceptionHandler will trigger. }); });","title":"Prevent merge of parent exception-handlers"},{"location":"routes/#url-rewriting","text":"","title":"URL Rewriting"},{"location":"routes/#changing-current-route","text":"Sometimes it can be useful to manipulate the route about to be loaded. Solital allows you to easily manipulate and change the routes which are about to be rendered. All information about the current route is stored in the \\Solital\\Core\\Course\\Router instance's loadedRoute property. For easy access you can use the shortcut helper function request() instead of calling the class directly \\Solital\\Core\\Course\\Course::router() . request()->setRewriteCallback('Example\\MyCustomClass@hello'); // -- or you can rewrite by url -- request()->setRewriteUrl('/my-rewrite-url');","title":"Changing current route"},{"location":"routes/#bootmanager-loading-routes-dynamically","text":"Sometimes it can be necessary to keep urls stored in the database, file or similar. In this example, we want the url /my-cat-is-beatiful to load the route /article/view/1 which the router knows, because it's defined in the routes.php file. To interfere with the router, we create a class that implements the RouterBootManagerInterface interface. This class will be loaded before any other rules in routes.php and allow us to \"change\" the current route, if any of our criteria are fulfilled (like coming from the url /my-cat-is-beatiful ). To create a bootmanager, run the command: php vinci create:boot CustomRouterRules All bootmanagers you create will be stored in the app/BootManager/ folder. <?php namespace Solital\\BootManager; use Solital\\Core\\Http\\Request; use Solital\\Core\\Course\\RouterBootManagerInterface; use Solital\\Core\\Course\\Router; class CustomRouterRules implements RouterBootManagerInterface { /** * Called when router is booting and before the routes is loaded. * * @param Router $router * @param Request $request */ public function boot(Router $router, Request $request): void { $rewriteRules = [ '/my-cat-is-beatiful' => '/article/view/1', '/horses-are-great' => '/article/view/2', ]; foreach ($rewriteRules as $url => $rule) { // If the current url matches the rewrite url, we use our custom route if ($request->getUri()->getPath() === $url) { $request->setRewriteUrl($rule); } } } } The above should be pretty self-explanatory and can easily be changed to loop through urls store in the database, file or cache. What happens is that if the current route matches the route defined in the index of our $rewriteRules array, we set the route to the array value instead. By doing this the route will now load the url /article/view/1 instead of /my-cat-is-beatiful .","title":"Bootmanager: loading routes dynamically"},{"location":"routes/#adding-routes-manually","text":"The Course class referenced in the previous example, is just a simple helper class that knows how to communicate with the Router class. If you are up for a challenge, want the full control or simply just want to create your own Router helper class, this example is for you. use \\Solital\\Core\\Course\\Router; use \\Solital\\Core\\Course\\Route\\RouteUrl; /* Create new Router instance */ $router = new Router(); $route = new RouteUrl('/answer/1', function() { die('this callback will match /answer/1'); }); $route->addMiddleware(\\Demo\\Middlewares\\AuthMiddleware::class); $route->setNamespace('\\Demo\\Controllers'); $route->setPrefix('v1'); /* Add the route to the router */ $router->addRoute($route);","title":"Adding routes manually"},{"location":"routes/#extending","text":"This is a simple example of an integration into a framework. The framework has it's own Router class which inherits from the Course class. This allows the framework to add custom functionality like loading a custom routes.php file or add debugging information etc. namespace Demo; use Solital\\Core\\Course\\Course; class Router extends Course { public static function start() { // change default namespace for all routes parent::setDefaultNamespace('\\Demo\\Controllers'); // change this to whatever makes sense in your project require_once 'routes.php'; // Do initial stuff parent::start(); } }","title":"Extending"},{"location":"routes/#form-method-spoofing","text":"HTML forms do not support PUT , PATCH or DELETE actions. Therefore, when defining the PUT , PATCH or DELETE routes that are called from an HTML form, you will need to use the spoofing helper to add a hidden _method field to the form. The value sent with the _method field will be used as the HTTP request method: <form method=\"post\" action=\"{{ url() }}\"> {{ spoofing('put'); }} <!-- other input elements here --> </form>","title":"Form Method Spoofing"},{"location":"routes/#accessing-the-current-route","text":"You can access information about the current route loaded by using the following method: Course::request()->getLoadedRoute(); request()->getLoadedRoute();","title":"Accessing The Current Route"},{"location":"routes/#other-examples","text":"You can find many other examples in the sample file below: <?php use Solital\\Core\\Course\\Course; /* Adding custom csrfVerifier here */ Course::csrfVerifier(new \\Demo\\Middlewares\\CsrfVerifier()); Course::group(['middleware' => \\Demo\\Middlewares\\Site::class, 'exceptionHandler' => \\Demo\\Handlers\\CustomExceptionHandler::class], function() { Course::get('/answers/{id}', 'ControllerAnswers@show', ['where' => ['id' => '[0-9]+']]); /** * Restful resource (see IRestController interface for available methods) */ Course::resource('/rest', ControllerRessource::class); /** * Load the entire controller (where url matches method names - getIndex(), postIndex(), putIndex()). * The url paths will determine which method to render. * * For example: * * GET /animals => getIndex() * GET /animals/view => getView() * POST /animals/save => postSave() * * etc. */ Course::controller('/animals', ControllerAnimals::class); }); Course::get('/page/404', 'ControllerPage@notFound', ['as' => 'page.notfound']);","title":"Other examples"},{"location":"scanner/","text":"Solital has a component to check scripts containing codes with possible malware inserted. Usage To perform this check, you can use the command below: php vinci scanner Checking entire project The above command will scan files within the app/ folder. If you want a complete scan of the project, use the --all option. php vinci scanner --all","title":"Malware Scanner"},{"location":"scanner/#usage","text":"To perform this check, you can use the command below: php vinci scanner","title":"Usage"},{"location":"scanner/#checking-entire-project","text":"The above command will scan files within the app/ folder. If you want a complete scan of the project, use the --all option. php vinci scanner --all","title":"Checking entire project"},{"location":"schedule/","text":"Introduction Task scheduling is a commonly used technique for automating tasks based on a schedule. Such tasks may include backing up databases, processing a queue, or creating system usage reports, as they are required to be repeated regularly over time, or even indefinitely. It is better to schedule such tasks and monitor them so they can run predictably in a timely fashion. Usage First, you must analyze whether the default_timezone variable in the bootstrap.yaml file is configured correctly. Otherwise, the schedule may be executed incorrectly. To create a Schedule class, you must execute the following command entering the class name: php vinci schedule UserSchedule All schedules are stored in the app/Schedule folder. Schedule Structure The standard structure of a schedule is as follows: <?php namespace Solital\\Schedule; use Solital\\Core\\Schedule\\Schedule; use Solital\\Core\\Schedule\\ScheduleInterface; /** * @generated class generated using Vinci Console */ class UserSchedule extends Schedule implements ScheduleInterface { /** * Construct with schedule time */ public function __construct() { $this->time = \"everyMinute\"; } /** * @return mixed */ public function handle(): mixed { return $this; } } The code that will be executed must be inside the handle method. Changing the time To change the time that the schedule will run, you can change the $time property inside the constructor. public function __construct() { $this->time = \"everyMinute\"; } Solital makes use of the php-cron-scheduler component to schedule tasks. Therefore, you can access the documentation for that component to see the available options. To make things easier, you can use one of the options below: Option Description everyMinute Run every minute hourly Run once per hour daily Run once per day at('* * * * *') This method accepts any expression supported by dragonmantank/cron-expression Before job execution In some cases you might want to run some code, if the job is due to run, before it's being executed. For example you might want to add a log entry, ping a url or anything else. To do so, you can call the before like the example below. public function before() { // This code will be executed before the `handle` method } After job execution Sometime you might wish to do something after a job runs. The then methods provides you the flexibility to do anything you want after the job execution. The output of the job will be injected to this function. For example you might want to add an entry to you logs, ping a url etc public function after() { // This code will be executed after the `handle` method } Using a schedule in development mode If you need to use the task schedule when developing your project, use the php vinci schedule command passing the --work option. php vinci schedule --work When a schedule is executed, an output of that schedule is generated within the app/Storage/schedules/ folder. Using a schedule in production mode To run the task schedule in production mode, you must use the same command as above using the --run option. However, there are different ways to execute this command for each type of operating system. Linux Add a new entry to your crontab to run php vinci schedule every minute. * * * * * cd /path-to-your-project && php vinci schedule --run 1>> /dev/null 2>&1 That's it! Your scheduler is up and running, now you can add your jobs without worring anymore about the crontab. Windows Create a Scheduled Task Open Task Scheduler Select Create Task... Give the task a name and description To run the task in the background, select Run whether the user is logged on or not and check the Hidden checkbox. Triggers Create a new trigger. Set the trigger to run Daily and recur every 1 days. Set Repeat task every to 1 minutes . 1 minutes is not a selectable option. Simply select 5 minutes from the dropdown and then manually edit. Set for a duration of: to Indefinitely . Ensure that Enabled is checked. Actions Create a new action. Start php by entering the php binary location, such as C:\\php\\php.exe Set Add arguments field to C:\\{project-dir}\\vinci schedule --run (replace {project-dir} with appropriate path). Settings Check Allow task to be run on demand . Check Run task as soon as possible after a scheduled start is missed . Wrap-up To ensure that the task is running, find the task in the Task Scheduler Library . Note the task Status . It may be Ready or Running . Note the Next Run Time and Last Run Time properties.","title":"Task Schedule"},{"location":"schedule/#introduction","text":"Task scheduling is a commonly used technique for automating tasks based on a schedule. Such tasks may include backing up databases, processing a queue, or creating system usage reports, as they are required to be repeated regularly over time, or even indefinitely. It is better to schedule such tasks and monitor them so they can run predictably in a timely fashion.","title":"Introduction"},{"location":"schedule/#usage","text":"First, you must analyze whether the default_timezone variable in the bootstrap.yaml file is configured correctly. Otherwise, the schedule may be executed incorrectly. To create a Schedule class, you must execute the following command entering the class name: php vinci schedule UserSchedule All schedules are stored in the app/Schedule folder.","title":"Usage"},{"location":"schedule/#schedule-structure","text":"The standard structure of a schedule is as follows: <?php namespace Solital\\Schedule; use Solital\\Core\\Schedule\\Schedule; use Solital\\Core\\Schedule\\ScheduleInterface; /** * @generated class generated using Vinci Console */ class UserSchedule extends Schedule implements ScheduleInterface { /** * Construct with schedule time */ public function __construct() { $this->time = \"everyMinute\"; } /** * @return mixed */ public function handle(): mixed { return $this; } } The code that will be executed must be inside the handle method.","title":"Schedule Structure"},{"location":"schedule/#changing-the-time","text":"To change the time that the schedule will run, you can change the $time property inside the constructor. public function __construct() { $this->time = \"everyMinute\"; } Solital makes use of the php-cron-scheduler component to schedule tasks. Therefore, you can access the documentation for that component to see the available options. To make things easier, you can use one of the options below: Option Description everyMinute Run every minute hourly Run once per hour daily Run once per day at('* * * * *') This method accepts any expression supported by dragonmantank/cron-expression","title":"Changing the time"},{"location":"schedule/#before-job-execution","text":"In some cases you might want to run some code, if the job is due to run, before it's being executed. For example you might want to add a log entry, ping a url or anything else. To do so, you can call the before like the example below. public function before() { // This code will be executed before the `handle` method }","title":"Before job execution"},{"location":"schedule/#after-job-execution","text":"Sometime you might wish to do something after a job runs. The then methods provides you the flexibility to do anything you want after the job execution. The output of the job will be injected to this function. For example you might want to add an entry to you logs, ping a url etc public function after() { // This code will be executed after the `handle` method }","title":"After job execution"},{"location":"schedule/#using-a-schedule-in-development-mode","text":"If you need to use the task schedule when developing your project, use the php vinci schedule command passing the --work option. php vinci schedule --work When a schedule is executed, an output of that schedule is generated within the app/Storage/schedules/ folder.","title":"Using a schedule in development mode"},{"location":"schedule/#using-a-schedule-in-production-mode","text":"To run the task schedule in production mode, you must use the same command as above using the --run option. However, there are different ways to execute this command for each type of operating system.","title":"Using a schedule in production mode"},{"location":"schedule/#linux","text":"Add a new entry to your crontab to run php vinci schedule every minute. * * * * * cd /path-to-your-project && php vinci schedule --run 1>> /dev/null 2>&1 That's it! Your scheduler is up and running, now you can add your jobs without worring anymore about the crontab.","title":"Linux"},{"location":"schedule/#windows","text":"Create a Scheduled Task Open Task Scheduler Select Create Task... Give the task a name and description To run the task in the background, select Run whether the user is logged on or not and check the Hidden checkbox. Triggers Create a new trigger. Set the trigger to run Daily and recur every 1 days. Set Repeat task every to 1 minutes . 1 minutes is not a selectable option. Simply select 5 minutes from the dropdown and then manually edit. Set for a duration of: to Indefinitely . Ensure that Enabled is checked. Actions Create a new action. Start php by entering the php binary location, such as C:\\php\\php.exe Set Add arguments field to C:\\{project-dir}\\vinci schedule --run (replace {project-dir} with appropriate path). Settings Check Allow task to be run on demand . Check Run task as soon as possible after a scheduled start is missed . Wrap-up To ensure that the task is running, find the task in the Task Scheduler Library . Note the task Status . It may be Ready or Running . Note the Next Run Time and Last Run Time properties.","title":"Windows"},{"location":"secure-password/","text":"Introduction \u201cSince 2017, NIST recommends using a secret input when hashing memorized secrets such as passwords. By mixing in a secret input (commonly called a \"pepper\"), one prevents an attacker from brute-forcing the password hashes altogether, even if they have the hash and salt. For example, an SQL injection typically affects only the database, not files on disk, so a pepper stored in a config file would still be out of reach for the attacker. A pepper must be randomly generated once and can be the same for all users. Many password leaks could have been made completely useless if site owners had done this. Since there is no pepper parameter for password_hash (even though Argon2 has a \"secret\" parameter, PHP does not allow to set it), the correct way to mix in a pepper is to use hash_hmac().\u201d php.net How to use Solital uses the SecurePassword package to validate passwords and prevent attacks. That is, even if someone manages to access the hash created with this package, using only the native password_verify function WILL NOT return true . Solital has two password helpers: Generate password hash pass_hash($password, int $cost = 10) Checks the hash generated by the pass_hash helper pass_verify($password, string $hash) Unlike just using password_hash function, these helpers adds a secret entry (commonly called a pepper) to make it difficult to break the generated hash. Customizing the password To change the type of algorithm used in encryption, the cost, among other options, you can edit the auth.yaml file. password: algorithm: default # default - argon2 - argon2d pepper: b3f952d5d9adea6f63bee9d4c6fceeaa cost: 10 memory_cost: '' time_cost: '' threads: '' crypt_type: openssl wait_microseconds: 25000 In the algorithm key, you can add the following values: default , argon2 and argon2d . For more information about other PHP constants, see this link . Changing the value of \u201cpepper\u201d As mentioned in the introduction, the SecurePassword package uses a \u201cpepper\u201d value. To change the value of this pepper, you can edit the value of the peeper key in the auth.yaml file. However, it is recommended to use the APP_HASH variable. If this variable does not exist in your project, run the command php vinci generate:hash . If this variable is present in the .env file, then you can delete the peeper in the auth.yaml file. Don't change the value of this key too often, as you will need to create a new password each time this value changes. Change only if necessary or if your project is just starting. If you are using Solital Core >= 4.2, the `pepper` variable will not be present in the `auth.yaml` file. Instead, Solital will use the value of the `APP_HASH` variable. Changing Peeper encryption By default, peeper is encrypted using OpenSSL. You can switch to Sodium encryption by changing the value of the crypt_type variable in the auth.yaml file. crypt_type: sodium","title":"Secure Password"},{"location":"secure-password/#introduction","text":"\u201cSince 2017, NIST recommends using a secret input when hashing memorized secrets such as passwords. By mixing in a secret input (commonly called a \"pepper\"), one prevents an attacker from brute-forcing the password hashes altogether, even if they have the hash and salt. For example, an SQL injection typically affects only the database, not files on disk, so a pepper stored in a config file would still be out of reach for the attacker. A pepper must be randomly generated once and can be the same for all users. Many password leaks could have been made completely useless if site owners had done this. Since there is no pepper parameter for password_hash (even though Argon2 has a \"secret\" parameter, PHP does not allow to set it), the correct way to mix in a pepper is to use hash_hmac().\u201d php.net","title":"Introduction"},{"location":"secure-password/#how-to-use","text":"Solital uses the SecurePassword package to validate passwords and prevent attacks. That is, even if someone manages to access the hash created with this package, using only the native password_verify function WILL NOT return true . Solital has two password helpers: Generate password hash pass_hash($password, int $cost = 10) Checks the hash generated by the pass_hash helper pass_verify($password, string $hash) Unlike just using password_hash function, these helpers adds a secret entry (commonly called a pepper) to make it difficult to break the generated hash.","title":"How to use"},{"location":"secure-password/#customizing-the-password","text":"To change the type of algorithm used in encryption, the cost, among other options, you can edit the auth.yaml file. password: algorithm: default # default - argon2 - argon2d pepper: b3f952d5d9adea6f63bee9d4c6fceeaa cost: 10 memory_cost: '' time_cost: '' threads: '' crypt_type: openssl wait_microseconds: 25000 In the algorithm key, you can add the following values: default , argon2 and argon2d . For more information about other PHP constants, see this link .","title":"Customizing the password"},{"location":"secure-password/#changing-the-value-of-pepper","text":"As mentioned in the introduction, the SecurePassword package uses a \u201cpepper\u201d value. To change the value of this pepper, you can edit the value of the peeper key in the auth.yaml file. However, it is recommended to use the APP_HASH variable. If this variable does not exist in your project, run the command php vinci generate:hash . If this variable is present in the .env file, then you can delete the peeper in the auth.yaml file.","title":"Changing the value of \u201cpepper\u201d"},{"location":"secure-password/#changing-peeper-encryption","text":"By default, peeper is encrypted using OpenSSL. You can switch to Sodium encryption by changing the value of the crypt_type variable in the auth.yaml file. crypt_type: sodium","title":"Changing Peeper encryption"},{"location":"seeders/","text":"Introduction A seeder is a special class used to generate and insert sample data (seeds) into a database. This is an important feature in development environments, as it allows you to recreate the application with a fresh database, using sample values that you would otherwise have to manually enter each time the database was recreated. Creating Seeders To create a seeder, you will need to use the Vinci Console: php vinci create:seeder UserSeeder The command will generate a class similar to this: <?php use Solital\\Core\\Database\\Seeds\\Seeder; class UserSeed extends Seeder { /** * Run a Seed */ public function run() { // ... } } All code you create must be inside the run() method. Calling other Seeders You can call other seeders within a seeder. For that use the call() method. <?php use Solital\\Core\\Database\\Seeds\\Seeder; class UserSeed extends Seeder { /** * Run a Seed */ public function run() { $this->call(UserSecondSeed::class); $this->call(UserThirdSeed::class); } } Or use an array: public function run() { $this->call([ UserSecondSeed::class, UserThirdSeed::class ]); } Running Seeders To run the created Seeders, run the command: php vinci seeder The previous command runs all seeders. To run a specific seeder, use the --class option. php vinci seeder --class=UserSeeder","title":"Seeders"},{"location":"seeders/#introduction","text":"A seeder is a special class used to generate and insert sample data (seeds) into a database. This is an important feature in development environments, as it allows you to recreate the application with a fresh database, using sample values that you would otherwise have to manually enter each time the database was recreated.","title":"Introduction"},{"location":"seeders/#creating-seeders","text":"To create a seeder, you will need to use the Vinci Console: php vinci create:seeder UserSeeder The command will generate a class similar to this: <?php use Solital\\Core\\Database\\Seeds\\Seeder; class UserSeed extends Seeder { /** * Run a Seed */ public function run() { // ... } } All code you create must be inside the run() method.","title":"Creating Seeders"},{"location":"seeders/#calling-other-seeders","text":"You can call other seeders within a seeder. For that use the call() method. <?php use Solital\\Core\\Database\\Seeds\\Seeder; class UserSeed extends Seeder { /** * Run a Seed */ public function run() { $this->call(UserSecondSeed::class); $this->call(UserThirdSeed::class); } } Or use an array: public function run() { $this->call([ UserSecondSeed::class, UserThirdSeed::class ]); }","title":"Calling other Seeders"},{"location":"seeders/#running-seeders","text":"To run the created Seeders, run the command: php vinci seeder The previous command runs all seeders. To run a specific seeder, use the --class option. php vinci seeder --class=UserSeeder","title":"Running Seeders"},{"location":"session-and-cookie/","text":"Managing Cookies Static method This library provides a static method that is compatible to PHP\u2019s built-in setcookie(...) function but includes support for more recent features such as the SameSite attribute: use Solital\\Core\\Resource\\Cookie; Cookie::setcookie('SID', '31d4d96e407aad42'); // or Cookie::setcookie('SID', '31d4d96e407aad42', time() + 3600, '/~rasmus/', 'example.com', true, true, 'Lax'); Builder pattern Instances of the Cookie class let you build a cookie conveniently by setting individual properties. This class uses reasonable defaults that may differ from defaults of the setcookie function. $cookie = new Cookie('SID'); $cookie->setValue('31d4d96e407aad42'); $cookie->setMaxAge(60 * 60 * 24); // $cookie->setExpiryTime(time() + 60 * 60 * 24); $cookie->setPath('/~rasmus/'); $cookie->setDomain('example.com'); $cookie->setHttpOnly(true); $cookie->setSecureOnly(true); $cookie->setSameSiteRestriction('Strict'); // echo $cookie; // or $cookie->save(); // or // $cookie->saveAndSet(); The method calls can also be chained: (new Cookie('SID')) ->setValue('31d4d96e407aad42') ->setMaxAge(60 * 60 * 24) ->setSameSiteRestriction('None') ->save(); A cookie can later be deleted simply like this: $cookie->delete(); // or $cookie->deleteAndUnset(); Note: For the deletion to work, the cookie must have the same settings as the cookie that was originally saved \u2013 except for its value, which doesn\u2019t need to be set. So you should remember to pass appropriate values to setPath(...) , setDomain(...) , setHttpOnly(...) and setSecureOnly(...) again. Reading cookies Checking whether a cookie exists: Cookie::exists('first_visit'); Reading a cookie\u2019s value (with optional default value): Cookie::get('first_visit'); // or Cookie::get('first_visit', \\time()); Parsing cookies $cookieHeader = 'Set-Cookie: test=php.net; expires=Thu, 09-Jun-2016 16:30:32 GMT; Max-Age=3600; path=/~rasmus/; secure'; $cookieInstance = Cookie::parse($cookieHeader); Managing Sessions Using the Session class, you can start and resume sessions in a way that is compatible to PHP\u2019s built-in session_start() function, while having access to the improved cookie handling from this library as well: use Solital\\Core\\Resource\\Session; // start session and have session cookie with 'lax' same-site restriction Session::start(); // or Session::start('Lax'); // start session and have session cookie with 'strict' same-site restriction Session::start('Strict'); // start session and have session cookie without any same-site restriction Session::start(null); // or Session::start('None'); // Chrome 80+ All three calls respect the settings from PHP\u2019s session_set_cookie_params(...) function and the configuration options session.name , session.cookie_lifetime , session.cookie_path , session.cookie_domain , session.cookie_secure , session.cookie_httponly and session.use_cookies . Likewise, replacements for session_regenerate_id(); // and session_regenerate_id(true); are available via Session::regenerate(); // and Session::regenerate(true); if you want protection against session fixation attacks that comes with improved cookie handling. Additionally, access to the current internal session ID is provided via Session::id(); as a replacement for session_id(); Reading and writing session data Read a value from the session (with optional default value): $value = Session::get($key); # With helper $value = session($key); // or $value = Session::get($key, $defaultValue); # With helper $value = session($key, defaultValue: 'default_value'); Write a value to the session: Session::set($key, $value); # With helper session($key, $value); Check whether a value exists in the session: if (Session::has($key)) { // ... } Remove a value from the session: Session::delete($key); # With helper session($key, delete: true); Read and then immediately remove a value from the session: $value = Session::take($key); $value = Session::take($key, $defaultValue); # With helper $value = session($key, take: true); This is often useful for flash messages, e.g. in combination with the has(...) method.","title":"Session and Cookie"},{"location":"session-and-cookie/#managing-cookies","text":"","title":"Managing Cookies"},{"location":"session-and-cookie/#static-method","text":"This library provides a static method that is compatible to PHP\u2019s built-in setcookie(...) function but includes support for more recent features such as the SameSite attribute: use Solital\\Core\\Resource\\Cookie; Cookie::setcookie('SID', '31d4d96e407aad42'); // or Cookie::setcookie('SID', '31d4d96e407aad42', time() + 3600, '/~rasmus/', 'example.com', true, true, 'Lax');","title":"Static method"},{"location":"session-and-cookie/#builder-pattern","text":"Instances of the Cookie class let you build a cookie conveniently by setting individual properties. This class uses reasonable defaults that may differ from defaults of the setcookie function. $cookie = new Cookie('SID'); $cookie->setValue('31d4d96e407aad42'); $cookie->setMaxAge(60 * 60 * 24); // $cookie->setExpiryTime(time() + 60 * 60 * 24); $cookie->setPath('/~rasmus/'); $cookie->setDomain('example.com'); $cookie->setHttpOnly(true); $cookie->setSecureOnly(true); $cookie->setSameSiteRestriction('Strict'); // echo $cookie; // or $cookie->save(); // or // $cookie->saveAndSet(); The method calls can also be chained: (new Cookie('SID')) ->setValue('31d4d96e407aad42') ->setMaxAge(60 * 60 * 24) ->setSameSiteRestriction('None') ->save(); A cookie can later be deleted simply like this: $cookie->delete(); // or $cookie->deleteAndUnset(); Note: For the deletion to work, the cookie must have the same settings as the cookie that was originally saved \u2013 except for its value, which doesn\u2019t need to be set. So you should remember to pass appropriate values to setPath(...) , setDomain(...) , setHttpOnly(...) and setSecureOnly(...) again.","title":"Builder pattern"},{"location":"session-and-cookie/#reading-cookies","text":"Checking whether a cookie exists: Cookie::exists('first_visit'); Reading a cookie\u2019s value (with optional default value): Cookie::get('first_visit'); // or Cookie::get('first_visit', \\time());","title":"Reading cookies"},{"location":"session-and-cookie/#parsing-cookies","text":"$cookieHeader = 'Set-Cookie: test=php.net; expires=Thu, 09-Jun-2016 16:30:32 GMT; Max-Age=3600; path=/~rasmus/; secure'; $cookieInstance = Cookie::parse($cookieHeader);","title":"Parsing cookies"},{"location":"session-and-cookie/#managing-sessions","text":"Using the Session class, you can start and resume sessions in a way that is compatible to PHP\u2019s built-in session_start() function, while having access to the improved cookie handling from this library as well: use Solital\\Core\\Resource\\Session; // start session and have session cookie with 'lax' same-site restriction Session::start(); // or Session::start('Lax'); // start session and have session cookie with 'strict' same-site restriction Session::start('Strict'); // start session and have session cookie without any same-site restriction Session::start(null); // or Session::start('None'); // Chrome 80+ All three calls respect the settings from PHP\u2019s session_set_cookie_params(...) function and the configuration options session.name , session.cookie_lifetime , session.cookie_path , session.cookie_domain , session.cookie_secure , session.cookie_httponly and session.use_cookies . Likewise, replacements for session_regenerate_id(); // and session_regenerate_id(true); are available via Session::regenerate(); // and Session::regenerate(true); if you want protection against session fixation attacks that comes with improved cookie handling. Additionally, access to the current internal session ID is provided via Session::id(); as a replacement for session_id();","title":"Managing Sessions"},{"location":"session-and-cookie/#reading-and-writing-session-data","text":"Read a value from the session (with optional default value): $value = Session::get($key); # With helper $value = session($key); // or $value = Session::get($key, $defaultValue); # With helper $value = session($key, defaultValue: 'default_value'); Write a value to the session: Session::set($key, $value); # With helper session($key, $value); Check whether a value exists in the session: if (Session::has($key)) { // ... } Remove a value from the session: Session::delete($key); # With helper session($key, delete: true); Read and then immediately remove a value from the session: $value = Session::take($key); $value = Session::take($key, $defaultValue); # With helper $value = session($key, take: true); This is often useful for flash messages, e.g. in combination with the has(...) method.","title":"Reading and writing session data"},{"location":"string-manipulate/","text":"Introduction PHP has several functions to manipulate strings procedurally. However, this can be a hassle when it comes to using multiple functions to manipulate a single string. The situation gets worse when you have multibyte characters, as you will have to switch between functions. $text = 'Something to translate'; $text = strtr($text, $translation); $text = htmlspecialchars($text); $text = nl2br($text); echo $text; The Str component allows you to perform these same functions using OOP. This will make living with PHP strings easier by: providing a simple chained API to string operations not mixing up the needle haystack stuff allowing you to extend and add your own methods in seconds How to use Below is an example of how to perform the functions in the previous example using the Str component: use Solital\\Core\\Resource\\Str\\Str; $str = new Str('Something to translate'); $str->translate([\"translate\" => \"another language\"]) $str->specialchars() $str->nl2br(); echo $str->value(); // Or use `__toString()` echo $str; If you don't want to create a new instance, you can use the str() helper: echo str('Something to translate') ->translate([\"translate\" => \"another language\"]) ->specialchars() ->nl2br(); The Str class is fully compatible with multibyte characters. Chained methods The methods below must be used by creating an instance of the Str class. value() Returns the current value of this string $str = new Str('foo'); echo $str->value(); after() Get the string after the first occurence of the substring. $str = new Str(\"This is a test\"); $str->after(\"This is\"); echo $str->value(); before() Get the string before the first occurence of the substring. $str = new Str(\"This is a test\"); $str->before(\"a test\"); echo $str->value(); addCslashes() Quote string with slashes in a C style $str = new Str('testescape'); $str->addCslashes('acep'); echo $str->value(); addSlashes() Quote string with slashes $str = new Str(\"aa'bb\"); $str->addSlashes(); echo $str->value(); chunkSplit() Splits the string into smaller chunks $str = new Str('foobar'); $str->chunkSplit(2, ':'); echo $str->value(); concat() Appends another string to this string. $str = new Str('foo'); $str->concat('bar'); echo $str->value(); ireplace() Case-insensitive version of Str::replace(). $str = new Str('foo=bar'); $str->ireplace(['FOO' => 'bar']); echo $str->value(); ltrim() Strip whitespace (or other characters) from the beginning of a string. $str = new Str('_-_foo'); $str->ltrim('_-'); echo $str->value(); nl2br() Converts new lines to <br /> elements. $str = new Str([\"foo\\nbar\" . PHP_EOL, \"foo<br />\\nbar<br />\" . PHP_EOL]); $str->nl2br(); echo $str->value(); pad() Pad the string to a certain length with another string. $pad_length : If the value of pad_length is negative, less than, or equal to the length of current string, no padding takes place $pad_string : String to pad the current string with $pad_type : Optional, can be STR_PAD_RIGHT , STR_PAD_LEFT , or STR_PAD_BOTH . If $pad_type is not specified it is assumed to be STR_PAD_RIGHT $str = new Str('foo'); $str->pad(16, '-.-;', STR_PAD_RIGHT); echo $str->value(); removeAccents() Replace characters with accents with normal characters. $str = new Str(\"\u00e0\u00e8\u00ec\u00d2\"); $str->removeAccents(); echo $str->value(); repeat() Repeats the string. $str = new Str('foo'); $str->repeat(5); echo $str->value(); replace() Replaces the occurences of keys with their values. $str = new Str('foo can be bar but foo does not have to'); $str->replace(['foo' => 'fOo', 'DoEs Not' => 'fail', 'to' => '2']); echo $str->value(); reverse() Reverses current string. $str = new Str('knitS raW pupilS regaL'); $str->reverse(); echo $str->value(); rot13() Perform the ROT13 transform on current string. The ROT13 encoding simply shifts every letter by 13 places in the alphabet while leaving non-alpha characters untouched. Encoding and decoding are done by the same function, passing an encoded string as argument will return the original version. $str = new Str('foobar'); $str->rot13(); echo $str->value(); rtrim() Strip whitespace (or other characters) from the end. $str = new Str('ofoooooo'); $str->rtrim('o'); echo $str->value(); shorten() Truncate String (shorten) with or without ellipsis. $str = new Str('foo bar foobar pebkac fubar'); $str->shorten(10); echo $str->value(); shuffle() Randomly shuffles the string. $str = new Str('foo bar foobar pebkac fubar'); $original = $str->value(); $str->shuffle(); echo $str->value(); echo $original; slug() Generate a URL friendly slug from the given string. $str = new Str('foo bar foobar pebkac fubar'); $str->slug(); echo $str->value(); specialchars() Convert special characters to HTML entities. $decode : If true , convert special HTML entities back to characters. $str = new Str('<p>This should <br>not be wrapped</p>'); $str->specialchars(); echo $str->value(); stripTags() Strip HTML and PHP tags. $allowable_tags : List of allowed tags. $str = new Str('<html><div><p><br/><br></p></div></html>'); $str->stripTags(); echo $str->value(); translate() Translate characters or replace substrings. $str = new Str(':foo :bar'); $str->translate([':foo' => ':bar', ':bar' => ':newbar']); echo $str->value(); trim() Strips whitespace (or other characters) from the beginning and end of the string. $str = new Str('offsoooooo'); $str->trim('o'); echo $str->value(); toUpper() Make a string uppercase. $str = new Str('my string'); $str->toUpper(); echo $str->value(); toLower() Make a string uppercase. $str = new Str('MY STRING'); $str->toLower(); echo $str->value(); undo() Undoes the last $steps operations. $str = new Str(' foo is bar '); $str->rtrim(); $str->ltrim(); $str->replace(array(' is ' => '_is_')); $str->undo(1); echo $str->value(); Not chainable methods The methods below must be used statically. compare() Binary safe string comparison. < 0 if this string is less than target string > 0 if this string is greater than target string == 0 if both strings are equal echo Str::compare('my_string', 'mystring'); compareInsensitive() Binary safe case-insensitive string comparison. < 0 if this string is less than target string > 0 if this string is greater than target string == 0 if both strings are equal echo Str::compareInsensitive('my_string', 'mystring'); contains() Does current string contain a subtring? echo Str::contains('my_string', 'string'); countChars() Return information about characters used in a string. $res = Str::countChars('abababcabc'); pre($res); endsWith() Checks if haystack ends with needle echo Str::endsWith('foo is bar sometimes', 'sometimes'); position() Find the position of the first occurrence of a substring in a string. echo Str::position('foo is bar sometimes', ' is ', 0); startsWith() Checks if haystack begins with needle echo Str::startsWith('foo is bar sometimes', 'foo'); uniqueChars() Returns a string containing all unique characters (in current string). echo Str::uniqueChars('abcabdabcd'); wordCount() Counts the number of words inside string. $charlist : Optional list of additional characters which will be considered as 'word'. echo Str::wordCount('foo is here 3 times foo foo'); word() Returns the list of words inside string. $charlist : Optional list of additional characters which will be considered as 'word'. echo Str::word('foo foo bar foo');","title":"Strings"},{"location":"string-manipulate/#introduction","text":"PHP has several functions to manipulate strings procedurally. However, this can be a hassle when it comes to using multiple functions to manipulate a single string. The situation gets worse when you have multibyte characters, as you will have to switch between functions. $text = 'Something to translate'; $text = strtr($text, $translation); $text = htmlspecialchars($text); $text = nl2br($text); echo $text; The Str component allows you to perform these same functions using OOP. This will make living with PHP strings easier by: providing a simple chained API to string operations not mixing up the needle haystack stuff allowing you to extend and add your own methods in seconds","title":"Introduction"},{"location":"string-manipulate/#how-to-use","text":"Below is an example of how to perform the functions in the previous example using the Str component: use Solital\\Core\\Resource\\Str\\Str; $str = new Str('Something to translate'); $str->translate([\"translate\" => \"another language\"]) $str->specialchars() $str->nl2br(); echo $str->value(); // Or use `__toString()` echo $str; If you don't want to create a new instance, you can use the str() helper: echo str('Something to translate') ->translate([\"translate\" => \"another language\"]) ->specialchars() ->nl2br(); The Str class is fully compatible with multibyte characters.","title":"How to use"},{"location":"string-manipulate/#chained-methods","text":"The methods below must be used by creating an instance of the Str class.","title":"Chained methods"},{"location":"string-manipulate/#value","text":"Returns the current value of this string $str = new Str('foo'); echo $str->value();","title":"value()"},{"location":"string-manipulate/#after","text":"Get the string after the first occurence of the substring. $str = new Str(\"This is a test\"); $str->after(\"This is\"); echo $str->value();","title":"after()"},{"location":"string-manipulate/#before","text":"Get the string before the first occurence of the substring. $str = new Str(\"This is a test\"); $str->before(\"a test\"); echo $str->value();","title":"before()"},{"location":"string-manipulate/#addcslashes","text":"Quote string with slashes in a C style $str = new Str('testescape'); $str->addCslashes('acep'); echo $str->value();","title":"addCslashes()"},{"location":"string-manipulate/#addslashes","text":"Quote string with slashes $str = new Str(\"aa'bb\"); $str->addSlashes(); echo $str->value();","title":"addSlashes()"},{"location":"string-manipulate/#chunksplit","text":"Splits the string into smaller chunks $str = new Str('foobar'); $str->chunkSplit(2, ':'); echo $str->value();","title":"chunkSplit()"},{"location":"string-manipulate/#concat","text":"Appends another string to this string. $str = new Str('foo'); $str->concat('bar'); echo $str->value();","title":"concat()"},{"location":"string-manipulate/#ireplace","text":"Case-insensitive version of Str::replace(). $str = new Str('foo=bar'); $str->ireplace(['FOO' => 'bar']); echo $str->value();","title":"ireplace()"},{"location":"string-manipulate/#ltrim","text":"Strip whitespace (or other characters) from the beginning of a string. $str = new Str('_-_foo'); $str->ltrim('_-'); echo $str->value();","title":"ltrim()"},{"location":"string-manipulate/#nl2br","text":"Converts new lines to <br /> elements. $str = new Str([\"foo\\nbar\" . PHP_EOL, \"foo<br />\\nbar<br />\" . PHP_EOL]); $str->nl2br(); echo $str->value();","title":"nl2br()"},{"location":"string-manipulate/#pad","text":"Pad the string to a certain length with another string. $pad_length : If the value of pad_length is negative, less than, or equal to the length of current string, no padding takes place $pad_string : String to pad the current string with $pad_type : Optional, can be STR_PAD_RIGHT , STR_PAD_LEFT , or STR_PAD_BOTH . If $pad_type is not specified it is assumed to be STR_PAD_RIGHT $str = new Str('foo'); $str->pad(16, '-.-;', STR_PAD_RIGHT); echo $str->value();","title":"pad()"},{"location":"string-manipulate/#removeaccents","text":"Replace characters with accents with normal characters. $str = new Str(\"\u00e0\u00e8\u00ec\u00d2\"); $str->removeAccents(); echo $str->value();","title":"removeAccents()"},{"location":"string-manipulate/#repeat","text":"Repeats the string. $str = new Str('foo'); $str->repeat(5); echo $str->value();","title":"repeat()"},{"location":"string-manipulate/#replace","text":"Replaces the occurences of keys with their values. $str = new Str('foo can be bar but foo does not have to'); $str->replace(['foo' => 'fOo', 'DoEs Not' => 'fail', 'to' => '2']); echo $str->value();","title":"replace()"},{"location":"string-manipulate/#reverse","text":"Reverses current string. $str = new Str('knitS raW pupilS regaL'); $str->reverse(); echo $str->value();","title":"reverse()"},{"location":"string-manipulate/#rot13","text":"Perform the ROT13 transform on current string. The ROT13 encoding simply shifts every letter by 13 places in the alphabet while leaving non-alpha characters untouched. Encoding and decoding are done by the same function, passing an encoded string as argument will return the original version. $str = new Str('foobar'); $str->rot13(); echo $str->value();","title":"rot13()"},{"location":"string-manipulate/#rtrim","text":"Strip whitespace (or other characters) from the end. $str = new Str('ofoooooo'); $str->rtrim('o'); echo $str->value();","title":"rtrim()"},{"location":"string-manipulate/#shorten","text":"Truncate String (shorten) with or without ellipsis. $str = new Str('foo bar foobar pebkac fubar'); $str->shorten(10); echo $str->value();","title":"shorten()"},{"location":"string-manipulate/#shuffle","text":"Randomly shuffles the string. $str = new Str('foo bar foobar pebkac fubar'); $original = $str->value(); $str->shuffle(); echo $str->value(); echo $original;","title":"shuffle()"},{"location":"string-manipulate/#slug","text":"Generate a URL friendly slug from the given string. $str = new Str('foo bar foobar pebkac fubar'); $str->slug(); echo $str->value();","title":"slug()"},{"location":"string-manipulate/#specialchars","text":"Convert special characters to HTML entities. $decode : If true , convert special HTML entities back to characters. $str = new Str('<p>This should <br>not be wrapped</p>'); $str->specialchars(); echo $str->value();","title":"specialchars()"},{"location":"string-manipulate/#striptags","text":"Strip HTML and PHP tags. $allowable_tags : List of allowed tags. $str = new Str('<html><div><p><br/><br></p></div></html>'); $str->stripTags(); echo $str->value();","title":"stripTags()"},{"location":"string-manipulate/#translate","text":"Translate characters or replace substrings. $str = new Str(':foo :bar'); $str->translate([':foo' => ':bar', ':bar' => ':newbar']); echo $str->value();","title":"translate()"},{"location":"string-manipulate/#trim","text":"Strips whitespace (or other characters) from the beginning and end of the string. $str = new Str('offsoooooo'); $str->trim('o'); echo $str->value();","title":"trim()"},{"location":"string-manipulate/#toupper","text":"Make a string uppercase. $str = new Str('my string'); $str->toUpper(); echo $str->value();","title":"toUpper()"},{"location":"string-manipulate/#tolower","text":"Make a string uppercase. $str = new Str('MY STRING'); $str->toLower(); echo $str->value();","title":"toLower()"},{"location":"string-manipulate/#undo","text":"Undoes the last $steps operations. $str = new Str(' foo is bar '); $str->rtrim(); $str->ltrim(); $str->replace(array(' is ' => '_is_')); $str->undo(1); echo $str->value();","title":"undo()"},{"location":"string-manipulate/#not-chainable-methods","text":"The methods below must be used statically.","title":"Not chainable methods"},{"location":"string-manipulate/#compare","text":"Binary safe string comparison. < 0 if this string is less than target string > 0 if this string is greater than target string == 0 if both strings are equal echo Str::compare('my_string', 'mystring');","title":"compare()"},{"location":"string-manipulate/#compareinsensitive","text":"Binary safe case-insensitive string comparison. < 0 if this string is less than target string > 0 if this string is greater than target string == 0 if both strings are equal echo Str::compareInsensitive('my_string', 'mystring');","title":"compareInsensitive()"},{"location":"string-manipulate/#contains","text":"Does current string contain a subtring? echo Str::contains('my_string', 'string');","title":"contains()"},{"location":"string-manipulate/#countchars","text":"Return information about characters used in a string. $res = Str::countChars('abababcabc'); pre($res);","title":"countChars()"},{"location":"string-manipulate/#endswith","text":"Checks if haystack ends with needle echo Str::endsWith('foo is bar sometimes', 'sometimes');","title":"endsWith()"},{"location":"string-manipulate/#position","text":"Find the position of the first occurrence of a substring in a string. echo Str::position('foo is bar sometimes', ' is ', 0);","title":"position()"},{"location":"string-manipulate/#startswith","text":"Checks if haystack begins with needle echo Str::startsWith('foo is bar sometimes', 'foo');","title":"startsWith()"},{"location":"string-manipulate/#uniquechars","text":"Returns a string containing all unique characters (in current string). echo Str::uniqueChars('abcabdabcd');","title":"uniqueChars()"},{"location":"string-manipulate/#wordcount","text":"Counts the number of words inside string. $charlist : Optional list of additional characters which will be considered as 'word'. echo Str::wordCount('foo is here 3 times foo foo');","title":"wordCount()"},{"location":"string-manipulate/#word","text":"Returns the list of words inside string. $charlist : Optional list of additional characters which will be considered as 'word'. echo Str::word('foo foo bar foo');","title":"word()"},{"location":"upgrade-guide/","text":"Upgrading from version 3.x to 4.x composer.json Update the Core package in your composer.json file: \"solital/core\": \"4.*\" .env These variables below will no longer be used in version 4.x , so they should be removed. INDEX_LOGIN=\"solital_index_login\" PRODUCTION_MODE=\"false\" config.php In the config.php file, add the constant SITE_ROOT at the beginning of the file, and replace the line below: $dotenv = Dotenv\\Dotenv::createUnsafeImmutable(__DIR__); $dotenv->load(); For this: use Solital\\Core\\Kernel\\Dotenv; Dotenv::env(__DIR__); The config.php file should be as follows: <?php define('SITE_ROOT', __DIR__); require_once 'vendor/autoload.php'; use Solital\\Core\\Kernel\\Application; use Solital\\Core\\Kernel\\Dotenv; Application::sessionInit(); Dotenv::env(__DIR__); if (!empty(getenv('ERRORS_DISPLAY'))) { if (getenv('ERRORS_DISPLAY') == 'true') { ini_set('display_errors', 1); error_reporting(E_ALL); } } User command Find the Config class inside the app/Console/ folder and change the getCommandClass() method: public function getCommandClass(): array { $this->command_class = Application::getUserCommands(); return $this->command_class; } index.php First, locate the file inside the public/ folder. The index.php file has few changes. The only things you need to do are: remove the constant SITE_ROOT as it will already exist in the config.php file, and replace the line below: Course::csrfVerifier(new BaseCsrfVerifier()); For this: Application::loadCsrfVerifier(); The index.php file should be as follows: <?php require_once dirname(__DIR__). '/vendor/autoload.php'; use Solital\\Core\\Course\\Course; use Solital\\Core\\Kernel\\Application; Application::autoload(\"../vendor/solital/core/src/Resource/Helpers/\"); Course::setDefaultNamespace('\\Solital\\Components\\Controller'); Application::loadCsrfVerifier(); Application::autoload(\"../routers/\"); Application::init(); Copying new files After all these changes, you will need to run the following command: php vinci generate:files This command will copy configuration files into the app/config folder. This command should be executed whenever there is an important update. Checking Solital Version To verify that the update was successful, run php vinci version to see the Core version. Also, run php vinci server to check on the splash screen that everything is working.","title":"Upgrade Guide"},{"location":"upgrade-guide/#upgrading-from-version-3x-to-4x","text":"","title":"Upgrading from version 3.x to 4.x"},{"location":"upgrade-guide/#composerjson","text":"Update the Core package in your composer.json file: \"solital/core\": \"4.*\"","title":"composer.json"},{"location":"upgrade-guide/#env","text":"These variables below will no longer be used in version 4.x , so they should be removed. INDEX_LOGIN=\"solital_index_login\" PRODUCTION_MODE=\"false\"","title":".env"},{"location":"upgrade-guide/#configphp","text":"In the config.php file, add the constant SITE_ROOT at the beginning of the file, and replace the line below: $dotenv = Dotenv\\Dotenv::createUnsafeImmutable(__DIR__); $dotenv->load(); For this: use Solital\\Core\\Kernel\\Dotenv; Dotenv::env(__DIR__); The config.php file should be as follows: <?php define('SITE_ROOT', __DIR__); require_once 'vendor/autoload.php'; use Solital\\Core\\Kernel\\Application; use Solital\\Core\\Kernel\\Dotenv; Application::sessionInit(); Dotenv::env(__DIR__); if (!empty(getenv('ERRORS_DISPLAY'))) { if (getenv('ERRORS_DISPLAY') == 'true') { ini_set('display_errors', 1); error_reporting(E_ALL); } }","title":"config.php"},{"location":"upgrade-guide/#user-command","text":"Find the Config class inside the app/Console/ folder and change the getCommandClass() method: public function getCommandClass(): array { $this->command_class = Application::getUserCommands(); return $this->command_class; }","title":"User command"},{"location":"upgrade-guide/#indexphp","text":"First, locate the file inside the public/ folder. The index.php file has few changes. The only things you need to do are: remove the constant SITE_ROOT as it will already exist in the config.php file, and replace the line below: Course::csrfVerifier(new BaseCsrfVerifier()); For this: Application::loadCsrfVerifier(); The index.php file should be as follows: <?php require_once dirname(__DIR__). '/vendor/autoload.php'; use Solital\\Core\\Course\\Course; use Solital\\Core\\Kernel\\Application; Application::autoload(\"../vendor/solital/core/src/Resource/Helpers/\"); Course::setDefaultNamespace('\\Solital\\Components\\Controller'); Application::loadCsrfVerifier(); Application::autoload(\"../routers/\"); Application::init();","title":"index.php"},{"location":"upgrade-guide/#copying-new-files","text":"After all these changes, you will need to run the following command: php vinci generate:files This command will copy configuration files into the app/config folder. This command should be executed whenever there is an important update.","title":"Copying new files"},{"location":"upgrade-guide/#checking-solital-version","text":"To verify that the update was successful, run php vinci version to see the Core version. Also, run php vinci server to check on the splash screen that everything is working.","title":"Checking Solital Version"},{"location":"url/","text":"By default, all controller and resource routes will use a simplified version of their url as name. You easily use the url() shortcut helper function to retrieve urls for your routes or manipulate the current url. url() will return a Uri object which will return a string when rendered, so it can be used safely in templates etc. but contains all the useful helpers methods in the Uri class like contains , indexOf etc. Check the Useful url tricks below. Get the current url It has never been easier to get and/or manipulate the current url. The example below shows you how to get the current url: # output: /current-url url(); Get by name (single route) Course::get('/product-view/{id}', 'ProductsController@show', ['as' => 'product']); # output: /product-view/22/?category=shoes url('product', ['id' => 22], ['category' => 'shoes']); # output: /product-view/?category=shoes url('product', null, ['category' => 'shoes']); Get by name (controller route) Course::controller('/images', ImagesController::class, ['as' => 'picture']); # output: /images/view/?category=shows url('picture@getView', null, ['category' => 'shoes']); # output: /images/view/?category=shows url('picture', 'getView', ['category' => 'shoes']); # output: /images/view/ url('picture', 'view'); Get by class Course::get('/product-view/{id}', 'ProductsController@show', ['as' => 'product']); Course::controller('/images', 'ImagesController'); # output: /product-view/22/?category=shoes url('ProductsController@show', ['id' => 22], ['category' => 'shoes']); # output: /images/image/?id=22 url('ImagesController@getImage', null, ['id' => 22]); Using custom names for methods on a controller/resource route Course::controller('gadgets', GadgetsController::class, ['names' => ['getIphoneInfo' => 'iphone']]); url('gadgets.iphone'); # output # /gadgets/iphoneinfo/ Getting REST/resource controller urls Course::resource('/phones', PhonesController::class); # output: /phones/ url('phones'); # output: /phones/ url('phones.index'); # output: /phones/create/ url('phones.create'); # output: /phones/edit/ url('phones.edit'); Manipulating url You can easily manipulate the query-strings, by adding your get param arguments. # output: /current-url?q=cars url(null, null, ['q' => 'cars']); You can remove a query-string parameter by setting the value to null . The example below will remove any query-string parameter named q from the url but keep all others query-string parameters: $url = url()->removeParam('q'); Useful url tricks Calling url will always return a Url object. Upon rendered it will return a string of the relative url , so it's safe to use in templates etc. However this allow us to use the useful methods on the Url object like indexOf and contains or retrieve specific parts of the url like the path, querystring parameters, host etc. You can also manipulate the url like removing- or adding parameters, changing host and more. In the example below, we check if the current url contains the /api part. if(url()->contains('/api')) { // ... do stuff } As mentioned earlier, you can also use the Uri object to show specific parts of the url or control what part of the url you want. # Grab the query-string parameter id from the current-url. $id = url()->getParam('id'); # Get the absolute url for the current url. $absoluteUrl = url()->getAbsoluteUrl(); For more available methods please check the Uri class.","title":"URL"},{"location":"url/#get-the-current-url","text":"It has never been easier to get and/or manipulate the current url. The example below shows you how to get the current url: # output: /current-url url();","title":"Get the current url"},{"location":"url/#get-by-name-single-route","text":"Course::get('/product-view/{id}', 'ProductsController@show', ['as' => 'product']); # output: /product-view/22/?category=shoes url('product', ['id' => 22], ['category' => 'shoes']); # output: /product-view/?category=shoes url('product', null, ['category' => 'shoes']);","title":"Get by name (single route)"},{"location":"url/#get-by-name-controller-route","text":"Course::controller('/images', ImagesController::class, ['as' => 'picture']); # output: /images/view/?category=shows url('picture@getView', null, ['category' => 'shoes']); # output: /images/view/?category=shows url('picture', 'getView', ['category' => 'shoes']); # output: /images/view/ url('picture', 'view');","title":"Get by name (controller route)"},{"location":"url/#get-by-class","text":"Course::get('/product-view/{id}', 'ProductsController@show', ['as' => 'product']); Course::controller('/images', 'ImagesController'); # output: /product-view/22/?category=shoes url('ProductsController@show', ['id' => 22], ['category' => 'shoes']); # output: /images/image/?id=22 url('ImagesController@getImage', null, ['id' => 22]);","title":"Get by class"},{"location":"url/#using-custom-names-for-methods-on-a-controllerresource-route","text":"Course::controller('gadgets', GadgetsController::class, ['names' => ['getIphoneInfo' => 'iphone']]); url('gadgets.iphone'); # output # /gadgets/iphoneinfo/","title":"Using custom names for methods on a controller/resource route"},{"location":"url/#getting-restresource-controller-urls","text":"Course::resource('/phones', PhonesController::class); # output: /phones/ url('phones'); # output: /phones/ url('phones.index'); # output: /phones/create/ url('phones.create'); # output: /phones/edit/ url('phones.edit');","title":"Getting REST/resource controller urls"},{"location":"url/#manipulating-url","text":"You can easily manipulate the query-strings, by adding your get param arguments. # output: /current-url?q=cars url(null, null, ['q' => 'cars']); You can remove a query-string parameter by setting the value to null . The example below will remove any query-string parameter named q from the url but keep all others query-string parameters: $url = url()->removeParam('q');","title":"Manipulating url"},{"location":"url/#useful-url-tricks","text":"Calling url will always return a Url object. Upon rendered it will return a string of the relative url , so it's safe to use in templates etc. However this allow us to use the useful methods on the Url object like indexOf and contains or retrieve specific parts of the url like the path, querystring parameters, host etc. You can also manipulate the url like removing- or adding parameters, changing host and more. In the example below, we check if the current url contains the /api part. if(url()->contains('/api')) { // ... do stuff } As mentioned earlier, you can also use the Uri object to show specific parts of the url or control what part of the url you want. # Grab the query-string parameter id from the current-url. $id = url()->getParam('id'); # Get the absolute url for the current url. $absoluteUrl = url()->getAbsoluteUrl(); For more available methods please check the Uri class.","title":"Useful url tricks"},{"location":"validation-component/","text":"This class is deprecated and removed in Core 4.4. Please use the Validation class You can validate email, string, array and others. Email $res = Valid::email('solital@email.com'); /* Return `string` if true or `null` if false */ pre($res); Number You can validate whether a number is int or float . $res = Valid::number(12.5); /* Return `int` or `float` if true or `null` if false */ pre($res); Null $res = Valid::isNull(null); /* Return bool */ pre($res); Lowercase You can validate a string if it is lowercase. If not, the isLower method will convert the string to lowercase. $res = Valid::isLower('SOLITAL'); /* Return string */ pre($res); Uppercase You can validate a string if it is uppercase. If not, the isUpper method will convert the string to uppercase. $res = Valid::isUpper('solital'); /* Return string */ pre($res); Base64 Checks whether a variable is Base64-type encryption. $hash = base64_encode(\"test\"); $res = Valid::isBase64($hash); /* Return bool */ pre($res); Identical Checks if one variable is identical to another. $res = Valid::identical(\"foo\", \"foo\"); /* Return bool */ pre($res);","title":"Validation component"},{"location":"validation-component/#email","text":"$res = Valid::email('solital@email.com'); /* Return `string` if true or `null` if false */ pre($res);","title":"Email"},{"location":"validation-component/#number","text":"You can validate whether a number is int or float . $res = Valid::number(12.5); /* Return `int` or `float` if true or `null` if false */ pre($res);","title":"Number"},{"location":"validation-component/#null","text":"$res = Valid::isNull(null); /* Return bool */ pre($res);","title":"Null"},{"location":"validation-component/#lowercase","text":"You can validate a string if it is lowercase. If not, the isLower method will convert the string to lowercase. $res = Valid::isLower('SOLITAL'); /* Return string */ pre($res);","title":"Lowercase"},{"location":"validation-component/#uppercase","text":"You can validate a string if it is uppercase. If not, the isUpper method will convert the string to uppercase. $res = Valid::isUpper('solital'); /* Return string */ pre($res);","title":"Uppercase"},{"location":"validation-component/#base64","text":"Checks whether a variable is Base64-type encryption. $hash = base64_encode(\"test\"); $res = Valid::isBase64($hash); /* Return bool */ pre($res);","title":"Base64"},{"location":"validation-component/#identical","text":"Checks if one variable is identical to another. $res = Valid::identical(\"foo\", \"foo\"); /* Return bool */ pre($res);","title":"Identical"},{"location":"validation/","text":"If you are looking for the old Valid class, use this link Introduction Solital has ways to validate data from $_POST and $_FILES requests. This way, you can validate emails, names, passwords, among others, in addition to applying filters to this data. Solital uses the validate method. This method makes use of the wixel/gump component. Getting Started Rules Rules are applied to data coming from $_POST and $_FILES requests. Firstly, you need to have created a controller inside the app/Components/Controller/ folder. After that, you must use the input() helper together with the validate() method. class StoreController { public function index() { $data_rules = [ 'username' => 'required|alpha_numeric|max_len,100|min_len,6', 'password' => 'required|max_len,100|min_len,6', 'email' => 'required|valid_email' ]; $values = input()->validate($data_rules); var_dump($values); } } In the previous example, if the request data is validated according to the defined rules, it will be returned in the variable $values . However, if one of the data does not comply with the rules, an array with index validation_errors will be returned containing the errors. Filters To apply filters to your data, use the second parameter of the validate method. class StoreController { public function index() { $data_rules = [ 'username' => 'required|alpha_numeric|max_len,100|min_len,6', 'password' => 'required|max_len,100|min_len,6', 'email' => 'required|valid_email' ]; $data_filter = [ 'username' => 'upper_case|sanitize_string', 'password' => 'trim', 'email' => 'trim|sanitize_email' ]; $values = input()->validate($data_rules, $data_filter); var_dump($values); } } Creating validation classes To have better control of the validations you perform, you can create your own class that will store all your rules, filters and error messages. To create a validator, you must run the following command: php vinci create:validator MyValidator All validators will be stored in the app/Components/Validator/ folder. Structure All validators you create will implement the RequestValidatorInterface interface. The validator you create will have the following structure: <?php namespace Solital\\Components\\Validator; use Solital\\Core\\Http\\RequestValidatorInterface; class MyValidation implements RequestValidatorInterface { #[\\Override] public function rules(): array { return []; } #[\\Override] public function filters(): array { return []; } #[\\Override] public function messages(): array { return []; } } The rules() and filters() methods will be used for rules and filters. The messages() method will have custom error messages as shown in the example below. #[\\Override] public function messages(): array { return [ 'username' => ['required' => 'Fill the Username field please, its required.'], 'password' => ['required' => 'Please enter a password. This field is empty.'], 'email' => ['valid_email' => 'Please enter a valid e-mail.'] ]; } Using the validator To use the validator you created, you must pass the validator name in the validate() method. use Solital\\Components\\Validator\\MyValidation; class StoreController { public function index() { $values = input()->validate(MyValidation::class); var_dump($values); } } Available Validators Rule Description required Ensures the specified key value exists and is not empty (not null, not empty string, not empty array). contains ,one;two;use array format if one of the values contains semicolons Verify that a value is contained within the pre-defined value set. contains_list ,value1;value2 Verify that a value is contained within the pre-defined value set. Error message will NOT show the list of possible values. doesnt_contain_list ,value1;value2 Verify that a value is contained within the pre-defined value set. Error message will NOT show the list of possible values. boolean ,strict Determine if the provided value is a valid boolean. Returns true for: yes/no, on/off, 1/0, true/false. In strict mode (optional) only true/false will be valid which you can combine with boolean filter. valid_email Determine if the provided email has valid format. max_len ,240 Determine if the provided value length is less or equal to a specific value. min_len ,4 Determine if the provided value length is more or equal to a specific value. exact_len ,5 Determine if the provided value length matches a specific value. between_len ,3;11 Determine if the provided value length is between min and max values. alpha Determine if the provided value contains only alpha characters. alpha_numeric Determine if the provided value contains only alpha-numeric characters. alpha_dash Determine if the provided value contains only alpha characters with dashed and underscores. alpha_numeric_dash Determine if the provided value contains only alpha numeric characters with dashed and underscores. alpha_numeric_space Determine if the provided value contains only alpha numeric characters with spaces. alpha_space Determine if the provided value contains only alpha characters with spaces. numeric Determine if the provided value is a valid number or numeric string. integer Determine if the provided value is a valid integer. float Determine if the provided value is a valid float. valid_url Determine if the provided value is a valid URL. url_exists Determine if a URL exists & is accessible. valid_ip Determine if the provided value is a valid IP address. valid_ipv4 Determine if the provided value is a valid IPv4 address. valid_ipv6 Determine if the provided value is a valid IPv6 address. valid_cc Determine if the input is a valid credit card number. valid_name Determine if the input is a valid human name. street_address Determine if the provided input is likely to be a street address using weak detection. iban Determine if the provided value is a valid IBAN. date ,d/m/Y Determine if the provided input is a valid date (ISO 8601) or specify a custom format (optional). min_age ,18 Determine if the provided input meets age requirement (ISO 8601). Input should be a date (Y-m-d). max_numeric ,50 Determine if the provided numeric value is lower or equal to a specific value. min_numeric ,1 Determine if the provided numeric value is higher or equal to a specific value. starts ,Z Determine if the provided value starts with param. required_file Determine if the file was successfully uploaded. extension ,png;jpg;gif Check the uploaded file for extension. Doesn't check mime-type yet. equalsfield ,other_field_name Determine if the provided field value equals current field value. guidv4 Determine if the provided field value is a valid GUID (v4) phone_number Determine if the provided value is a valid phone number. regex ,/test-[0-9]{3}/ Custom regex validator. valid_json_string Determine if the provided value is a valid JSON string. valid_array_size_greater ,1 Check if an input is an array and if the size is more or equal to a specific value. valid_array_size_lesser ,1 Check if an input is an array and if the size is less or equal to a specific value. valid_array_size_equal ,1 Check if an input is an array and if the size is equal to a specific value. Available Filters Filter rules can also be any PHP native function (e.g.: trim). Filter Description noise_words Replace noise words in a string (http://tax.cchgroup.com/help/Avoiding_noise_words_in_your_search.htm). rmpunctuation Remove all known punctuation from a string. urlencode Sanitize the string by urlencoding characters. htmlencode Sanitize the string by converting HTML characters to their HTML entities. sanitize_email Sanitize the string by removing illegal characters from emails. sanitize_numbers Sanitize the string by removing illegal characters from numbers. sanitize_floats Sanitize the string by removing illegal characters from float numbers. sanitize_string Sanitize the string by removing any script tags. boolean Converts ['1', 1, 'true', true, 'yes', 'on'] to true, anything else is false ('on' is useful for form checkboxes). basic_tags Filter out all HTML tags except the defined basic tags. whole_number Convert the provided numeric value to a whole number. ms_word_characters Convert MS Word special characters to web safe characters. ([\u201c \u201d] => \", [\u2018 \u2019] => ', [\u2013] => -, [\u2026] => ...) lower_case Converts to lowercase. upper_case Converts to uppercase. slug Converts value to url-web-slugs. trim Remove spaces from the beginning and end of strings (PHP).","title":"Validation"},{"location":"validation/#introduction","text":"Solital has ways to validate data from $_POST and $_FILES requests. This way, you can validate emails, names, passwords, among others, in addition to applying filters to this data. Solital uses the validate method. This method makes use of the wixel/gump component.","title":"Introduction"},{"location":"validation/#getting-started","text":"","title":"Getting Started"},{"location":"validation/#rules","text":"Rules are applied to data coming from $_POST and $_FILES requests. Firstly, you need to have created a controller inside the app/Components/Controller/ folder. After that, you must use the input() helper together with the validate() method. class StoreController { public function index() { $data_rules = [ 'username' => 'required|alpha_numeric|max_len,100|min_len,6', 'password' => 'required|max_len,100|min_len,6', 'email' => 'required|valid_email' ]; $values = input()->validate($data_rules); var_dump($values); } } In the previous example, if the request data is validated according to the defined rules, it will be returned in the variable $values . However, if one of the data does not comply with the rules, an array with index validation_errors will be returned containing the errors.","title":"Rules"},{"location":"validation/#filters","text":"To apply filters to your data, use the second parameter of the validate method. class StoreController { public function index() { $data_rules = [ 'username' => 'required|alpha_numeric|max_len,100|min_len,6', 'password' => 'required|max_len,100|min_len,6', 'email' => 'required|valid_email' ]; $data_filter = [ 'username' => 'upper_case|sanitize_string', 'password' => 'trim', 'email' => 'trim|sanitize_email' ]; $values = input()->validate($data_rules, $data_filter); var_dump($values); } }","title":"Filters"},{"location":"validation/#creating-validation-classes","text":"To have better control of the validations you perform, you can create your own class that will store all your rules, filters and error messages. To create a validator, you must run the following command: php vinci create:validator MyValidator All validators will be stored in the app/Components/Validator/ folder.","title":"Creating validation classes"},{"location":"validation/#structure","text":"All validators you create will implement the RequestValidatorInterface interface. The validator you create will have the following structure: <?php namespace Solital\\Components\\Validator; use Solital\\Core\\Http\\RequestValidatorInterface; class MyValidation implements RequestValidatorInterface { #[\\Override] public function rules(): array { return []; } #[\\Override] public function filters(): array { return []; } #[\\Override] public function messages(): array { return []; } } The rules() and filters() methods will be used for rules and filters. The messages() method will have custom error messages as shown in the example below. #[\\Override] public function messages(): array { return [ 'username' => ['required' => 'Fill the Username field please, its required.'], 'password' => ['required' => 'Please enter a password. This field is empty.'], 'email' => ['valid_email' => 'Please enter a valid e-mail.'] ]; }","title":"Structure"},{"location":"validation/#using-the-validator","text":"To use the validator you created, you must pass the validator name in the validate() method. use Solital\\Components\\Validator\\MyValidation; class StoreController { public function index() { $values = input()->validate(MyValidation::class); var_dump($values); } }","title":"Using the validator"},{"location":"validation/#available-validators","text":"Rule Description required Ensures the specified key value exists and is not empty (not null, not empty string, not empty array). contains ,one;two;use array format if one of the values contains semicolons Verify that a value is contained within the pre-defined value set. contains_list ,value1;value2 Verify that a value is contained within the pre-defined value set. Error message will NOT show the list of possible values. doesnt_contain_list ,value1;value2 Verify that a value is contained within the pre-defined value set. Error message will NOT show the list of possible values. boolean ,strict Determine if the provided value is a valid boolean. Returns true for: yes/no, on/off, 1/0, true/false. In strict mode (optional) only true/false will be valid which you can combine with boolean filter. valid_email Determine if the provided email has valid format. max_len ,240 Determine if the provided value length is less or equal to a specific value. min_len ,4 Determine if the provided value length is more or equal to a specific value. exact_len ,5 Determine if the provided value length matches a specific value. between_len ,3;11 Determine if the provided value length is between min and max values. alpha Determine if the provided value contains only alpha characters. alpha_numeric Determine if the provided value contains only alpha-numeric characters. alpha_dash Determine if the provided value contains only alpha characters with dashed and underscores. alpha_numeric_dash Determine if the provided value contains only alpha numeric characters with dashed and underscores. alpha_numeric_space Determine if the provided value contains only alpha numeric characters with spaces. alpha_space Determine if the provided value contains only alpha characters with spaces. numeric Determine if the provided value is a valid number or numeric string. integer Determine if the provided value is a valid integer. float Determine if the provided value is a valid float. valid_url Determine if the provided value is a valid URL. url_exists Determine if a URL exists & is accessible. valid_ip Determine if the provided value is a valid IP address. valid_ipv4 Determine if the provided value is a valid IPv4 address. valid_ipv6 Determine if the provided value is a valid IPv6 address. valid_cc Determine if the input is a valid credit card number. valid_name Determine if the input is a valid human name. street_address Determine if the provided input is likely to be a street address using weak detection. iban Determine if the provided value is a valid IBAN. date ,d/m/Y Determine if the provided input is a valid date (ISO 8601) or specify a custom format (optional). min_age ,18 Determine if the provided input meets age requirement (ISO 8601). Input should be a date (Y-m-d). max_numeric ,50 Determine if the provided numeric value is lower or equal to a specific value. min_numeric ,1 Determine if the provided numeric value is higher or equal to a specific value. starts ,Z Determine if the provided value starts with param. required_file Determine if the file was successfully uploaded. extension ,png;jpg;gif Check the uploaded file for extension. Doesn't check mime-type yet. equalsfield ,other_field_name Determine if the provided field value equals current field value. guidv4 Determine if the provided field value is a valid GUID (v4) phone_number Determine if the provided value is a valid phone number. regex ,/test-[0-9]{3}/ Custom regex validator. valid_json_string Determine if the provided value is a valid JSON string. valid_array_size_greater ,1 Check if an input is an array and if the size is more or equal to a specific value. valid_array_size_lesser ,1 Check if an input is an array and if the size is less or equal to a specific value. valid_array_size_equal ,1 Check if an input is an array and if the size is equal to a specific value.","title":"Available Validators"},{"location":"validation/#available-filters","text":"Filter rules can also be any PHP native function (e.g.: trim). Filter Description noise_words Replace noise words in a string (http://tax.cchgroup.com/help/Avoiding_noise_words_in_your_search.htm). rmpunctuation Remove all known punctuation from a string. urlencode Sanitize the string by urlencoding characters. htmlencode Sanitize the string by converting HTML characters to their HTML entities. sanitize_email Sanitize the string by removing illegal characters from emails. sanitize_numbers Sanitize the string by removing illegal characters from numbers. sanitize_floats Sanitize the string by removing illegal characters from float numbers. sanitize_string Sanitize the string by removing any script tags. boolean Converts ['1', 1, 'true', true, 'yes', 'on'] to true, anything else is false ('on' is useful for form checkboxes). basic_tags Filter out all HTML tags except the defined basic tags. whole_number Convert the provided numeric value to a whole number. ms_word_characters Convert MS Word special characters to web safe characters. ([\u201c \u201d] => \", [\u2018 \u2019] => ', [\u2013] => -, [\u2026] => ...) lower_case Converts to lowercase. upper_case Converts to uppercase. slug Converts value to url-web-slugs. trim Remove spaces from the beginning and end of strings (PHP).","title":"Available Filters"},{"location":"verify-domain/","text":"Sometimes when we create a project for a client or for our work, we want to protect our code so that other people can't use it. Solital has a security method that verifies the domain of your project. If someone else copies your project to another domain, Solital sends you an email letting you know that your project is on a different domain. To do this configuration, you need to edit the bootstrap.yaml file. In the verify_domain -> enable_verification key, change the value to true . verify_domain: enable_verification: false send_to: recipient_name: In the send_to key, add the email that will be used for Solital to notify you about the copy of the project. In the recipient_name key, you will add your name or an alias. When you do this and reload any page in your project, a variable called APP_DOMAIN will be created in the .env file. This variable will contain the domain where your project was made. Obviously, if you are on locahost, you need to change this variable later. The line below is just an example. APP_DOMAIN=\"http://localhost:8000\" This is one more method for the security of your code. Obviously, for greater security, you need to use a private repository on GitHub.","title":"Verify Domain"},{"location":"vinci-console/","text":"Vinci Console is an auxiliary component to help create files faster, such as login structures, password recovery structures, database configuration and more. Access Vinci To access Vinci, open the terminal in your project folder and type php vinci [command] . To access information about Solital and its dependencies, open your terminal inside your project folder and type php vinci version For Windows To run the Vinci console on Windows, remember to add the PHP directory to the Windows PATH. Also check if your version of Windows or your editor supports ANSI characters. List of all commands The Vinci Console is a very simple to use helper. When you run the php vinci list command, you will get a description of all the commands present in the Solital Framework. Example php vinci [command] [argument] [--option1] [--option2] Command Description Arguments Options auth:skeleton Create Login and 'Forgot Password' structures - --login / --forgot / --remove clear-history Clear a command history - - create:cmd Create a command name --remove create:controller Create a Controller class name --remove create:middleware Create a Middleware class name --remove create:migration Create a migration name (optional) - create:model Create a Model class name --remove create:queue Create a Queue class name --remove create:seeder Create a Seeder class name - create:router Create a new router name --comment db:dump Dump the connected database name - db:list List data from a database table - --limit=10 generate:files Imports Solital Framework's default configuration files - - history Get all command history - - migrate Run a migration - --rollback (=value) / --status queue Run a queue - --class (=name) router:list Show all routes - - scanner Find infected files - - schedule Create a schedule class name - seeder Run a user-created Seeder - --class (=name) server Start built-in PHP server - - status Check app status - storage:clear Clear the Solital cache - --cache / --session / --schedules / --log version Describes a command cmd_name - help Displays details about some command - - about Displays the Vinci Console version - list Displays a list of all Solital commands - - Custom Command To create a custom command, you need to run the command php vinci create:cmd [command_name_class] . This command will create a class in the app/Console/Command folder. Below is an example of the command and the created class: Command php vinci create:cmd UserCommand Generated class <?php namespace Solital\\Console\\Command; use Solital\\Core\\Console\\{Command, MessageTrait}; use Solital\\Core\\Console\\Interface\\CommandInterface; class UserCommand extends Command implements CommandInterface { use MessageTrait; /** * @var string */ protected string $command = \"\"; /** * @var array */ protected array $arguments = []; /** * @var array */ protected array $options = []; /** * @var string */ protected string $description = \"\"; /** * @param object $arguments * @param object $options * * @return mixed */ #[\\Override] public function handle(object $arguments, object $options): mixed { return $this; } } Don't forget to use the `Override` attribute in the `handle` method In the $command variable, you will define the custom command that will be executed. The $arguments variable will have an array of values containing all arguments (if your custom command has no arguments, leave this variable empty). The variable $options must contain mandatory options for your command, otherwise use the options dynamically. Lastly, the $description variable will have a short description of what the custom command does. The handle method will contain all the code that will be executed when executing the custom command and should always return a $this or, if necessary, another value. Using Arguments Arguments can be retrieved using the $arguments variable: php vinci user:cmd myArgument protected array $arguments = ['name']; If you pass more arguments than are specified in your command's class, a warning will be displayed. Using Options Options can be returned dynamically, but you must check in the handle method whether an option exists. php vinci user:cmd name --myOption #[\\Override] public function handle(object $arguments, object $options): mixed { if (isset($options->myOption)) { # ... } return $this; } If you have any mandatory options that must be entered when executing the command, you can define these options using the variable $options . protected array $options = ['--myoption', '--withArg=']; In the example above, the command must contain one of the options. If an option requires entering a value, use = next to the option (see the example above: --withArg= ). This will mean that when using this option, the user will enter a value (for example: --withArg=accept ). Input and output commands It is very common to enter an input value on the command line when needed. Using the InputOutput class, you can perform this action. use Solital\\Core\\Console\\InputOutput; $input_output = new InputOutput(); $input_output->dialog('Enter a string: ')->action(function ($message) { echo $message . PHP_EOL; }); The dialog() method will display a message to the user to inform a input value, while the action() method retrieves the value entered on the command line. The action() method performs an action using the previously entered value. This method uses an anonymous function with the variable $message as a parameter. Confirmation box You can also use a \"yes/no\" confirmation, or any other value. use Solital\\Core\\Console\\InputOutput; $input_output = new InputOutput(); $input_output->confirmDialog('What you want?', 'Y', 'N', false); $input_output->confirm(function () { echo \"accepted\" . PHP_EOL; })->refuse(function () { echo \"denied\" . PHP_EOL; }); In the first parameter of the confirmDialog method, you will define the question. The second parameter will be the value of the answer if it is positive, if not, the third parameter will receive the value of the answer if it is negative. The fourth parameter will define if the answer is know sensitive, if not, set it to false . This method must be used together with two other methods: confirm() and refuse() . Customizing colors To customize the colors of the message that is displayed from the CLI, you must use the color() method. To use the available colors, you must use the ColorsEnum enum. use Solital\\Core\\Console\\Output\\ColorsEnum; $input_output = new InputOutput(); $inout_output->color(ColorsEnum::GREEN); Reading passwords By default, the previous methods display input to the user. However, in the case of passwords, you must use the password() method. You can take the entered password and use it in another part of your code. $input_output = new InputOutput(); $password = $input_output->password(\"Enter the password\"); echo $password; Data output to the console To display data in the console, use the ConsoleOutput class. Below are some of the main methods you can use to display messages in a personalized way. use Solital\\Core\\Console\\Output\\ConsoleOutput; ConsoleOutput::success($message, $space); // Display a success message ConsoleOutput::info($message, $space); // Display an information message ConsoleOutput::warning($message, $space); // Displays a warning message ConsoleOutput::error($message, $space); // Displays an error message ConsoleOutput::line($message, $space); // Display a standard message $message : in the first parameter, you will define the message that will be displayed in the console. $space (optional) : if true , adds a margin to the left of the message. After that, to display the message on the command line, use the print() method: ConsoleOutput::success(\"My message\")->print(); Skip lines If you need to skip some lines in the console, you can use the break() method. This method accepts the value true and also int values. // Skip a line ConsoleOutput::success(\"My message\")->print()->break(); // Skip two lines ConsoleOutput::success(\"My message\")->print()->break(true); // Skip three lines. Use an INT value ConsoleOutput::success(\"My message\")->print()->break(3); Stop script execution To stop script execution when displaying a message on the console, use the exit() method. ConsoleOutput::success(\"My message\")->print()->exit(); This method uses the native PHP function exit() . You can also add a message to this function. ConsoleOutput::success(\"My message\")->print()->exit(\"My exit message\"); Customize message color If you want to add a custom color to your message, you must use the message method. You must make use of the Enum ColorsEnum . This enum has forground and background colors. However, if you want to use any type of color, then you must use the color number instead of the Enum. use Solital\\Core\\Console\\Output\\ColorsEnum; // With ColorsEnum ConsoleOutput::message(\"My message\", ColorsEnum::LIGHT_BLUE)->print(); // With custom color ConsoleOutput::message(\"My message\", 49)->print(); To display all foreground and background colors that do not exist in ColorsEnum , you can use the methods below. echo ConsoleOutput::getForegroundColors() . PHP_EOL; echo ConsoleOutput::getBackgroundColors(); Displaying banners Banners are large messages intended to display important information. Use the banner() method. ConsoleOutput::banner(\"My message\", ColorsEnum::BG_BLUE)->print(); If you need to increase or decrease the banner size, change the third parameter. ConsoleOutput::banner(\"My message\", ColorsEnum::BG_BLUE, 40)->print(); If you use `ColorsEnum`, use values that start with `BG_` Debug messages There is a different type of display message used for debugging using the debugMessage() method. ConsoleOutput::debugMessage(\"My message\", $title, $color)->print(); $title (optional) : The title that will be displayed indicating the debug value. $color (optional) : color using ColorsEnum or an integer number. If you use `ColorsEnum`, use values that start with `BG_` Clearing console messages To clear a message from the console, you can use the clear() method, informing, if necessary, the time it will take (in seconds) for the message to be cleared. ConsoleOutput::success(\"My message\")->print(); // Without time ConsoleOutput::clear(); // With time ConsoleOutput::clear(2); Checking closure time If you want to display the execution time of a method or function in the console, you can use the status() method. This method displays whether a method or function was executed correctly or whether there was an error through a Boolean return. If the return is not Boolean, a simple message is displayed. You must add in the first parameter the name of the task that the method or function is doing. For example, if you are saving a user to the database, you can add creating_user . The second parameter will be the closure. To display the status, you must use the printStatus() method. ConsoleOutput::status('creating_user', function () { return true; })->printStatus(); In the previous example, the return is true . Therefore, an OK will be displayed in the console. If the return is false , an ERROR will be displayed. To customize these messages, you must add values to the parameters of the printStatus() method. You can also disable the script time display. ConsoleOutput::status('creating_user', function () { return true; })->printStatus('accept', 'not accept', false); Calling a command within another If you have a command, and want to call another command within the same class, you can use the call() method. For example, you have an InsertCommand class: <?php namespace Solital\\Console\\Command; use Solital\\Core\\Console\\Command; use Solital\\Core\\Console\\Interface\\CommandInterface; class InsertCommand extends Command implements CommandInterface { /** * @var string */ protected string $command = \"cmd:insert\"; /** * @var array */ protected array $arguments = []; /** * @var array */ protected array $options = []; /** * @var string */ protected string $description = \"\"; /** * @param object $arguments * @param object $options * * @return mixed */ #[\\Override] public function handle(object $arguments, object $options): mixed { echo \"Insert a value\"; return $this; } } And you also have an UpdateCommand class. You can execute the command from the previous class within this new class. <?php namespace Solital\\Console\\Command; use Solital\\Core\\Console\\Command; use Solital\\Core\\Console\\Interface\\CommandInterface; class UpdateCommand extends Command implements CommandInterface { /** * @var string */ protected string $command = \"cmd:update\"; /** * @var array */ protected array $arguments = []; /** * @var array */ protected array $options = []; /** * @var string */ protected string $description = \"\"; /** * @param object $arguments * @param object $options * * @return mixed */ #[\\Override] public function handle(object $arguments, object $options): mixed { Command::call('cmd:insert'); return $this; } } You cannot call the same command on the same classe Progress Bar Progressbar has customizable names, colors, datatypes, error handling, and more. Usage use Solital\\Core\\Console\\ProgressBar\\ProgressBar; use Solital\\Core\\Console\\ProgressBar\\ProgressBarStyle; //Lets create a style object first. //Style object has 4 parameters {$name, $color, $datatype, $length}. $progressbar_style = new ProgressBarStyle(\"Downloading\", \"white\", \"Kb\", 16); //Now lets create the progressbar object. //Progressbar object has 2 parameters {$styleobject, $initialmax} $progressbar = new ProgressBar($progressbar_style, 1000); Using the Progressbar //Loop until the progressbar is complete for ($i = 0; $i < $progressbar->GetInitialMax(); $i++) { $progressbar->step(); usleep(1000); } Methods //Increases the progressbar value by 1. $progressbar->step(); //Increases the progressbar value by x. $progressbar->stepBy(x); //Changes the progressbar value to x. $progressbar->stepTo(x); //Gets the progressbar value. $progressbar->getValue(); //Gets the max initial value. $progressbar->getInitialMax(); //Forces a redraw on the progressbar. $progressbar->update(); //Enables the pause mode, it can be removed by using any of the step methods or forcing a redraw. $progressbar->pauseProgressbar(); //Resets the progressbar object. $progressbar->resetProgressbar(); //Terminates the progressbar and resets the object. $progressbar->terminateProgressbar(); Table You can create tables in the console. To do this, use the Table class. use Solital\\Core\\Console\\Table; $table = new Table(); $table->row([ 'id' => 1, 'name' => 'Matthew S.', 'surname' => 'Kramer', 'email' => 'matthew@example.com', 'status' => true, ]); $table->row([ 'id' => 2, 'name' => 'Millie J.', 'surname' => 'Koenig', 'email' => 'millie@example.com', 'status' => false, ]); $table->row([ 'id' => 3, 'name' => 'Regina G.', 'surname' => 'Hart', 'email' => 'regina@example.com', 'status' => true, ]); echo $table; Output : Styled use Solital\\Core\\Console\\Table; $table = new Table(); $table->setBorderStyle(Table::COLOR_BLUE); $table->setCellStyle(Table::COLOR_GREEN); $table->setHeaderStyle(Table::COLOR_RED, Table::BOLD); $table->setColumnCellStyle('id', Table::ITALIC, Table::COLOR_LIGHT_YELLOW); $table->setColumnCellStyle('email', Table::BOLD, Table::ITALIC); $table->row([ 'id' => 1, 'name' => 'Matthew S.', 'surname' => 'Kramer', 'email' => 'matthew@example.com', 'status' => true, ]); $table->row([ 'id' => 2, 'name' => 'Millie J.', 'surname' => 'Koenig', 'email' => 'millie@example.com', 'status' => false, ]); $table->row([ 'id' => 3, 'name' => 'Regina G.', 'surname' => 'Hart', 'email' => 'regina@example.com', 'status' => true, ]); echo $table; Output : Credits - Muhammet \u015eAFAK Dynamic Rows If you need a standard header and just add the values, use the dynamicRows method. use Solital\\Core\\Console\\Table; $header = ['name', 'email', 'age']; $values = [ ['Foo', 'foo@email.com', 20], ['Bar', 'bar@email.com', 30] ]; $table = new Table(); $table->setHeaderStyle(Table::COLOR_LIGHT_GREEN); $table->dynamicRows($header, $values); Formatted Row Formatted lines are a way of organizing data that contains some additional information. You can see an example of this method in use by running the php vinci list command. use Solital\\Core\\Console\\Table; $values = [ 'user' => 'Admin', 'email' => 'admin@gmail.com' ]; Table::formattedRowData($values); The second parameter you can define the spacing between the information. In the third parameter you can create a margin on the left side. use Solital\\Core\\Console\\Table; $values = [ 'user' => 'Admin', 'email' => 'admin@gmail.com' ]; Table::formattedRowData($values, 50, true);","title":"Vinci Console"},{"location":"vinci-console/#access-vinci","text":"To access Vinci, open the terminal in your project folder and type php vinci [command] . To access information about Solital and its dependencies, open your terminal inside your project folder and type php vinci version","title":"Access Vinci"},{"location":"vinci-console/#for-windows","text":"To run the Vinci console on Windows, remember to add the PHP directory to the Windows PATH. Also check if your version of Windows or your editor supports ANSI characters.","title":"For Windows"},{"location":"vinci-console/#list-of-all-commands","text":"The Vinci Console is a very simple to use helper. When you run the php vinci list command, you will get a description of all the commands present in the Solital Framework. Example php vinci [command] [argument] [--option1] [--option2] Command Description Arguments Options auth:skeleton Create Login and 'Forgot Password' structures - --login / --forgot / --remove clear-history Clear a command history - - create:cmd Create a command name --remove create:controller Create a Controller class name --remove create:middleware Create a Middleware class name --remove create:migration Create a migration name (optional) - create:model Create a Model class name --remove create:queue Create a Queue class name --remove create:seeder Create a Seeder class name - create:router Create a new router name --comment db:dump Dump the connected database name - db:list List data from a database table - --limit=10 generate:files Imports Solital Framework's default configuration files - - history Get all command history - - migrate Run a migration - --rollback (=value) / --status queue Run a queue - --class (=name) router:list Show all routes - - scanner Find infected files - - schedule Create a schedule class name - seeder Run a user-created Seeder - --class (=name) server Start built-in PHP server - - status Check app status - storage:clear Clear the Solital cache - --cache / --session / --schedules / --log version Describes a command cmd_name - help Displays details about some command - - about Displays the Vinci Console version - list Displays a list of all Solital commands - -","title":"List of all commands"},{"location":"vinci-console/#custom-command","text":"To create a custom command, you need to run the command php vinci create:cmd [command_name_class] . This command will create a class in the app/Console/Command folder. Below is an example of the command and the created class: Command php vinci create:cmd UserCommand Generated class <?php namespace Solital\\Console\\Command; use Solital\\Core\\Console\\{Command, MessageTrait}; use Solital\\Core\\Console\\Interface\\CommandInterface; class UserCommand extends Command implements CommandInterface { use MessageTrait; /** * @var string */ protected string $command = \"\"; /** * @var array */ protected array $arguments = []; /** * @var array */ protected array $options = []; /** * @var string */ protected string $description = \"\"; /** * @param object $arguments * @param object $options * * @return mixed */ #[\\Override] public function handle(object $arguments, object $options): mixed { return $this; } }","title":"Custom Command"},{"location":"vinci-console/#input-and-output-commands","text":"It is very common to enter an input value on the command line when needed. Using the InputOutput class, you can perform this action. use Solital\\Core\\Console\\InputOutput; $input_output = new InputOutput(); $input_output->dialog('Enter a string: ')->action(function ($message) { echo $message . PHP_EOL; }); The dialog() method will display a message to the user to inform a input value, while the action() method retrieves the value entered on the command line. The action() method performs an action using the previously entered value. This method uses an anonymous function with the variable $message as a parameter.","title":"Input and output commands"},{"location":"vinci-console/#confirmation-box","text":"You can also use a \"yes/no\" confirmation, or any other value. use Solital\\Core\\Console\\InputOutput; $input_output = new InputOutput(); $input_output->confirmDialog('What you want?', 'Y', 'N', false); $input_output->confirm(function () { echo \"accepted\" . PHP_EOL; })->refuse(function () { echo \"denied\" . PHP_EOL; }); In the first parameter of the confirmDialog method, you will define the question. The second parameter will be the value of the answer if it is positive, if not, the third parameter will receive the value of the answer if it is negative. The fourth parameter will define if the answer is know sensitive, if not, set it to false . This method must be used together with two other methods: confirm() and refuse() .","title":"Confirmation box"},{"location":"vinci-console/#customizing-colors","text":"To customize the colors of the message that is displayed from the CLI, you must use the color() method. To use the available colors, you must use the ColorsEnum enum. use Solital\\Core\\Console\\Output\\ColorsEnum; $input_output = new InputOutput(); $inout_output->color(ColorsEnum::GREEN);","title":"Customizing colors"},{"location":"vinci-console/#reading-passwords","text":"By default, the previous methods display input to the user. However, in the case of passwords, you must use the password() method. You can take the entered password and use it in another part of your code. $input_output = new InputOutput(); $password = $input_output->password(\"Enter the password\"); echo $password;","title":"Reading passwords"},{"location":"vinci-console/#data-output-to-the-console","text":"To display data in the console, use the ConsoleOutput class. Below are some of the main methods you can use to display messages in a personalized way. use Solital\\Core\\Console\\Output\\ConsoleOutput; ConsoleOutput::success($message, $space); // Display a success message ConsoleOutput::info($message, $space); // Display an information message ConsoleOutput::warning($message, $space); // Displays a warning message ConsoleOutput::error($message, $space); // Displays an error message ConsoleOutput::line($message, $space); // Display a standard message $message : in the first parameter, you will define the message that will be displayed in the console. $space (optional) : if true , adds a margin to the left of the message. After that, to display the message on the command line, use the print() method: ConsoleOutput::success(\"My message\")->print();","title":"Data output to the console"},{"location":"vinci-console/#skip-lines","text":"If you need to skip some lines in the console, you can use the break() method. This method accepts the value true and also int values. // Skip a line ConsoleOutput::success(\"My message\")->print()->break(); // Skip two lines ConsoleOutput::success(\"My message\")->print()->break(true); // Skip three lines. Use an INT value ConsoleOutput::success(\"My message\")->print()->break(3);","title":"Skip lines"},{"location":"vinci-console/#stop-script-execution","text":"To stop script execution when displaying a message on the console, use the exit() method. ConsoleOutput::success(\"My message\")->print()->exit(); This method uses the native PHP function exit() . You can also add a message to this function. ConsoleOutput::success(\"My message\")->print()->exit(\"My exit message\");","title":"Stop script execution"},{"location":"vinci-console/#customize-message-color","text":"If you want to add a custom color to your message, you must use the message method. You must make use of the Enum ColorsEnum . This enum has forground and background colors. However, if you want to use any type of color, then you must use the color number instead of the Enum. use Solital\\Core\\Console\\Output\\ColorsEnum; // With ColorsEnum ConsoleOutput::message(\"My message\", ColorsEnum::LIGHT_BLUE)->print(); // With custom color ConsoleOutput::message(\"My message\", 49)->print(); To display all foreground and background colors that do not exist in ColorsEnum , you can use the methods below. echo ConsoleOutput::getForegroundColors() . PHP_EOL; echo ConsoleOutput::getBackgroundColors();","title":"Customize message color"},{"location":"vinci-console/#displaying-banners","text":"Banners are large messages intended to display important information. Use the banner() method. ConsoleOutput::banner(\"My message\", ColorsEnum::BG_BLUE)->print(); If you need to increase or decrease the banner size, change the third parameter. ConsoleOutput::banner(\"My message\", ColorsEnum::BG_BLUE, 40)->print();","title":"Displaying banners"},{"location":"vinci-console/#debug-messages","text":"There is a different type of display message used for debugging using the debugMessage() method. ConsoleOutput::debugMessage(\"My message\", $title, $color)->print(); $title (optional) : The title that will be displayed indicating the debug value. $color (optional) : color using ColorsEnum or an integer number.","title":"Debug messages"},{"location":"vinci-console/#clearing-console-messages","text":"To clear a message from the console, you can use the clear() method, informing, if necessary, the time it will take (in seconds) for the message to be cleared. ConsoleOutput::success(\"My message\")->print(); // Without time ConsoleOutput::clear(); // With time ConsoleOutput::clear(2);","title":"Clearing console messages"},{"location":"vinci-console/#checking-closure-time","text":"If you want to display the execution time of a method or function in the console, you can use the status() method. This method displays whether a method or function was executed correctly or whether there was an error through a Boolean return. If the return is not Boolean, a simple message is displayed. You must add in the first parameter the name of the task that the method or function is doing. For example, if you are saving a user to the database, you can add creating_user . The second parameter will be the closure. To display the status, you must use the printStatus() method. ConsoleOutput::status('creating_user', function () { return true; })->printStatus(); In the previous example, the return is true . Therefore, an OK will be displayed in the console. If the return is false , an ERROR will be displayed. To customize these messages, you must add values to the parameters of the printStatus() method. You can also disable the script time display. ConsoleOutput::status('creating_user', function () { return true; })->printStatus('accept', 'not accept', false);","title":"Checking closure time"},{"location":"vinci-console/#calling-a-command-within-another","text":"If you have a command, and want to call another command within the same class, you can use the call() method. For example, you have an InsertCommand class: <?php namespace Solital\\Console\\Command; use Solital\\Core\\Console\\Command; use Solital\\Core\\Console\\Interface\\CommandInterface; class InsertCommand extends Command implements CommandInterface { /** * @var string */ protected string $command = \"cmd:insert\"; /** * @var array */ protected array $arguments = []; /** * @var array */ protected array $options = []; /** * @var string */ protected string $description = \"\"; /** * @param object $arguments * @param object $options * * @return mixed */ #[\\Override] public function handle(object $arguments, object $options): mixed { echo \"Insert a value\"; return $this; } } And you also have an UpdateCommand class. You can execute the command from the previous class within this new class. <?php namespace Solital\\Console\\Command; use Solital\\Core\\Console\\Command; use Solital\\Core\\Console\\Interface\\CommandInterface; class UpdateCommand extends Command implements CommandInterface { /** * @var string */ protected string $command = \"cmd:update\"; /** * @var array */ protected array $arguments = []; /** * @var array */ protected array $options = []; /** * @var string */ protected string $description = \"\"; /** * @param object $arguments * @param object $options * * @return mixed */ #[\\Override] public function handle(object $arguments, object $options): mixed { Command::call('cmd:insert'); return $this; } }","title":"Calling a command within another"},{"location":"vinci-console/#progress-bar","text":"Progressbar has customizable names, colors, datatypes, error handling, and more. Usage use Solital\\Core\\Console\\ProgressBar\\ProgressBar; use Solital\\Core\\Console\\ProgressBar\\ProgressBarStyle; //Lets create a style object first. //Style object has 4 parameters {$name, $color, $datatype, $length}. $progressbar_style = new ProgressBarStyle(\"Downloading\", \"white\", \"Kb\", 16); //Now lets create the progressbar object. //Progressbar object has 2 parameters {$styleobject, $initialmax} $progressbar = new ProgressBar($progressbar_style, 1000); Using the Progressbar //Loop until the progressbar is complete for ($i = 0; $i < $progressbar->GetInitialMax(); $i++) { $progressbar->step(); usleep(1000); } Methods //Increases the progressbar value by 1. $progressbar->step(); //Increases the progressbar value by x. $progressbar->stepBy(x); //Changes the progressbar value to x. $progressbar->stepTo(x); //Gets the progressbar value. $progressbar->getValue(); //Gets the max initial value. $progressbar->getInitialMax(); //Forces a redraw on the progressbar. $progressbar->update(); //Enables the pause mode, it can be removed by using any of the step methods or forcing a redraw. $progressbar->pauseProgressbar(); //Resets the progressbar object. $progressbar->resetProgressbar(); //Terminates the progressbar and resets the object. $progressbar->terminateProgressbar();","title":"Progress Bar"},{"location":"vinci-console/#table","text":"You can create tables in the console. To do this, use the Table class. use Solital\\Core\\Console\\Table; $table = new Table(); $table->row([ 'id' => 1, 'name' => 'Matthew S.', 'surname' => 'Kramer', 'email' => 'matthew@example.com', 'status' => true, ]); $table->row([ 'id' => 2, 'name' => 'Millie J.', 'surname' => 'Koenig', 'email' => 'millie@example.com', 'status' => false, ]); $table->row([ 'id' => 3, 'name' => 'Regina G.', 'surname' => 'Hart', 'email' => 'regina@example.com', 'status' => true, ]); echo $table; Output :","title":"Table"},{"location":"vinci-console/#styled","text":"use Solital\\Core\\Console\\Table; $table = new Table(); $table->setBorderStyle(Table::COLOR_BLUE); $table->setCellStyle(Table::COLOR_GREEN); $table->setHeaderStyle(Table::COLOR_RED, Table::BOLD); $table->setColumnCellStyle('id', Table::ITALIC, Table::COLOR_LIGHT_YELLOW); $table->setColumnCellStyle('email', Table::BOLD, Table::ITALIC); $table->row([ 'id' => 1, 'name' => 'Matthew S.', 'surname' => 'Kramer', 'email' => 'matthew@example.com', 'status' => true, ]); $table->row([ 'id' => 2, 'name' => 'Millie J.', 'surname' => 'Koenig', 'email' => 'millie@example.com', 'status' => false, ]); $table->row([ 'id' => 3, 'name' => 'Regina G.', 'surname' => 'Hart', 'email' => 'regina@example.com', 'status' => true, ]); echo $table; Output : Credits - Muhammet \u015eAFAK","title":"Styled"},{"location":"vinci-console/#dynamic-rows","text":"If you need a standard header and just add the values, use the dynamicRows method. use Solital\\Core\\Console\\Table; $header = ['name', 'email', 'age']; $values = [ ['Foo', 'foo@email.com', 20], ['Bar', 'bar@email.com', 30] ]; $table = new Table(); $table->setHeaderStyle(Table::COLOR_LIGHT_GREEN); $table->dynamicRows($header, $values);","title":"Dynamic Rows"},{"location":"vinci-console/#formatted-row","text":"Formatted lines are a way of organizing data that contains some additional information. You can see an example of this method in use by running the php vinci list command. use Solital\\Core\\Console\\Table; $values = [ 'user' => 'Admin', 'email' => 'admin@gmail.com' ]; Table::formattedRowData($values); The second parameter you can define the spacing between the information. In the third parameter you can create a margin on the left side. use Solital\\Core\\Console\\Table; $values = [ 'user' => 'Admin', 'email' => 'admin@gmail.com' ]; Table::formattedRowData($values, 50, true);","title":"Formatted Row"},{"location":"wolf-template/","text":"Wolf is Solital's default template engine. With Wolf, you can display any HTML, CSS and JavaScript code. Wolf has the following features: generate views cache; extend other views; minify CSS and JS files; use native HTML files. You can load any template into the resource/views folder Basic To use the Wolf Template, you can use the view() helper, or create an instance of the Wolf class. use Solital\\Core\\Wolf\\Wolf; // With helper Course::get('/', function () { return view('welcome'); }); // With instance Course::get('/', function () { $wolf = new Wolf(); $wolf->setView('welcome'); return $wolf->render(); }); Markers in Wolf Wolf uses markers to interpret PHP code within views. That is, when using {{ }} , Wolf will interpret these characters as <?= ?> . Likewise, when using {% %} , Wolf will interpret it as <?php ?> . That way, you can use native PHP code inside your views using the bookmarks. Parameters To display data for your view, use the second parameter of the view helper or setArgs method. // With helper Course::get('/', function () { return view('welcome', [ 'title' => 'My Title' ]); }); // With instance Course::get('/', function () { $wolf = new Wolf(); $wolf->setArgs([ 'title' => 'My Title' ]); $wolf->setView('welcome'); return $wolf->render(); }); And in your home.php , retrieve the value informed in this way: <title>{{ title }}</title> Wolf automatically escapes special characters. If you want to disable this function, use false in the second parameter. // In helper view('welcome', [ 'xss' => '<script>alert(\"hello\")</script>' ], false); // In method $wolf->setArgs([ 'xss' => '<script>alert(\"hello\")</script>' ], false); Loading CSS, JS and images Make sure the files exist in the folder public/assets/_css , public/assets/_js and public/assets/_img To load a CSS file, use the static load_css method in your template. <link rel=\"stylesheet\" href=\"{{ load_css('style.css'); }}\"> To load a JS file, use the static load_js method in your template. <link rel=\"stylesheet\" href=\"{{ load_js('file.js'); }}\"> To load a image file, use the static load_img method in your template. <img src=\"{{ load_img('image.png'); }}\"> To load a file outside the _css , _js and _img folder, use the load_file method. <img src=\"{{ load_file('path/for/your/file'); }}\"> Cache templates Cache on all pages If you have a template that takes a long time to load, or is rarely accessed, consider creating a cache of that template. Wolf's cache works as follows: a page is loaded, then a page identical to the one that was loaded with all the data already saved in cache is created. When reloading, if this page is still valid, the page's cache will be displayed. To cache your views, edit the bootstrap.yaml file: wolf_cache: enabled: true # false time: minute # minute, hour, day, week In time , you can define if you want to cache your views for 1 minute, 1 hour, 1 day or 1 week. Cache on a single page If you don't want to create a cache file for all templates, consider using the setCacheTime method before setView method to generate a cache file for each template. This class will create a cache file just for a single view (or for several if you add this class in the Controller's constructor). The syntax below shows how long the template can be cached. // minute - hour - day - week $wolf->setCacheTime('week'); Minify Assets Having to load multiple CSS and Javascript files can be a lot of work and can be a burden on the site. However, you can minify all of these files into a single CSS and JS file. By default, assets are loaded into the public/assets/ folder. However, there is a second assets folder inside specific resource/ to minify the CSS/JS files. If you want to generate a minified file for your assets, first add your CSS and JavaScript files to the resource/assets folder. Then edit the bootstrap.yaml file. wolf_minify: false style : minify only CSS files script : minify only JS files all : minify CSS and JS files false : don't minify files Load minified files into the template The load_min_css() and load_min_js() functions will load all files that are minified, without having to use the load_css() and load_js() functions. # Load minify CSS <link rel=\"stylesheet\" href=\"{{ load_min_css() }}\"> # Load minify JS <script src=\"{{ load_min_js() }}\"><script> Extending templates It is very common for developers to create a header.php file and include it in other files. With Wolf this is also possible using the extend method. The extend method includes any template that is inside the resource/view folder. {% extend('header') %} It is not necessary to inform the file extension, just use the file home without the extension. View inside a folder If you want to extend a view inside a folder, use a (.) separator. {% extend('auth.header') %} Conditionals Production and development mode If you want a code to be displayed only in production mode or only in development mode, you can use the production and development methods. {% production %} <!-- This code will only be displayed in production mode --> {% endproduction %} {% development %} <!-- This code will only be displayed in development mode --> {% enddevelopment %} Conditional if true If there is a variable or element that you want to display if another element is true, use the conditional helper. {% $is_error = true; %} <span class=\"{{ conditional('text-danger', $is_error) }}\">DANGER!!!</span> <!-- <span class=\"text-danger\">DANGER!!!</span> -->","title":"Wolf Template"},{"location":"wolf-template/#basic","text":"To use the Wolf Template, you can use the view() helper, or create an instance of the Wolf class. use Solital\\Core\\Wolf\\Wolf; // With helper Course::get('/', function () { return view('welcome'); }); // With instance Course::get('/', function () { $wolf = new Wolf(); $wolf->setView('welcome'); return $wolf->render(); });","title":"Basic"},{"location":"wolf-template/#markers-in-wolf","text":"Wolf uses markers to interpret PHP code within views. That is, when using {{ }} , Wolf will interpret these characters as <?= ?> . Likewise, when using {% %} , Wolf will interpret it as <?php ?> . That way, you can use native PHP code inside your views using the bookmarks.","title":"Markers in Wolf"},{"location":"wolf-template/#parameters","text":"To display data for your view, use the second parameter of the view helper or setArgs method. // With helper Course::get('/', function () { return view('welcome', [ 'title' => 'My Title' ]); }); // With instance Course::get('/', function () { $wolf = new Wolf(); $wolf->setArgs([ 'title' => 'My Title' ]); $wolf->setView('welcome'); return $wolf->render(); }); And in your home.php , retrieve the value informed in this way: <title>{{ title }}</title> Wolf automatically escapes special characters. If you want to disable this function, use false in the second parameter. // In helper view('welcome', [ 'xss' => '<script>alert(\"hello\")</script>' ], false); // In method $wolf->setArgs([ 'xss' => '<script>alert(\"hello\")</script>' ], false);","title":"Parameters"},{"location":"wolf-template/#loading-css-js-and-images","text":"Make sure the files exist in the folder public/assets/_css , public/assets/_js and public/assets/_img To load a CSS file, use the static load_css method in your template. <link rel=\"stylesheet\" href=\"{{ load_css('style.css'); }}\"> To load a JS file, use the static load_js method in your template. <link rel=\"stylesheet\" href=\"{{ load_js('file.js'); }}\"> To load a image file, use the static load_img method in your template. <img src=\"{{ load_img('image.png'); }}\"> To load a file outside the _css , _js and _img folder, use the load_file method. <img src=\"{{ load_file('path/for/your/file'); }}\">","title":"Loading CSS, JS and images"},{"location":"wolf-template/#cache-templates","text":"Cache on all pages If you have a template that takes a long time to load, or is rarely accessed, consider creating a cache of that template. Wolf's cache works as follows: a page is loaded, then a page identical to the one that was loaded with all the data already saved in cache is created. When reloading, if this page is still valid, the page's cache will be displayed. To cache your views, edit the bootstrap.yaml file: wolf_cache: enabled: true # false time: minute # minute, hour, day, week In time , you can define if you want to cache your views for 1 minute, 1 hour, 1 day or 1 week. Cache on a single page If you don't want to create a cache file for all templates, consider using the setCacheTime method before setView method to generate a cache file for each template. This class will create a cache file just for a single view (or for several if you add this class in the Controller's constructor). The syntax below shows how long the template can be cached. // minute - hour - day - week $wolf->setCacheTime('week');","title":"Cache templates"},{"location":"wolf-template/#minify-assets","text":"Having to load multiple CSS and Javascript files can be a lot of work and can be a burden on the site. However, you can minify all of these files into a single CSS and JS file. By default, assets are loaded into the public/assets/ folder. However, there is a second assets folder inside specific resource/ to minify the CSS/JS files. If you want to generate a minified file for your assets, first add your CSS and JavaScript files to the resource/assets folder. Then edit the bootstrap.yaml file. wolf_minify: false style : minify only CSS files script : minify only JS files all : minify CSS and JS files false : don't minify files","title":"Minify Assets"},{"location":"wolf-template/#load-minified-files-into-the-template","text":"The load_min_css() and load_min_js() functions will load all files that are minified, without having to use the load_css() and load_js() functions. # Load minify CSS <link rel=\"stylesheet\" href=\"{{ load_min_css() }}\"> # Load minify JS <script src=\"{{ load_min_js() }}\"><script>","title":"Load minified files into the template"},{"location":"wolf-template/#extending-templates","text":"It is very common for developers to create a header.php file and include it in other files. With Wolf this is also possible using the extend method. The extend method includes any template that is inside the resource/view folder. {% extend('header') %} It is not necessary to inform the file extension, just use the file home without the extension.","title":"Extending templates"},{"location":"wolf-template/#view-inside-a-folder","text":"If you want to extend a view inside a folder, use a (.) separator. {% extend('auth.header') %}","title":"View inside a folder"},{"location":"wolf-template/#conditionals","text":"","title":"Conditionals"},{"location":"wolf-template/#production-and-development-mode","text":"If you want a code to be displayed only in production mode or only in development mode, you can use the production and development methods. {% production %} <!-- This code will only be displayed in production mode --> {% endproduction %} {% development %} <!-- This code will only be displayed in development mode --> {% enddevelopment %}","title":"Production and development mode"},{"location":"wolf-template/#conditional-if-true","text":"If there is a variable or element that you want to display if another element is true, use the conditional helper. {% $is_error = true; %} <span class=\"{{ conditional('text-danger', $is_error) }}\">DANGER!!!</span> <!-- <span class=\"text-danger\">DANGER!!!</span> -->","title":"Conditional if true"},{"location":"yaml-files/","text":"The YAML files that are inside the app/config folder are used to change Solital Framework configurations, such as middlewares, authentication, passwords, among others. These files are updated whenever there is a Solital Core update. Updating YAML files To update the YAML files, run the following command: php vinci generate:files When you install a new Solital update using composer update , run the above command, so new files are copied to the app/config folder. Other files may be copied to other folders in this process. Changing settings at runtime Solital uses the runtime.yaml file to change settings at runtime. Feel free to change these values.","title":"YAML Files"},{"location":"yaml-files/#updating-yaml-files","text":"To update the YAML files, run the following command: php vinci generate:files When you install a new Solital update using composer update , run the above command, so new files are copied to the app/config folder. Other files may be copied to other folders in this process.","title":"Updating YAML files"},{"location":"yaml-files/#changing-settings-at-runtime","text":"Solital uses the runtime.yaml file to change settings at runtime. Feel free to change these values.","title":"Changing settings at runtime"}]}